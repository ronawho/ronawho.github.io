

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Arrays &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Slices" href="slices.html" />
    <link rel="prev" title="Domains" href="domains.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "primers/arrays";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Primers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#iterators">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#task-parallelism">Task Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#locality">Locality</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-parallelism">Data Parallelism</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="slices.html">Slices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sparse.html">Sparse Domains and Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="associative.html">Associative Domains and Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="reductions.html">Reductions</a></li>
<li class="toctree-l3"><a class="reference internal" href="distributions.html">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="replicated.html">Replicated Distribution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#library-utilities">Library Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#numerical-libraries">Numerical Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-overview">Language Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Primers</a> &raquo;</li>
        
      <li>Arrays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/primers/arrays.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="arrays">
<span id="primers-arrays"></span><h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/chapel-lang/chapel/blob/master/test/release/examples/primers/arrays.chpl">View arrays.chpl on GitHub</a></p>
<p>This primer is a tutorial on Chapel rectangular arrays and domains.</p>
<p>Arrays in Chapel are specified using a square-bracketed expression
that specifies the array’s index set, followed by the array’s
element type.  Rectangular arrays are those whose indices are
integers or tuples of integers, supporting standard
multidimensional, rectilinear index sets.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></div>
</div>
<p>Declare an array of five 64-bit real values:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>Like other variable types in Chapel, arrays are initialized so that
each element stores its default value.  So our array of real values
above will default to an array of the value 0.0.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>Arrays can also be declared using the the array literal syntax.
Array literals are specified by enclosing a comma separated list of
expressions in square brackets.  The domain of the array will be
0-based, and the type of the array’s element is the type of the
first element listed.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A2</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.5</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, A2 is: &quot;</span><span class="p">,</span> <span class="nx">A2</span><span class="p">);</span>
</pre></div>
</div>
<p>Arrays can be accessed using scalar index values of the appropriate
type, using either parentheses or square brackets:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning two elements, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>Arrays can also be accessed using ranges to refer to subsets of
array elements, or sub-arrays, using a technique called slicing:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.3</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning its interior values, A is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>Just like with array indexing, either square brackets or parentheses
can be used for array slicing:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;A(2..4) is: &quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">4</span><span class="p">),</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note: further information on slicing can be found in the
<a class="reference internal" href="slices.html#primers-slices"><span class="std std-ref">Slices Primer</span></a></p>
<p>Arrays can be multidimensional as well:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">B</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>

<span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">}</span> <span class="k">do</span>
  <span class="nx">B</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>An array’s elements can be iterated over in a for or forall loop,
which causes the index variable to store references to an array’s
elements:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="nx">b</span> <span class="kd">in</span> <span class="nx">B</span> <span class="k">do</span>
  <span class="nx">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After incrementing B&#39;s elements, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>An array’s index set is referred to as a domain – a first-class
language concept that stores the set of indices used to access the
array.  The arrays A and B above are respectively declared with the
anonymous but explicit domains <code class="docutils literal notranslate"><span class="pre">{1..n}</span></code> and <code class="docutils literal notranslate"><span class="pre">{1..n,</span> <span class="pre">1..n}</span></code>.
Array A2 above is declared with the implicit domain <code class="docutils literal notranslate"><span class="pre">{0..4}</span></code>.  An
array’s domain can be accessed using the <code class="docutils literal notranslate"><span class="pre">.domain</span></code> method:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">B</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
  <span class="nx">B</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After decrementing B&#39;s elements, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Domains can also be queried when arrays are passed to functions
in order to refer to the domain via a new identifier within the
context of that function:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">printArr</span><span class="p">(</span><span class="nx">B</span><span class="p">);</span>

<span class="k">proc</span> <span class="nf">printArr</span><span class="p">(</span><span class="nx">X</span><span class="p">:</span> <span class="p">[?</span><span class="nx">D</span><span class="p">]</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;within printArr, D is: &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
  <span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">D</span> <span class="k">do</span>
    <span class="nx">X</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="nx">X</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;after negating X within printArr, X is:\n&quot;</span><span class="p">,</span> <span class="nx">X</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Arrays are passed to functions by reference by default, so the
modifications to X in function printArr are reflected on B as
well:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After calling printArr, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Domains can also be declared and named.  This has the advantages
of allowing them to be reused for multiple arrays, for associating
names with different index spaces, and for amortizing the overhead
of storing distributed arrays across multiple similar array
variables.</p>
<p>The following domain declaration defines a 2D rectangular domain
called <code class="docutils literal notranslate"><span class="pre">ProbSpace</span></code> which is the same size and shape as <code class="docutils literal notranslate"><span class="pre">B</span></code> was above.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">ProbSpace</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
</pre></div>
</div>
<p>We then use that domain to declare some arrays…</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">D</span><span class="p">,</span> <span class="nx">E</span><span class="p">:</span> <span class="p">[</span><span class="nx">ProbSpace</span><span class="p">]</span> <span class="kt">bool</span><span class="p">;</span>
</pre></div>
</div>
<p>…and to iterate over their index spaces…</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">ProbSpace</span> <span class="k">do</span>
  <span class="nx">C</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After initializing C, its value is:\n&quot;</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>When indexing over a multidimensional domain, the indices
can be captured into a single tuple variable rather than
destructuring the tuple into its integer components.
Similarly, multidimensional array accesses can be expressed using
tuple indices rather than multiple integer arguments.  In the
following example, the index variable ij stores a 2-tuple of
integers (<code class="docutils literal notranslate"><span class="pre">2*int</span></code> in Chapel).  This is a really inefficient way
to assign the diagonal values “true” – note the use of tuple
indexing to tease the individual components out of the 2-tuple.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">ij</span> <span class="kd">in</span> <span class="nx">ProbSpace</span> <span class="k">do</span>
  <span class="nx">D</span><span class="p">(</span><span class="nx">ij</span><span class="p">)</span> <span class="o">=</span> <span class="nx">ij</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ij</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After initializing D, its value is:\n&quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Arrays of similar size and shape support whole-array assignment.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">E</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning C to E, E&#39;s value is:\n&quot;</span><span class="p">,</span> <span class="nx">E</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Whole array assignment also allows scalar values to be promoted
and assigned to every element of an array.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">B</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After being reset, B is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>An array need not be indexed using the domain used to declare it,
though doing so presents the compiler with opportunities to
optimize bounds checks away.  In the following loop, there is
no known relation between <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">ProbSpace</span></code>, so bounds checks are
harder to prove away (requires symbolic analysis of the definitions
of the two domains and the invariance of their bounds).</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">ProbSpace</span> <span class="k">do</span>
  <span class="nx">B</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;B has been re-initialized to:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Whole-array assignment can also be used for arrays or sub-arrays
whose index spaces differ. Their shapes must still match.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">F</span><span class="p">,</span> <span class="nx">G</span><span class="p">:</span> <span class="p">[</span><span class="nx">ProbSpace</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>

<span class="nx">F</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="nx">n</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning a slice of B to F, F&#39;s value is:\n&quot;</span><span class="p">,</span> <span class="nx">F</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Arrays can also be sliced using unbounded ranges in which either
the low and/or high bounds are omitted.  In this case, they will be
inherited from the array’s bounds.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">G</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">,</span> <span class="o">..</span><span class="p">]</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning a slice of B to G, G&#39;s value is:\n&quot;</span><span class="p">,</span> <span class="nx">G</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Array slicing supports rank-change semantics when sliced using
a scalar value rather than a range.  In the following assignment,
recall that <code class="docutils literal notranslate"><span class="pre">A</span></code> was our initial 1-dimensional array.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">..</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After being assigned a slice of B, A is:\n&quot;</span><span class="p">,</span> <span class="nx">A</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Domains can also be sliced.  However, rather than having indexing
semantics, domain slicing results in intersection of the domain’s
index set and the specified slice.</p>
<p>Domain slicing, like array indexing and slicing, can be written
with either square brackets or parentheses.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;ProbSpace[1..n-2, 3..] is: &quot;</span><span class="p">,</span> <span class="nx">ProbSpace</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="p">],</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Ranges also support slicing in this way, though we don’t
demonstrate that here.</p>
<p>Domain variables and expressions can also be used to specify an
array slice rather than using lists of ranges.  For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">ProbSpaceSlice</span> <span class="o">=</span> <span class="nx">ProbSpace</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="p">];</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;B[ProbSpaceSlice] is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">[</span><span class="nx">ProbSpaceSlice</span><span class="p">],</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Forall loops over domains and arrays can be written using the
syntax <code class="docutils literal notranslate"><span class="pre">[&lt;ind&gt;</span> <span class="pre">in</span> <span class="pre">&lt;Dom&gt;]</span> <span class="pre">...</span></code> which is shorthand for
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">&lt;ind&gt;</span> <span class="pre">in</span> <span class="pre">&lt;Dom&gt;</span> <span class="pre">do</span> <span class="pre">...</span></code></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// a 2-tuple offset</span>

<span class="p">[</span><span class="nx">ij</span> <span class="kd">in</span> <span class="nx">ProbSpace</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="nx">F</span><span class="p">(</span><span class="nx">ij</span><span class="p">)</span> <span class="o">=</span> <span class="nx">B</span><span class="p">(</span><span class="nx">ij</span> <span class="o">+</span> <span class="nx">offset</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After assigning F a shifted slice of B, it is:\n&quot;</span><span class="p">,</span> <span class="nx">F</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>

<span class="p">[</span><span class="nx">b</span> <span class="kd">in</span> <span class="nx">B</span><span class="p">]</span> <span class="nx">b</span> <span class="o">=</span> <span class="o">-</span><span class="nx">b</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After negating B, it is:\n&quot;</span><span class="p">,</span> <span class="nx">B</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that this shorthand resembles the array type definition in
a variable declaration.</p>
<p>Another advantage to declaring named domain variables is that their
index sets can be reassigned.  This results in a logical
re-allocation of the array variable in question, preserving array
values for indices that existed in both the old and new domain
values:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>

<span class="kd">var</span> <span class="nx">VarArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">VarDom</span><span class="p">]</span> <span class="kt">real</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="nx">VarDom</span><span class="p">]</span> <span class="nx">i</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, VarArr = &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, if we reassign <code class="docutils literal notranslate"><span class="pre">VarDom</span></code>, <code class="docutils literal notranslate"><span class="pre">VarArr</span></code> will be reallocated with the
old values preserved and the new values initialized to the element
type’s default value.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="p">};</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After doubling VarDom, VarArr = &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>As mentioned before, this reallocation preserves values according
to index, so if we extend the lower bound of the domain, the
non-zero values will still logically be associated with indices
<code class="docutils literal notranslate"><span class="pre">1..n</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">*</span><span class="nx">n</span><span class="p">};</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After lowering VarDom&#39;s lower bound, VarArr = &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>If the domain shrinks, values will be thrown away</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After shrinking VarDom, VarArr = &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>One trick to reallocate an array without preserving any values is
to assign its domain variable a degenerate domain, e.g. <code class="docutils literal notranslate"><span class="pre">{1..0}</span></code>,
and then assign it the new value:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">0</span><span class="p">};</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;VarArr should now be empty: &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>

<span class="nx">VarDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;VarArr should now be reset: &quot;</span><span class="p">,</span> <span class="nx">VarArr</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that querying an array’s domain via the <code class="docutils literal notranslate"><span class="pre">.domain</span></code> method or
the function argument query syntax does not result in a domain
expression that can be reassigned.  In particular, we cannot do:</p>
<p><code class="docutils literal notranslate"><span class="pre">VarArr.domain</span> <span class="pre">=</span> <span class="pre">{1..2*n};</span></code></p>
<p>nor:</p>
<p><code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">foo(X:</span> <span class="pre">[?D])</span> <span class="pre">{</span>&#160; <span class="pre">D</span> <span class="pre">=</span> <span class="pre">{1..2*n};</span>&#160; <span class="pre">}</span></code></p>
<p>Only a domain variable or formal argument can be
reassigned to reallocate arrays.  This is to avoid confusion
since assigning one domain variable can cause a number of
arrays to be reallocated.  It also implies that arrays declared
using an anonymous domain cannot be reallocated.  So for our
original array declarations <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, we have no way of reallocating
them.  Arrays with constant domains provide the compiler with
optimization benefits, so this supports a common case efficiently.</p>
<p>As some of our examples have shown, arrays in Chapel can have
arbitrary element types – numeric values, classes, or records.
Arrays can also support array elements, and initial support for
this is implemented in our compiler.  For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">Y</span><span class="p">:</span> <span class="p">[</span><span class="nx">ProbSpace</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>

<span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">ProbSpace</span> <span class="k">do</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="k">do</span>
    <span class="nx">Y</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="o">=</span> <span class="nx">i</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">k</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Y is:\n&quot;</span><span class="p">,</span> <span class="nx">Y</span><span class="p">);</span>
</pre></div>
</div>
<p>Our current implementation requires that array elements must
all be of uniform size. We would also like to support jagged arrays,
where the inner array size is a function of the outer.
In particular, it is our intention to support arrays like these:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">Triangle</span><span class="p">:</span> <span class="p">[</span><span class="nx">row</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">row</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">HierArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">lvl</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">**</span><span class="nx">lvl</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">**</span><span class="nx">lvl</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>For further information, see the <a class="reference internal" href="domains.html#primers-domains"><span class="std std-ref">Domain Primer</span></a>
and other array primers: <a class="reference internal" href="sparse.html#primers-sparse"><span class="std std-ref">Sparse</span></a>,
<a class="reference internal" href="associative.html#primers-associative"><span class="std std-ref">Associative</span></a>.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="slices.html" class="btn btn-neutral float-right" title="Slices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="domains.html" class="btn btn-neutral float-left" title="Domains" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>