

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Regexp &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Set" href="Set.html" />
    <link rel="prev" title="Reflection" href="Reflection.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "modules/standard/Regexp";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assert.html">Assert</a></li>
<li class="toctree-l2"><a class="reference internal" href="Barriers.html">Barriers</a></li>
<li class="toctree-l2"><a class="reference internal" href="BigInteger.html">BigInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="BitOps.html">BitOps</a></li>
<li class="toctree-l2"><a class="reference internal" href="Builtins.html">Builtins</a></li>
<li class="toctree-l2"><a class="reference internal" href="CommDiagnostics.html">CommDiagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="DateTime.html">DateTime</a></li>
<li class="toctree-l2"><a class="reference internal" href="DynamicIters.html">DynamicIters</a></li>
<li class="toctree-l2"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="GMP.html">GMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Heap.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="Help.html">Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="IO.html">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="LinkedLists.html">LinkedLists</a></li>
<li class="toctree-l2"><a class="reference internal" href="List.html">List</a></li>
<li class="toctree-l2"><a class="reference internal" href="Map.html">Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="Math.html">Math</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="Path.html">Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="Random.html">Random</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reflection.html">Reflection</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Regexp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#enabling-regular-expression-support">Enabling Regular Expression Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-regular-expression-support">Using Regular Expression Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-expression-examples">Regular Expression Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#re2-regular-expression-syntax-reference">RE2 regular expression syntax reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-expression-types-and-methods">Regular Expression Types and Methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Set.html">Set</a></li>
<li class="toctree-l2"><a class="reference internal" href="Spawn.html">Spawn</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sys.html">Sys</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysBasic.html">SysBasic</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysCTypes.html">SysCTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysError.html">SysError</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Version.html">Version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
        
      <li>Regexp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/standard/Regexp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-Regexp"></span><div class="section" id="regexp">
<h1>Regexp<a class="headerlink" href="#regexp" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Regexp</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">import</span> <span class="nx">Regexp</span><span class="p">;</span>
</pre></div>
</div>
<p>Regular expression support.</p>
<p>The regular expression support is built on top of the RE2 regular expression
library. As such, the exact regular expression syntax available is the syntax
from RE2, which is available within the RE2 project at
<a class="reference external" href="https://github.com/google/re2">https://github.com/google/re2</a> and included here for your convenience.</p>
<div class="section" id="enabling-regular-expression-support">
<h2>Enabling Regular Expression Support<a class="headerlink" href="#enabling-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<p>Setting the environment variable CHPL_REGEXP to re2 will enable regular
expression support with the RE2 library:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">CHPL_REGEXP</span><span class="o">=</span>re2
</pre></div>
</div>
<p>Then, rebuild Chapel. The RE2 library will be expanded from a release included
in the Chapel distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if re2 support is not enabled (which is the case in quickstart configurations
as in <a class="reference internal" href="../../usingchapel/QUICKSTART.html#chapelhome-quickstart"><span class="std std-ref">Chapel Quickstart Instructions</span></a>), the functionality described below will
result in either a compile-time or a run-time error.</p>
</div>
</div>
<div class="section" id="using-regular-expression-support">
<h2>Using Regular Expression Support<a class="headerlink" href="#using-regular-expression-support" title="Permalink to this headline">¶</a></h2>
<p>Chapel supports both string and bytes regular expressions.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Regexp</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">myRegexp</span> <span class="o">=</span> <span class="nx">compile</span><span class="p">(</span><span class="s">&quot;a+&quot;</span><span class="p">);</span>   <span class="c1">// b&quot;a+&quot; for matching arbitrary bytes values</span>
</pre></div>
</div>
<p>Now you can use these methods on regular expressions: <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>,
<a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.match</span></code></a>, <a class="reference internal" href="#Regexp.regexp.split" title="Regexp.regexp.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.split</span></code></a>, <a class="reference internal" href="#Regexp.regexp.matches" title="Regexp.regexp.matches"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.matches</span></code></a>.</p>
<p>You can also use the string versions of these methods: <a class="reference internal" href="#Regexp.string.search" title="Regexp.string.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.search</span></code></a>,
<a class="reference internal" href="#Regexp.string.match" title="Regexp.string.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.match</span></code></a>, <a class="reference internal" href="#Regexp.string.split" title="Regexp.string.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.split</span></code></a>, or <a class="reference internal" href="#Regexp.string.matches" title="Regexp.string.matches"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.matches</span></code></a>. Methods
with same prototypes exist for <a class="reference internal" href="../../builtins/Bytes.html#module-Bytes" title="Bytes: The following document shows functions and methods used to manipulate and"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">Bytes</span></code></a> type, as well.</p>
<p>Lastly, you can include regular expressions in the format string for
<a class="reference internal" href="IO/FormattedIO.html#FormattedIO.readf" title="FormattedIO.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">readf</span></code></a> for searching on QIO channels using the <code class="docutils literal notranslate"><span class="pre">%/&lt;regexp&gt;/</span></code>
syntax.</p>
</div>
<div class="section" id="regular-expression-examples">
<h2>Regular Expression Examples<a class="headerlink" href="#regular-expression-examples" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">a+</span></code></dt>
<dd>Match one or more <code class="docutils literal notranslate"><span class="pre">a</span></code> characters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[[:space:]]*</span></code> or <code class="docutils literal notranslate"><span class="pre">\s*</span></code> (which would be <code class="docutils literal notranslate"><span class="pre">&quot;\\s*&quot;</span></code> in a string)</dt>
<dd>Match zero or more spaces</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[[:digit:]]+</span></code> or <code class="docutils literal notranslate"><span class="pre">\d+</span></code> (which would be <code class="docutils literal notranslate"><span class="pre">&quot;\\d+&quot;</span></code> in a string)</dt>
<dd>Match one or more digits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">([a-zA-Z0-9]+[[:space:]]+=[[:space:]]+[0-9]+</span></code></dt>
<dd>Match sequences of the form <em>&lt;letters-and-digits&gt; &lt;spaces&gt;</em> <code class="docutils literal notranslate"><span class="pre">=</span></code> <em>&lt;digits&gt;</em></dd>
</dl>
</div>
<div class="section" id="re2-regular-expression-syntax-reference">
<span id="regular-expression-syntax"></span><h2>RE2 regular expression syntax reference<a class="headerlink" href="#re2-regular-expression-syntax-reference" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Single characters:
.            any character, possibly including newline (s=true)
[xyz]        character class
[^xyz]       negated character class
\d           Perl character class (see below)
\D           negated Perl character class (see below)
[:alpha:]    ASCII character class
[:^alpha:]   negated ASCII character class
\pN          Unicode character class (one-letter name)
\p{Greek}    Unicode character class
\PN          negated Unicode character class (one-letter name)
\P{Greek}    negated Unicode character class

Composites:
xy           «x» followed by «y»
x|y          «x» or «y» (prefer «x»)

Repetitions:
x*           zero or more «x», prefer more
x+           one or more «x», prefer more
x?           zero or one «x», prefer one
x{n,m}       «n» or «n»+1 or ... or «m» «x», prefer more
x{n,}        «n» or more «x», prefer more
x{n}         exactly «n» «x»
x*?          zero or more «x», prefer fewer
x+?          one or more «x», prefer fewer
x??          zero or one «x», prefer zero
x{n,m}?      «n» or «n»+1 or ... or «m» «x», prefer fewer
x{n,}?       «n» or more «x», prefer fewer
x{n}?        exactly «n» «x»

Grouping:
(re)         numbered capturing group
(?P&lt;name&gt;re) named &amp; numbered capturing group
(?:re)       non-capturing group
(?flags)     set flags within current group; non-capturing
(?flags:re)  set flags during re; non-capturing

Flags:
i            case-insensitive (default false)
m            multi-line mode: «^» and «$» match begin/end line in addition to
               begin/end text (default false)
s            let «.» match «\n» (default false)
U            ungreedy: swap meaning of «x*» and «x*?», «x+» and «x+?», etc.
               (default false)

Flag syntax is:
  «xyz»   (set)
  «-xyz»  (clear)
  «xy-z»  (set «xy», clear «z»)

Empty strings:
^            at beginning of text or line («m»=true)
$            at end of text (like «\z» not «\Z») or line («m»=true)
\A           at beginning of text
\b           at word boundary («\w» on one side and «\W», «\A», or «\z» on the
               other)
\B           not a word boundary
\z           at end of text

Escape sequences:
\a           bell (== \007)
\f           form feed (== \014)
\t           horizontal tab (== \011)
\n           newline (== \012)
\r           carriage return (== \015)
\v           vertical tab character (== \013)
\*           literal «*», for any punctuation character «*»
\123         octal character code (up to three digits)
\x7F         hex character code (exactly two digits)
\x{10FFFF}   hex character code
\C           match a single byte even in UTF-8 mode
\Q...\E      literal text «...» even if «...» has punctuation

Character class elements:
x            single character
A-Z          character range (inclusive)
\d           Perl character class (see below)
[:foo:]      ASCII character class «foo»
\p{Foo}      Unicode character class «Foo»
\pF          Unicode character class «F» (one-letter name)

Named character classes as character class elements:
[\d]         digits (== \d)
[^\d]        not digits (== \D)
[\D]         not digits (== \D)
[^\D]        not not digits (== \d)
[[:name:]]   named ASCII class inside character class (== [:name:])
[^[:name:]]  named ASCII class inside negated character class (== [:^name:])
[\p{Name}]   named Unicode property inside character class (== \p{Name})
[^\p{Name}]  named Unicode property inside negated character class (==\P{Name})

Perl character classes:
\d           digits (== [0-9])
\D           not digits (== [^0-9])
\s           whitespace (== [\t\n\f\r ])
\S           not whitespace (== [^\t\n\f\r ])
\w           word characters (== [0-9A-Za-z_])
\W           not word characters (== [^0-9A-Za-z_])

ASCII character classes::
  Note -- you must use these within a [] group! so if you want
          to match any number of spaces, use [[:space:]]* or \s*

[:alnum:]    alphanumeric (== [0-9A-Za-z])
[:alpha:]    alphabetic (== [A-Za-z])
[:ascii:]    ASCII (== [\x00-\x7F])
[:blank:]    blank (== [\t ])
[:cntrl:]    control (== [\x00-\x1F\x7F])
[:digit:]    digits (== [0-9])
[:graph:]    graphical (== [!-~] ==
               [A-Za-z0-9!&quot;#$%&amp;&#39;()*+,\-./:;&lt;=&gt;?@[\\\]^_`{|}~])
[:lower:]    lower case (== [a-z])
[:print:]    printable (== [ -~] == [[:graph:]])
[:punct:]    punctuation (== [!-/:-@[-`{-~])
[:space:]    whitespace (== [\t\n\v\f\r ])
[:upper:]    upper case (== [A-Z])
[:word:]     word characters (== [0-9A-Za-z_])
[:xdigit:]   hex digit (== [0-9A-Fa-f])

Unicode character class names--general category:
C            other
Cc           control
Cf           format
Co           private use
Cs           surrogate
L            letter
Ll           lowercase letter
Lm           modifier letter
Lo           other letter
Lt           titlecase letter
Lu           uppercase letter
M            mark
Mc           spacing mark
Me           enclosing mark
Mn           non-spacing mark
N            number
Nd           decimal number
Nl           letter number
No           other number
P            punctuation
Pc           connector punctuation
Pd           dash punctuation
Pe           close punctuation
Pf           final punctuation
Pi           initial punctuation
Po           other punctuation
Ps           open punctuation
S            symbol
Sc           currency symbol
Sk           modifier symbol
Sm           math symbol
So           other symbol
Z            separator
Zl           line separator
Zp           paragraph separator
Zs           space separator

Unicode character class names--scripts (with explanation where non-trivial):
Arabic
Armenian
Balinese
Bengali
Bopomofo
Braille
Buginese
Buhid
Canadian_Aboriginal
Carian
Cham
Cherokee
Common       characters not specific to one script
Coptic
Cuneiform
Cypriot
Cyrillic
Deseret
Devanagari
Ethiopic
Georgian
Glagolitic
Gothic
Greek
Gujarati
Gurmukhi
Han
Hangul
Hanunoo
Hebrew
Hiragana
Inherited    inherit script from previous character
Kannada
Katakana
Kayah_Li
Kharoshthi
Khmer
Lao
Latin
Lepcha
Limbu
Linear_B
Lycian
Lydian
Malayalam
Mongolian
Myanmar
New_Tai_Lue  aka Simplified Tai Lue
Nko
Ogham
Ol_Chiki
Old_Italic
Old_Persian
Oriya
Osmanya
Phags_Pa
Phoenician
Rejang
Runic
Saurashtra
Shavian
Sinhala
Sundanese
Syloti_Nagri
Syriac
Tagalog
Tagbanwa
Tai_Le
Tamil
Telugu
Thaana
Thai
Tibetan
Tifinagh
Ugaritic
Vai
Yi

Vim character classes:
\d      digits (== [0-9])
\D      not «\d»
\w      word character
\W      not «\w»
</pre></div>
</div>
</div>
<div class="section" id="regular-expression-types-and-methods">
<h2>Regular Expression Types and Methods<a class="headerlink" href="#regular-expression-types-and-methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Regexp.BadRegexpError">
<em class="property">class </em><code class="descname">BadRegexpError</code>: Error<a class="headerlink" href="#Regexp.BadRegexpError" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="Regexp.BadRegexpError.msg">
<em class="property">var </em><code class="descname">msg</code>: string<a class="headerlink" href="#Regexp.BadRegexpError.msg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Regexp.BadRegexpError.init">
<em class="property">proc </em><code class="descname">init</code><span class="sig-paren">(</span><em>msg: string</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.BadRegexpError.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Regexp.BadRegexpError.message">
<em class="property">override proc </em><code class="descname">message</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.BadRegexpError.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="Regexp.compile">
<em class="property">proc </em><code class="descname">compile</code><span class="sig-paren">(</span><em>pattern: ?t</em>, <em>posix = false</em>, <em>literal = false</em>, <em>noCapture = false</em>, <em>ignoreCase = false</em>, <em>multiLine = false</em>, <em>dotnl = false</em>, <em>nonGreedy = false</em><span class="sig-paren">)</span>: regexp(t) throws<a class="headerlink" href="#Regexp.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression. This routine will throw a
class:<cite>BadRegexpError</cite> if compilation failed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>pattern</strong> – the regular expression to compile. This argument can be string
or bytes. See <a class="reference internal" href="#regular-expression-syntax"><span class="std std-ref">RE2 regular expression syntax reference</span></a> for details.
Note that you may have to escape backslashes. For example, to
get the regular expression <code class="docutils literal notranslate"><span class="pre">\s</span></code>, you’d have to write
<code class="docutils literal notranslate"><span class="pre">&quot;\\s&quot;</span></code> because the <code class="docutils literal notranslate"><span class="pre">\</span></code> is the escape character within
Chapel string/bytes literals. Note that, Chapel supports
triple-quoted raw string/bytes literals, which do not require
escaping backslashes. For example <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;\s&quot;&quot;&quot;</span></code>
can be used.</li>
<li><strong>posix</strong> – (optional) set to true to disable non-POSIX regular expression
syntax</li>
<li><strong>literal</strong> – (optional) set to true to treat the regular expression as a
literal (ie, create a regexp matching <code class="docutils literal notranslate"><span class="pre">pattern</span></code> as a string
rather than as a regular expression).</li>
<li><strong>noCapture</strong> – (optional) set to true in order to disable all capture groups
in the regular expression</li>
<li><strong>ignoreCase</strong> – (optional) set to true in order to ignore case when
matching. Note that this can be set inside the regular
expression with <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</li>
<li><strong>multiLine</strong> – (optional) set to true in order to activate multiline mode
(meaning that <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code> match the beginning and end
of a line instead of just the beginning and end of the text.
Note that this can be set inside a regular expression
with <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</li>
<li><strong>dotnl</strong> – (optional, default false) set to true in order to allow <code class="docutils literal notranslate"><span class="pre">.</span></code>
to match a newline. Note that this can be set inside the
regular expression with <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</li>
<li><strong>nonGreedy</strong> – (optional) set to true in order to prefer shorter matches for
repetitions; for example, normally x* will match as many x
characters as possible and x*? will match as few as possible.
This flag swaps the two, so that x* will match as few as
possible and x*? will match as many as possible. Note that
this flag can be set inside the regular expression with
<code class="docutils literal notranslate"><span class="pre">(?U)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="record">
<dt id="Regexp.reMatch">
<em class="property">record </em><code class="descname">reMatch</code><a class="headerlink" href="#Regexp.reMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>The reMatch record records a regular expression search match
or a capture group.</p>
<p>Regular expression search routines normally return one of these.
Also, this type can be passed as a capture group argument.
Lastly, something of type reMatch can be checked for a match
in a simple if statement, as in:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">m</span><span class="p">:</span><span class="nx">reMatch</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>
<span class="k">if</span> <span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_matched</span><span class="p">();</span>
<span class="k">if</span> <span class="o">!</span><span class="nx">m</span> <span class="k">then</span> <span class="nx">do_something_if_not_matched</span><span class="p">();</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="Regexp.reMatch.matched">
<em class="property">var </em><code class="descname">matched</code>: bool<a class="headerlink" href="#Regexp.reMatch.matched" title="Permalink to this definition">¶</a></dt>
<dd><p>true if the regular expression search matched successfully</p>
</dd></dl>

<dl class="attribute">
<dt id="Regexp.reMatch.offset">
<em class="property">var </em><code class="descname">offset</code>: byteIndex<a class="headerlink" href="#Regexp.reMatch.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>0-based offset into the string or channel that matched; -1 if matched=false</p>
</dd></dl>

<dl class="attribute">
<dt id="Regexp.reMatch.size">
<em class="property">var </em><code class="descname">size</code>: int<a class="headerlink" href="#Regexp.reMatch.size" title="Permalink to this definition">¶</a></dt>
<dd><p>the length of the match. 0 if matched==false</p>
</dd></dl>

<dl class="method">
<dt id="Regexp.reMatch.length">
<em class="property">proc </em><code class="descname">length</code> ref<a class="headerlink" href="#Regexp.reMatch.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated - please use <a class="reference internal" href="#Regexp.reMatch.size" title="Regexp.reMatch.size"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">reMatch.size</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Regexp.string.this">
<em class="property">proc </em><code class="descclassname">string.</code><code class="descname">this</code><span class="sig-paren">(</span><em>m: reMatch</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.string.this" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the part of a string matching a regular
expression or capture group. This method is intended to be
called on the same string used as the <cite>text</cite> in a regular
expression search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>m</strong> – a match (e.g. returned by <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> referred to by the match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.bytes.this">
<em class="property">proc </em><code class="descclassname">bytes.</code><code class="descname">this</code><span class="sig-paren">(</span><em>m: reMatch</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.bytes.this" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the part of a bytes matching a regular
expression or capture group. This method is intended to be
called on the same bytes used as the <cite>text</cite> in a regular
expression search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>m</strong> – a match (e.g. returned by <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> referred to by the match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="record">
<dt id="Regexp.regexp">
<em class="property">record </em><code class="descname">regexp</code><a class="headerlink" href="#Regexp.regexp" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a compiled regular expression. Regular expressions
are currently cached on a per-thread basis and are reference counted.
To create a compiled regular expression, use the proc:<cite>compile</cite> function.</p>
<p>A string-based regexp can be cast to a string (resulting in the pattern that
was compiled). A string can be cast to a string-based regexp (resulting in a
compiled regexp). Same applies for bytes.</p>
<dl class="method">
<dt id="Regexp.regexp.init">
<em class="property">proc </em><code class="descname">init</code><span class="sig-paren">(</span><em>type exprType</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.regexp.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Regexp.regexp.init=">
<em class="property">proc </em><code class="descname">init=</code><span class="sig-paren">(</span><em>x: regexp(?)</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.regexp.init=" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Regexp.regexp.ok">
<em class="property">proc </em><code class="descname">ok</code>: bool<a class="headerlink" href="#Regexp.regexp.ok" title="Permalink to this definition">¶</a></dt>
<dd><p>did this regular expression compile ?</p>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.error">
<em class="property">proc </em><code class="descname">error</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: string<a class="headerlink" href="#Regexp.regexp.error" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string describing any error encountered when compiling this
regular expression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.search">
<em class="property">proc </em><code class="descname">search</code><span class="sig-paren">(</span><em>text: exprType</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.regexp.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search within the passed text for the first match at any offset to this
regular expression.  This routine will try matching the regular expression
at different offsets until a match is found. If you want to only match at
the beginning of the pattern, you can start your pattern with <code class="docutils literal notranslate"><span class="pre">^</span></code> and
end it with <code class="docutils literal notranslate"><span class="pre">$</span></code> or use <a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.match</span></code></a>. If a capture group was not
matched, the corresponding argument will get the default value for its
type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> – a string or bytes to search</li>
<li><strong>captures</strong> – (optional) what to capture from the regular expression.
If the class:<cite>regexp</cite> was based on string, then, these
should be strings or types that strings can cast to. Same
applies for bytes.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in text
where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.match">
<em class="property">proc </em><code class="descname">match</code><span class="sig-paren">(</span><em>text: exprType</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.regexp.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a match to this regular expression at the start of the passed
text. If a capture group was not matched, the corresponding argument will
get the default value for its type.</p>
<p>For example, this function can be used to check to see if a string
fits a particular template:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">myRegExp</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">doSomethingIfMatched</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> – a string or bytes to search</li>
<li><strong>captures</strong> – what to capture from the regular expression.
If the class:<cite>regexp</cite> was based on string, then, these
should be strings or types that strings can cast to. Same
applies for bytes.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in text
where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.regexp.split">
<em class="property">iter </em><code class="descname">split</code><span class="sig-paren">(</span><em>text: exprType</em>, <em>maxsplit: int = 0</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.regexp.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the text by occurrences of this regular expression.
If capturing parentheses are used in pattern, then the text of all
groups in the pattern are also returned as part of the resulting array.
If <em>maxsplit</em> is nonzero, at most maxsplit splits occur, and the
remaining text is returned as the last element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> – a string or bytes to split</li>
<li><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">each split portion, one at a time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.regexp.matches">
<em class="property">iter </em><code class="descname">matches</code><span class="sig-paren">(</span><em>text: exprType</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.regexp.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the text as well as capture groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> – the string or bytes to search</li>
<li><strong>captures</strong> – (compile-time constant) the size of the captures to return</li>
<li><strong>maxmatches</strong> – the maximum number of matches to return</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.subn">
<em class="property">proc </em><code class="descname">subn</code><span class="sig-paren">(</span><em>repl: exprType</em>, <em>text: exprType</em>, <em>global = true</em><span class="sig-paren">)</span>: (exprType, int)<a class="headerlink" href="#Regexp.regexp.subn" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the same operation as <a class="reference internal" href="#Regexp.regexp.sub" title="Regexp.regexp.sub"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.sub</span></code></a> but return a tuple
containing the new text and the number of substitutions made.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>repl</strong> – replace matches with this string or bytes</li>
<li><strong>text</strong> : <cite>string</cite> or <cite>bytes</cite> – the text to search and replace within</li>
<li><strong>global</strong> – if true, replace multiple matches</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple containing (new text, number of substitutions made)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.regexp.sub">
<em class="property">proc </em><code class="descname">sub</code><span class="sig-paren">(</span><em>repl: exprType</em>, <em>text: exprType</em>, <em>global = true</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.regexp.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matches to this regular expression and create a new string or bytes in
which those matches are replaced by repl.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>repl</strong> – replace matches with this string or bytes</li>
<li><strong>text</strong> : <cite>string</cite> or <cite>bytes</cite> – the text to search and replace within</li>
<li><strong>global</strong> – if true, replace multiple matches</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new string or bytes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Regexp.string.search">
<em class="property">proc </em><code class="descclassname">string.</code><code class="descname">search</code><span class="sig-paren">(</span><em>needle: string</em>, <em>ignorecase = false</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.string.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression and search the receiving string for matches at
any offset using <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> – the regular expression to search for</li>
<li><strong>ignorecase</strong> – true to ignore case in the regular expression</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.bytes.search">
<em class="property">proc </em><code class="descclassname">bytes.</code><code class="descname">search</code><span class="sig-paren">(</span><em>needle: bytes</em>, <em>ignorecase = false</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.bytes.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a regular expression and search the receiving bytes for matches at
any offset using <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> – the regular expression to search for</li>
<li><strong>ignorecase</strong> – true to ignore case in the regular expression</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving bytes where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">string.</code><code class="descname">search</code><span class="sig-paren">(</span><em>needle: regexp(string)</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch</dt>
<dd><p>Search the receiving string for a regular expression already compiled
by calling <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>. Search for matches at any offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> – the compiled regular expression to search for</li>
<li><strong>captures</strong> – (optional) what to capture from the regular expression. These
should be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descclassname">bytes.</code><code class="descname">search</code><span class="sig-paren">(</span><em>needle: regexp(bytes)</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch</dt>
<dd><p>Search the receiving bytes for a regular expression already compiled
by calling <a class="reference internal" href="#Regexp.regexp.search" title="Regexp.regexp.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.search</span></code></a>. Search for matches at any offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>needle</strong> – the compiled regular expression to search for</li>
<li><strong>captures</strong> – (optional) what to capture from the regular expression. These
should be bytes or types that bytes can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving bytes where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.string.match">
<em class="property">proc </em><code class="descclassname">string.</code><code class="descname">match</code><span class="sig-paren">(</span><em>pattern: regexp(string)</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.string.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the receiving string to a regular expression already compiled by
calling <a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.match</span></code></a>. Note that function only returns a match if
the start of the string matches the pattern. Use <a class="reference internal" href="#Regexp.string.search" title="Regexp.string.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">string.search</span></code></a>
to search for the pattern at any offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the compiled regular expression to match</li>
<li><strong>captures</strong> – (optional) what to capture from the regular expression. These
should be strings or types that strings can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving string where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Regexp.bytes.match">
<em class="property">proc </em><code class="descclassname">bytes.</code><code class="descname">match</code><span class="sig-paren">(</span><em>pattern: regexp(bytes)</em>, <em>ref captures ...?k</em><span class="sig-paren">)</span>: reMatch<a class="headerlink" href="#Regexp.bytes.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the receiving bytes to a regular expression already compiled by
calling <a class="reference internal" href="#Regexp.regexp.match" title="Regexp.regexp.match"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.match</span></code></a>. Note that function only returns a match if
the start of the bytes matches the pattern. Use <a class="reference internal" href="#Regexp.bytes.search" title="Regexp.bytes.search"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">bytes.search</span></code></a>
to search for the pattern at any offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the compiled regular expression to match</li>
<li><strong>captures</strong> – (optional) what to capture from the regular expression. These
should be bytes or types that bytes can cast to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> object representing the offset in the
receiving bytes where a match occurred</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.string.split">
<em class="property">iter </em><code class="descclassname">string.</code><code class="descname">split</code><span class="sig-paren">(</span><em>pattern: regexp(string)</em>, <em>maxsplit: int = 0</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.string.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the the receiving string by occurrences of the passed regular
expression by calling <a class="reference internal" href="#Regexp.regexp.split" title="Regexp.regexp.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.split</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the regular expression to use to split</li>
<li><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">each split portion, one at a time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.bytes.split">
<em class="property">iter </em><code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>pattern: regexp(bytes)</em>, <em>maxsplit: int = 0</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.bytes.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the the receiving bytes by occurrences of the passed regular
expression by calling <a class="reference internal" href="#Regexp.regexp.split" title="Regexp.regexp.split"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.split</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the regular expression to use to split</li>
<li><strong>maxsplit</strong> – if nonzero, the maximum number of splits to do</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">each split portion, one at a time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.string.matches">
<em class="property">iter </em><code class="descclassname">string.</code><code class="descname">matches</code><span class="sig-paren">(</span><em>pattern: regexp(string)</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.string.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the receiving string as well as capture groups
by calling <a class="reference internal" href="#Regexp.regexp.matches" title="Regexp.regexp.matches"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.matches</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the regular expression to find matches</li>
<li><strong>captures</strong> – (compile-time constant) the size of the captures to return</li>
<li><strong>maxmatches</strong> – the maximum number of matches to return</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="itermethod">
<dt id="Regexp.bytes.matches">
<em class="property">iter </em><code class="descclassname">bytes.</code><code class="descname">matches</code><span class="sig-paren">(</span><em>pattern: regexp(bytes)</em>, <em>param captures = 0</em>, <em>maxmatches: int = max(int)</em><span class="sig-paren">)</span><a class="headerlink" href="#Regexp.bytes.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerates matches in the receiving bytes as well as capture groups
by calling <a class="reference internal" href="#Regexp.regexp.matches" title="Regexp.regexp.matches"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">regexp.matches</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – the regular expression to find matches</li>
<li><strong>captures</strong> – (compile-time constant) the size of the captures to return</li>
<li><strong>maxmatches</strong> – the maximum number of matches to return</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last">tuples of <a class="reference internal" href="#Regexp.reMatch" title="Regexp.reMatch"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">reMatch</span></code></a> objects, the 1st is always
the match for the whole pattern and the rest are the capture groups.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Set.html" class="btn btn-neutral float-right" title="Set" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Reflection.html" class="btn btn-neutral float-left" title="Reflection" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>