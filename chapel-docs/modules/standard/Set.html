

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Set &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Spawn" href="Spawn.html" />
    <link rel="prev" title="Regexp" href="Regexp.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "modules/standard/Set";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assert.html">Assert</a></li>
<li class="toctree-l2"><a class="reference internal" href="Barriers.html">Barriers</a></li>
<li class="toctree-l2"><a class="reference internal" href="BigInteger.html">BigInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="BitOps.html">BitOps</a></li>
<li class="toctree-l2"><a class="reference internal" href="Builtins.html">Builtins</a></li>
<li class="toctree-l2"><a class="reference internal" href="CommDiagnostics.html">CommDiagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="DateTime.html">DateTime</a></li>
<li class="toctree-l2"><a class="reference internal" href="DynamicIters.html">DynamicIters</a></li>
<li class="toctree-l2"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="GMP.html">GMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Heap.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="Help.html">Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="IO.html">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="LinkedLists.html">LinkedLists</a></li>
<li class="toctree-l2"><a class="reference internal" href="List.html">List</a></li>
<li class="toctree-l2"><a class="reference internal" href="Map.html">Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="Math.html">Math</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="Path.html">Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="Random.html">Random</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="Regexp.html">Regexp</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Set</a></li>
<li class="toctree-l2"><a class="reference internal" href="Spawn.html">Spawn</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sys.html">Sys</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysBasic.html">SysBasic</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysCTypes.html">SysCTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="SysError.html">SysError</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Version.html">Version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
        
      <li>Set</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/standard/Set.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-Set"></span><div class="section" id="set">
<h1>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Set</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">import</span> <span class="nx">Set</span><span class="p">;</span>
</pre></div>
</div>
<p>This module contains the implementation of the set type.</p>
<p>A set is a collection of unique elements. Sets are unordered and unindexed.</p>
<p>The highly parallel nature of Chapel means that great care should be taken
when performing operations that may invalidate references to set elements.
Adding or removing an element from a set may invalidate references to
elements contained in the set.</p>
<p>All references to set elements are invalidated when the set is cleared or
deinitialized.</p>
<p>Sets are not parallel safe by default, but can be made parallel safe by
setting the param formal ‘parSafe` to true in any set constructor. When
constructed from another set, the new set will inherit the parallel safety
mode of its originating set.</p>
<dl class="record">
<dt id="Set.set">
<em class="property">record </em><code class="descname">set</code><a class="headerlink" href="#Set.set" title="Permalink to this definition">¶</a></dt>
<dd><p>A set is a collection of unique elements. Attempting to add a duplicate
element to a set has no effect.</p>
<p>The set type supports a test for membership via the <a class="reference internal" href="#Set.set.contains" title="Set.set.contains"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">contains</span></code></a>
method, along with free functions for calculating the union, difference,
intersection, and symmetric difference of two sets. The set type also
defines the (proper) subset and (proper) superset operations by
overloading common comparison operators.</p>
<p>Sets can be iterated over. The set type makes no guarantee of a consistent
iteration order.</p>
<p>A set can be default initialized (containing no elements), or it may be
initialized with elements that are copies of those contained by any
type that supports an iterator.</p>
<p>The set type is not parallel safe by default. For situations in which
such protections are desirable, parallel safety can be enabled by setting
<cite>parSafe = true</cite> in any set constructor. A set constructed from another
set inherits the parallel safety mode of that set by default.</p>
<dl class="attribute">
<dt id="Set.set.eltType">
<em class="property">type </em><code class="descname">eltType</code><a class="headerlink" href="#Set.set.eltType" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the elements contained in this set.</p>
</dd></dl>

<dl class="attribute">
<dt id="Set.set.parSafe">
<em class="property">param </em><code class="descname">parSafe</code> = false<a class="headerlink" href="#Set.set.parSafe" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>true</cite>, this set will perform parallel safe operations.</p>
</dd></dl>

<dl class="method">
<dt id="Set.set.init">
<em class="property">proc </em><code class="descname">init</code><span class="sig-paren">(</span><em>type eltType</em>, <em>param parSafe = false</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes an empty set containing elements of the given type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>eltType</strong> – The type of the elements of this set.</li>
<li><strong>parSafe</strong> – If <cite>true</cite>, this set will use parallel safe operations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<em class="property">proc </em><code class="descname">init</code><span class="sig-paren">(</span><em>type eltType</em>, <em>iterable</em>, <em>param parSafe = false</em><span class="sig-paren">)</span></dt>
<dd><p>Initialize this set with a unique copy of each element contained in
<cite>iterable</cite>. If an element from <cite>iterable</cite> is already contained in this
set, it will not be added again. The formal <cite>iterable</cite> must be a type
with an iterator named “these” defined for it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>iterable</strong> – A collection of elements to add to this set.</li>
<li><strong>parSafe</strong> – If <cite>true</cite>, this set will use parallel safe operations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.init=">
<em class="property">proc </em><code class="descname">init=</code><span class="sig-paren">(</span><em>const ref other: ?tset?</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.init=" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize this set with a copy of each of the elements contained in
the set <cite>other</cite>. This set will inherit the <cite>parSafe</cite> value of the
set <cite>other</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>other</strong> – A set to initialize this set with.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc ref add(in x: eltType)</code></dt>
<dd><p>Add a copy of the element <cite>x</cite> to this set. Does nothing if this set
already contains an element equal to the value of <cite>x</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>x</strong> – The element to add to this set.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.contains">
<em class="property">proc </em><code class="descname">contains</code><span class="sig-paren">(</span><em>const ref x: eltType</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if the given element is a member of this set, and <cite>false</cite>
otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>x</strong> – The element to test for membership.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Whether or not the given element is a member of this set.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><cite>bool</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.isDisjoint">
<em class="property">proc </em><code class="descname">isDisjoint</code><span class="sig-paren">(</span><em>const ref other: eltTypeset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isDisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set shares no elements in common with the set
<cite>other</cite>, and <cite>false</cite> otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>other</strong> – The set to compare against.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Whether or not this set and <cite>other</cite> are disjoint.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><cite>bool</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.isIntersecting">
<em class="property">proc </em><code class="descname">isIntersecting</code><span class="sig-paren">(</span><em>const ref other: eltTypeset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isIntersecting" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set and <cite>other</cite> have at least one element in
common, and <cite>false</cite> otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>other</strong> – The set to compare against.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Whether or not this set and <cite>other</cite> intersect.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><cite>bool</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc ref remove(const ref x: eltType): bool</code></dt>
<dd><p>Attempt to remove the item from this set with a value equal to <cite>x</cite>. If
an element equal to <cite>x</cite> was removed from this set, return <cite>true</cite>, else
return <cite>false</cite> if no such value was found.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Removing an element from this set may invalidate existing references
to the elements contained in this set.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>x</strong> – The element to remove.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Whether or not an element equal to <cite>x</cite> was removed.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><cite>bool</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc ref clear()</code></dt>
<dd><p>Clear the contents of this set.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Clearing the contents of this set will invalidate all existing
references to the elements contained in this set.</p>
</div>
</dd></dl>

<dl class="itermethod">
<dt id="Set.set.these">
<em class="property">iter </em><code class="descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.these" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the elements of this set. Yields constant references
that cannot be modified.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Modifying this set while iterating over it may invalidate the
references returned by an iterator and is considered undefined
behavior.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body">A constant reference to an element in this set.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.writeThis">
<em class="property">proc </em><code class="descname">writeThis</code><span class="sig-paren">(</span><em>ch: channel</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#Set.set.writeThis" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contents of this set to a channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><strong>ch</strong> – A channel to write to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.isEmpty">
<em class="property">proc </em><code class="descname">isEmpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set contains zero elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><cite>true</cite> if this set is empty.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><cite>bool</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Set.set.size">
<em class="property">proc </em><code class="descname">size</code><a class="headerlink" href="#Set.set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The current number of elements contained in this set.</p>
</dd></dl>

<dl class="method">
<dt id="Set.set.toArray">
<em class="property">proc </em><code class="descname">toArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: [] eltType<a class="headerlink" href="#Set.set.toArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new DefaultRectangular array containing a copy of each of the
elements contained in this set. The elements of the returned array are
not guaranteed to follow any particular ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An array containing a copy of each of the elements in this set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><cite>[] eltType</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Set.=">
<em class="property">proc </em><code class="descname">=</code><span class="sig-paren">(</span><em>ref lhs: ?tset?</em>, <em>const ref rhs: tset?</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.=" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the contents of the set <cite>lhs</cite>, then iterate through the contents of
<cite>rhs</cite> and add a copy of each element to <cite>lhs</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – The set to assign to.</li>
<li><strong>rhs</strong> – The set to assign from.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc |(const ref a: ?tset?, const ref b: tset?): set(t)</code></dt>
<dd><p>Return a new set that contains the union of two sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to take the union of.</li>
<li><strong>b</strong> – A set to take the union of.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new set containing the union between <cite>a</cite> and <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>set(?t, ?)</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc |=(ref lhs: ?tset?, const ref rhs: tset?)</code></dt>
<dd><p>Add to the set <cite>lhs</cite> all the elements of <cite>rhs</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – A set to take the union of and then assign to.</li>
<li><strong>rhs</strong> – A set to take the union of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.+">
<em class="property">proc </em><code class="descname">+</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: tset?<a class="headerlink" href="#Set.+" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new set that contains the union of two sets. Alias for the <cite>|</cite>
operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to take the union of.</li>
<li><strong>b</strong> – A set to take the union of.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new set containing the union between <cite>a</cite> and <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>set(?t, ?)</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.+=">
<em class="property">proc </em><code class="descname">+=</code><span class="sig-paren">(</span><em>ref lhs: ?tset?</em>, <em>const ref rhs: tset?</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.+=" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to the set <cite>lhs</cite> all the elements of <cite>rhs</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – A set to take the union of and then assign to.</li>
<li><strong>rhs</strong> – A set to take the union of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.-">
<em class="property">proc </em><code class="descname">-</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: set(t)<a class="headerlink" href="#Set.-" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new set that contains the difference of two sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to take the difference of.</li>
<li><strong>b</strong> – A set to take the difference of.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new set containing the difference between <cite>a</cite> and <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>set(t)</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.-=">
<em class="property">proc </em><code class="descname">-=</code><span class="sig-paren">(</span><em>ref lhs: ?tset?</em>, <em>const ref rhs: tset?</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.-=" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove from the set <cite>lhs</cite> the elements of <cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – A set to take the difference of and then assign to.</li>
<li><strong>rhs</strong> – A set to take the difference of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc &amp;(const ref a: ?tset?, const ref b: tset?): set(t)</code></dt>
<dd><p>Return a new set that contains the intersection of two sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to take the intersection of.</li>
<li><strong>b</strong> – A set to take the intersection of.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new set containing the intersection of <cite>a</cite> and <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>set(t)</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc &amp;=(ref lhs: ?tset?, const ref rhs: tset?)</code></dt>
<dd><p>Assign to the set <cite>lhs</cite> the set that is the intersection of <cite>lhs</cite> and
<cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – A set to take the intersection of and then assign to.</li>
<li><strong>rhs</strong> – A set to take the intersection of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc ^(const ref a: ?tset?, const ref b: tset?): set(t)</code></dt>
<dd><p>Return the symmetric difference of two sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to take the symmetric difference of.</li>
<li><strong>b</strong> – A set to take the symmetric difference of.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new set containing the symmetric difference of <cite>a</cite> and <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>set(?t, ?)</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc ^=(ref lhs: ?tset?, const ref rhs: tset?)</code></dt>
<dd><p>Assign to the set <cite>lhs</cite> the set that is the symmetric difference of <cite>lhs</cite>
and <cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs</strong> – A set to take the symmetric difference of and then assign to.</li>
<li><strong>rhs</strong> – A set to take the symmetric difference of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.==">
<em class="property">proc </em><code class="descname">==</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.==" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if the sets <cite>a</cite> and <cite>b</cite> are equal. That is, they are the
same size and contain the same elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if two sets are equal.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.!=">
<em class="property">proc </em><code class="descname">!=</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.!=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if the sets <cite>a</cite> and <cite>b</cite> are not equal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if two sets are not equal.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.&lt;">
<em class="property">proc </em><code class="descname">&lt;</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.<" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a proper subset of <cite>b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if <cite>a</cite> is a proper subset of <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.&lt;=">
<em class="property">proc </em><code class="descname">&lt;=</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.<=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a subset of <cite>b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if <cite>a</cite> is a subset of <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.&gt;">
<em class="property">proc </em><code class="descname">&gt;</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.>" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a proper superset of <cite>b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if <cite>a</cite> is a proper superset of <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Set.&gt;=">
<em class="property">proc </em><code class="descname">&gt;=</code><span class="sig-paren">(</span><em>const ref a: ?tset?</em>, <em>const ref b: tset?</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.>=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a superset of <cite>b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> – A set to compare.</li>
<li><strong>b</strong> – A set to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>true</cite> if <cite>a</cite> is a superset of <cite>b</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>bool</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Spawn.html" class="btn btn-neutral float-right" title="Spawn" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Regexp.html" class="btn btn-neutral float-left" title="Regexp" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>