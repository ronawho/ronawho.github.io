

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Procedures &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Methods" href="methods.html" />
    <link rel="prev" title="Modules" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "language/spec/procedures";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Procedures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-calls">Function Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#procedure-definitions">Procedure Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-without-parentheses">Functions without Parentheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formal-arguments">Formal Arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#named-arguments">Named Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-values">Default Values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#argument-intents">Argument Intents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concrete-intents">Concrete Intents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#abstract-intents">Abstract Intents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#variable-number-of-arguments">Variable Number of Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-intents">Return Intents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-ref-return-intent">The Ref Return Intent</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-const-ref-return-intent">The Const Ref Return Intent</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-intent-overloads">Return Intent Overloads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-param-return-intent">The Param Return Intent</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-type-return-intent">The Type Return Intent</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-return-statement">The Return Statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-types">Return Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#explicit-return-types">Explicit Return Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-return-types">Implicit Return Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#where-clauses">Where Clauses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nested-functions">Nested Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-and-operator-overloading">Function and Operator Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-resolution">Function Resolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#determining-visible-functions">Determining Visible Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#determining-candidate-functions">Determining Candidate Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#determining-more-specific-functions">Determining More Specific Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#determining-best-functions">Determining Best Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choosing-return-intent-overloads-based-on-calling-context">Choosing Return Intent Overloads Based on Calling Context</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Procedures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/procedures.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="procedures">
<span id="chapter-procedures"></span><h1>Procedures<a class="headerlink" href="#procedures" title="Permalink to this headline">¶</a></h1>
<p>A <em>function</em> is a code abstraction that can be invoked by a call
expression. Throughout this specification the term “function” is used in
this programming-languages sense, rather than in the mathematical sense.
A function has zero or more <em>formal arguments</em>, or simply <em>formals</em>.
Upon a function call each formal is associated with the corresponding
<em>actual argument</em>, or simply <em>actual</em>. Actual arguments are provided as
part of the call expression, or at the the <em>call site</em>. Direct and
indirect recursion is supported.</p>
<p>A function can be a <em>procedure</em>, which completes and returns to the call
site exactly once, returning no result, a single result, or multiple
results aggregated in a tuple. A function can also be an iterator, which
can generate, or <em>yield</em>, multiple results (in sequence and/or in
parallel). A function (either a procedure or an iterator) can be a
<em>method</em> if it is bound to a type (often a class). An <em>operator</em> in this
chapter is a procedure with a special name, which can be invoked using
infix notation, i.e., via a unary or binary expression. This chapter
defines procedures, but most of its contents apply to iterators and
methods as well.</p>
<p>Functions are presented as follows:</p>
<ul class="simple">
<li>procedures (this chapter)</li>
<li>operators <a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>,
<a class="reference internal" href="expressions.html#binary-expressions"><span class="std std-ref">Operator Expressions</span></a></li>
<li>iterators <a class="reference internal" href="iterators.html#chapter-iterators"><span class="std std-ref">Iterators</span></a></li>
<li>methods (when bound to a class) <a class="reference internal" href="classes.html#class-methods"><span class="std std-ref">Class Methods</span></a></li>
<li>function calls <a class="reference internal" href="#function-calls"><span class="std std-ref">Function Calls</span></a></li>
<li>various aspects of defining a procedure
<a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>–<a class="reference internal" href="#nested-functions"><span class="std std-ref">Nested Functions</span></a></li>
<li>calling external functions from Chapel
<a class="reference internal" href="interoperability.html#calling-external-functions"><span class="std std-ref">Calling External Functions</span></a></li>
<li>calling Chapel functions from external
functions:ref:<cite>Calling_Chapel_Functions</cite></li>
<li>determining the function to invoke for a given call site: function
and operator overloading <a class="reference internal" href="#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>,
function resolution <a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a></li>
</ul>
<div class="section" id="function-calls">
<span id="id1"></span><h2>Function Calls<a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h2>
<p>The syntax to call a non-method function is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>call-expression:
  lvalue-expression ( named-expression-list )
  lvalue-expression [ named-expression-list ]
  parenthesesless-function-identifier

named-expression-list:
  named-expression
  named-expression , named-expression-list

named-expression:
  expression
  identifier = expression

parenthesesless-function-identifier:
  identifier
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">call-expression</span></code> is resolved to a particular function according to
the algorithm for function resolution described
in&nbsp;<a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>.</p>
<p>Functions can be called using either parentheses or brackets.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>This provides an opportunity to blur the distinction between an array
access and a function call and thereby exploit a possible space/time
tradeoff.</p>
</div></blockquote>
<p>Functions that are defined without parentheses must be called without
parentheses as defined by scope resolution. Functions without
parentheses are discussed
in&nbsp;<a class="reference internal" href="#functions-without-parentheses"><span class="std std-ref">Functions without Parentheses</span></a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">named-expression</span></code> is an expression that may be optionally named. It
provides an actual argument to the function being called. The optional
<code class="docutils literal notranslate"><span class="pre">identifier</span></code> refers to a named formal argument described
in&nbsp;<a class="reference internal" href="#named-arguments"><span class="std std-ref">Named Arguments</span></a>.</p>
<p>Calls to methods are defined in
Section&nbsp;<a class="reference internal" href="classes.html#class-method-calls"><span class="std std-ref">Class Method Calls</span></a>.</p>
</div>
<div class="section" id="procedure-definitions">
<span id="function-definitions"></span><h2>Procedure Definitions<a class="headerlink" href="#procedure-definitions" title="Permalink to this headline">¶</a></h2>
<p>Procedures are defined with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>procedure-declaration-statement:
  privacy-specifier[OPT] procedure-kind[OPT] `proc&#39; function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
    function-body

procedure-kind:
  `inline&#39;
  `export&#39;
  `extern&#39;
  `override&#39;

function-name:
  identifier
  operator-name

operator-name: one of
  + - * / % ** ! == != &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; | ^ ~
  = += -= *= /= %= **= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &lt;=&gt; &lt;~&gt;

argument-list:
  ( formals[OPT] )

formals:
  formal
  formal , formals

formal:
  formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
  formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression

formal-type:
  : type-expression
  : ? identifier[OPT]

default-expression:
  = expression

variable-argument-expression:
  ... expression
  ... ? identifier[OPT]
  ...

formal-intent:
  `const&#39;
  `const in&#39;
  `const ref&#39;
  `in&#39;
  `out&#39;
  `inout&#39;
  `ref&#39;
  `param&#39;
  `type&#39;

return-intent:
  `const&#39;
  `const ref&#39;
  `ref&#39;
  `param&#39;
  `type&#39;

return-type:
  : type-expression

where-clause:
  `where&#39; expression

function-body:
  block-statement
  return-statement
</pre></div>
</div>
<p>Functions do not require parentheses if they have no arguments. Such
functions are described in&nbsp;<a class="reference internal" href="#functions-without-parentheses"><span class="std std-ref">Functions without Parentheses</span></a>.</p>
<p>Formal arguments can be grouped together using a tuple notation as
described in&nbsp;<a class="reference internal" href="tuples.html#formal-argument-declarations-in-a-tuple"><span class="std std-ref">Splitting a Tuple into Multiple Formal Arguments in a Function Call</span></a>.</p>
<p>Default expressions allow for the omission of actual arguments at the
call site, resulting in the implicit passing of a default value. Default
values are discussed in&nbsp;<a class="reference internal" href="#default-values"><span class="std std-ref">Default Values</span></a>.</p>
<p>The intents <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>,
<code class="docutils literal notranslate"><span class="pre">inout</span></code> and <code class="docutils literal notranslate"><span class="pre">ref</span></code> are discussed in&nbsp;<a class="reference internal" href="#argument-intents"><span class="std std-ref">Argument Intents</span></a>.
The intents <code class="docutils literal notranslate"><span class="pre">param</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span></code> make a function generic and are
discussed in&nbsp;<a class="reference internal" href="generics.html#generic-functions"><span class="std std-ref">Generic Functions</span></a>. If the formal argument’s
type is omitted, generic, or prefixed with a question mark, the function
is also generic and is discussed in&nbsp;<a class="reference internal" href="generics.html#generic-functions"><span class="std std-ref">Generic Functions</span></a>.</p>
<p>Functions can take a variable number of arguments. Such functions are
discussed in&nbsp;<a class="reference internal" href="#variable-length-argument-lists"><span class="std std-ref">Variable Number of Arguments</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> can be used to indicate how the value is returned
from a function. <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> is described further in
<a class="reference internal" href="#return-intent"><span class="std std-ref">Return Intents</span></a>.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Parameter and type procedures are supported. Parameter and type
iterators are currently not supported.</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">return-type</span></code> is optional and is discussed
in&nbsp;<a class="reference internal" href="#return-types"><span class="std std-ref">Return Types</span></a>. A type function may not specify a return
type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">where-clause</span></code> is optional and is discussed
in&nbsp;<a class="reference internal" href="#where-clauses"><span class="std std-ref">Where Clauses</span></a>.</p>
<p>Function and operator overloading is supported in Chapel and is
discussed in&nbsp;<a class="reference internal" href="#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>. Operator overloading
is supported on the operators listed above (see <code class="docutils literal notranslate"><span class="pre">operator-name</span></code>).</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> keywords indicate the visibility of
module level procedures to outside modules. By default, procedures are
publicly visible. More details on visibility can be found in
&nbsp;<a class="reference internal" href="modules.html#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>.</p>
<p>The linkage specifier <code class="docutils literal notranslate"><span class="pre">inline</span></code> indicates that the function body must
be inlined at every call site.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>A Chapel compiler is permitted to inline any function if it
determines there is likely to be a performance benefit to do so.
Hence an error must be reported if the compiler is unable to inline a
procedure with this specifier. One example of a preventable inlining
error is to define a sequence of inlined calls that includes a cycle
back to an inlined procedure.</p>
</div></blockquote>
<p>See the chapter on interoperability
(<a class="reference internal" href="interoperability.html#chapter-interoperability"><span class="std std-ref">Interoperability</span></a>) for details on exported
and imported functions.</p>
</div>
<div class="section" id="functions-without-parentheses">
<span id="id2"></span><h2>Functions without Parentheses<a class="headerlink" href="#functions-without-parentheses" title="Permalink to this headline">¶</a></h2>
<p>Functions do not require parentheses if they have empty argument lists.
Functions declared without parentheses around empty argument lists must
be called without parentheses.</p>
<blockquote>
<div><p><em>Example (function-no-parens.chpl)</em>.</p>
<p>Given the definitions</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In foo&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In bar&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>the procedure <code class="docutils literal notranslate"><span class="pre">foo</span></code> can be called by writing <code class="docutils literal notranslate"><span class="pre">foo</span></code> and the
procedure <code class="docutils literal notranslate"><span class="pre">bar</span></code> can be called by writing <code class="docutils literal notranslate"><span class="pre">bar()</span></code>. It is an error
to use parentheses when calling <code class="docutils literal notranslate"><span class="pre">foo</span></code> or omit them when calling
<code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="formal-arguments">
<span id="id3"></span><h2>Formal Arguments<a class="headerlink" href="#formal-arguments" title="Permalink to this headline">¶</a></h2>
<p>A formal argument’s intent&nbsp;(<a class="reference internal" href="#argument-intents"><span class="std std-ref">Argument Intents</span></a>) specifies
how the actual argument is passed to the function. If no intent is
specified, the default intent&nbsp;(<a class="reference internal" href="#the-default-intent"><span class="std std-ref">The Default Intent</span></a>) is
applied, resulting in type-dependent behavior.</p>
<div class="section" id="named-arguments">
<span id="id4"></span><h3>Named Arguments<a class="headerlink" href="#named-arguments" title="Permalink to this headline">¶</a></h3>
<p>A formal argument can be named at the call site to explicitly map an
actual argument to a formal argument.</p>
<blockquote>
<div><p><em>Example (named-args.chpl)</em>.</p>
<p>Running the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="o">=</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nx">x</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>will produce the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>2
3
2
3
</pre></div>
</div>
<p>named argument passing is used to map the actual arguments to the
formal arguments. The two function calls are equivalent.</p>
</div></blockquote>
<p>Named arguments are sometimes necessary to disambiguate calls or ignore
arguments with default values. For a function that has many arguments,
it is sometimes good practice to name the arguments at the call site for
compiler-checked documentation.</p>
</div>
<div class="section" id="default-values">
<span id="id5"></span><h3>Default Values<a class="headerlink" href="#default-values" title="Permalink to this headline">¶</a></h3>
<p>Default values can be specified for a formal argument by appending the
assignment operator and a default expression to the declaration of the
formal argument. If the actual argument is omitted from the function
call, the default expression is evaluated when the function call is made
and the evaluated result is passed to the formal argument as if it were
passed from the call site. Note though that the default value is
evaluated in the same scope as the called function. Default value
expressions can refer to previous formal arguments or to variables that
are visible to the scope of the function definition.</p>
<blockquote>
<div><p><em>Example (default-values.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>writes out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>5
7
7
7
5
5
</pre></div>
</div>
<p>Default values are specified for the formal arguments <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>. The three calls to <code class="docutils literal notranslate"><span class="pre">foo</span></code> are equivalent to the following
three calls where the actual arguments are explicit: <code class="docutils literal notranslate"><span class="pre">foo(5,</span> <span class="pre">7)</span></code>,
<code class="docutils literal notranslate"><span class="pre">foo(7,</span> <span class="pre">7)</span></code>, and <code class="docutils literal notranslate"><span class="pre">foo(5,</span> <span class="pre">5)</span></code>. The example <code class="docutils literal notranslate"><span class="pre">foo(y=5)</span></code> shows how
to use a named argument for <code class="docutils literal notranslate"><span class="pre">y</span></code> in order to use the default value
for <code class="docutils literal notranslate"><span class="pre">x</span></code> in the case when <code class="docutils literal notranslate"><span class="pre">x</span></code> appears earlier than <code class="docutils literal notranslate"><span class="pre">y</span></code> in the
formal argument list.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="argument-intents">
<span id="id6"></span><h2>Argument Intents<a class="headerlink" href="#argument-intents" title="Permalink to this headline">¶</a></h2>
<p>Argument intents specify how an actual argument is passed to a function
where it is represented by the corresponding formal argument.</p>
<p>Argument intents are categorized as being either <em>concrete</em> or
<em>abstract</em>. Concrete intents are those in which the semantics of the
intent keyword are independent of the argument’s type. Abstract intents
are those in which the keyword (or lack thereof) expresses a general
intention that will ultimately be implemented via one of the concrete
intents. The specific choice of concrete intent depends on the
argument’s type and may be implementation-defined. Abstract intents are
provided to support productivity and code reuse.</p>
<div class="section" id="concrete-intents">
<span id="id7"></span><h3>Concrete Intents<a class="headerlink" href="#concrete-intents" title="Permalink to this headline">¶</a></h3>
<p>The concrete intents are <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>, <code class="docutils literal notranslate"><span class="pre">ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>.</p>
<div class="section" id="the-in-intent">
<span id="id8"></span><h4>The In Intent<a class="headerlink" href="#the-in-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">in</span></code> is specified as the intent, the formal argument represents a
variable that is copy-initialized with the value of the actual argument.
For example, for integer arguments, the formal argument will store a
copy of the actual argument. An implicit conversion occurs from the
actual argument to the type of the formal. The formal can be modified
within the function, but such changes are local to the function and not
reflected back to the call site.</p>
</div>
<div class="section" id="the-out-intent">
<span id="id9"></span><h4>The Out Intent<a class="headerlink" href="#the-out-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">out</span></code> is specified as the intent, the actual argument is ignored
when the call is made, but when the function returns, the actual argument
is assigned to the value of the formal argument.  An implicit conversion
occurs from the type of the formal to the type of the actual. The actual
argument must be a valid lvalue. Within the function body, the formal
argument is initialized to its default value if one is supplied, or to
its type’s default value otherwise. The formal argument can be modified
within the function.</p>
<p>The assignment implementing the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent is a candidate for
<a class="reference internal" href="variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a>. As a result, an actual argument might be
initialized by a call passing the actual by <code class="docutils literal notranslate"><span class="pre">out</span></code> intent.</p>
<p>_The_Inout_Intent:</p>
</div>
<div class="section" id="the-inout-intent">
<h4>The Inout Intent<a class="headerlink" href="#the-inout-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">inout</span></code> is specified as the intent, the actual argument is copied
into the formal argument as with the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent and then copied back
out as with the <code class="docutils literal notranslate"><span class="pre">out</span></code> intent. The actual argument must be a valid
lvalue. The formal argument can be modified within the function. The
type of the actual argument must be the same as the type of the formal.</p>
</div>
<div class="section" id="the-ref-intent">
<span id="id10"></span><h4>The Ref Intent<a class="headerlink" href="#the-ref-intent" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">ref</span></code> is specified as the intent, the actual argument is passed
by reference. Any reads of, or modifications to, the formal argument are
performed directly on the corresponding actual argument at the call
site. The actual argument must be a valid lvalue. The type of the actual
argument must be the same as the type of the formal.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent differs from the <code class="docutils literal notranslate"><span class="pre">inout</span></code> intent in that the
<code class="docutils literal notranslate"><span class="pre">inout</span></code> intent requires copying from/to the actual argument on the way
in/out of the function, while <code class="docutils literal notranslate"><span class="pre">ref</span></code> allows direct access to the actual
argument through the formal argument without copies. Note that
concurrent modifications to the <code class="docutils literal notranslate"><span class="pre">ref</span></code> actual argument by other tasks
may be visible within the function, subject to the memory consistency
model.</p>
</div>
<div class="section" id="the-const-in-intent">
<span id="id11"></span><h4>The Const In Intent<a class="headerlink" href="#the-const-in-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intent is identical to the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent, except that
modifications to the formal argument are prohibited within the function.</p>
</div>
<div class="section" id="the-const-ref-intent">
<span id="id12"></span><h4>The Const Ref Intent<a class="headerlink" href="#the-const-ref-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent is identical to the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent, except that
modifications to the formal argument are prohibited within the dynamic
scope of the function. Note that concurrent tasks may modify the actual
argument while the function is executing and that these modifications
may be visible to reads of the formal argument within the function’s
dynamic scope (subject to the memory consistency model).</p>
</div>
<div class="section" id="summary-of-concrete-intents">
<span id="id13"></span><h4>Summary of Concrete Intents<a class="headerlink" href="#summary-of-concrete-intents" title="Permalink to this headline">¶</a></h4>
<p>The following table summarizes the differences between the concrete
intents:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="7%" />
<col width="10%" />
<col width="10%" />
<col width="12%" />
<col width="13%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">in</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">out</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">inout</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">ref</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copied in on function call?</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td>copied out on function return?</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td>refers to actual argument?</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td>formal can be read?</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="row-even"><td>formal can be modified?</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-odd"><td>local changes affect the actual?</td>
<td>no</td>
<td>on return</td>
<td>on return</td>
<td>immediately</td>
<td>N/A</td>
<td>N/A</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="abstract-intents">
<span id="id14"></span><h3>Abstract Intents<a class="headerlink" href="#abstract-intents" title="Permalink to this headline">¶</a></h3>
<p>The abstract intents are <code class="docutils literal notranslate"><span class="pre">const</span></code> and the <em>default intent</em> (when no
intent is specified).</p>
<div class="section" id="abstract-intents-table">
<span id="id15"></span><h4>Abstract Intents Table<a class="headerlink" href="#abstract-intents-table" title="Permalink to this headline">¶</a></h4>
<p>The following table summarizes what these abstract intents mean for each
type:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="15%" />
<col width="21%" />
<col width="47%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td></td>
<td>meaning of</td>
<td>meaning of</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>type</td>
<td><code class="docutils literal notranslate"><span class="pre">const</span></code> intent</td>
<td>default intent</td>
<td>notes</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">uint</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">real</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">imag</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">complex</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">range</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">class</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">class</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">class</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">class</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">atomic</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">single</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">sync</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">string</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">bytes</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">record</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>see <a class="reference internal" href="#default-intent-for-arrays-and-record-this"><span class="std std-ref">Default Intent for Arrays and Record ’this’</span></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">union</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">dmap</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">domain</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>array</td>
<td><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">ref</span></code> / <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code></td>
<td>see <a class="reference internal" href="#default-intent-for-arrays-and-record-this"><span class="std std-ref">Default Intent for Arrays and Record ’this’</span></a></td>
</tr>
<tr class="row-even"><td>tuple</td>
<td>per element</td>
<td>per element</td>
<td>see <a class="reference internal" href="tuples.html#tuple-argument-intents"><span class="std std-ref">Tuple Argument Intents</span></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-const-intent">
<span id="id16"></span><h4>The Const Intent<a class="headerlink" href="#the-const-intent" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span></code> intent specifies the intention that the function will not
and cannot modify the formal argument within its dynamic scope. Whether
the actual argument will be passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>
intent depends on its type. In general, small values, such as scalar
types, will be passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>; while larger values, such as
domains and arrays, will be passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent. The
<a class="reference internal" href="#abstract-intents-table"><span class="std std-ref">Abstract Intents Table</span></a> earlier in this sub-section lists the
meaning of the const intent for each type.</p>
</div>
<div class="section" id="the-default-intent">
<span id="id17"></span><h4>The Default Intent<a class="headerlink" href="#the-default-intent" title="Permalink to this headline">¶</a></h4>
<p>When no intent is specified for a formal argument, the <em>default intent</em>
is applied. It is designed to take the most natural/least surprising
action for the argument, based on its type. The
<a class="reference internal" href="#abstract-intents-table"><span class="std std-ref">Abstract Intents Table</span></a> earlier in this sub-section lists the
meaning of the default intent for each type.</p>
<p>Default argument passing for tuples generally matches the default
argument passing strategy that would be applied if each tuple element
was passed as a separate argument. See <a class="reference internal" href="tuples.html#tuple-argument-intents"><span class="std std-ref">Tuple Argument Intents</span></a>.</p>
</div>
<div class="section" id="default-intent-for-arrays-and-record-this">
<span id="id18"></span><h4>Default Intent for Arrays and Record ’this’<a class="headerlink" href="#default-intent-for-arrays-and-record-this" title="Permalink to this headline">¶</a></h4>
<p>The default intent for arrays and for a <code class="docutils literal notranslate"><span class="pre">this</span></code> argument of record
type&nbsp;(see <a class="reference internal" href="methods.html#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>) is <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. It is <code class="docutils literal notranslate"><span class="pre">ref</span></code> if the formal argument is modified inside
the function, otherwise it is <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. Note that neither of these
cause an array or record to be copied by default. The choice between
<code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> is similar to and interacts with return intent
overloads (see <a class="reference internal" href="#return-intent-overloads"><span class="std std-ref">Return Intent Overloads</span></a>).</p>
</div>
<div class="section" id="default-intent-for-owned-and-shared">
<span id="id19"></span><h4>Default Intent for ’owned’ and ’shared’<a class="headerlink" href="#default-intent-for-owned-and-shared" title="Permalink to this headline">¶</a></h4>
<p>The default intent for <code class="docutils literal notranslate"><span class="pre">owned</span></code> and <code class="docutils literal notranslate"><span class="pre">shared</span></code> arguments is
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>. Arguments can use the <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intents to
transfer or share ownership if those arguments apply to <code class="docutils literal notranslate"><span class="pre">owned</span></code> or
<code class="docutils literal notranslate"><span class="pre">shared</span></code> types.</p>
<blockquote>
<div><p><em>Example (owned-any-intent.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">defaultGeneric</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">SomeClass</span><span class="p">();</span>
<span class="nx">defaultGeneric</span><span class="p">(</span><span class="nx">own</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">own</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="variable-number-of-arguments">
<span id="variable-length-argument-lists"></span><h2>Variable Number of Arguments<a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h2>
<p>Functions can be defined to take a variable number of arguments where
those arguments can have any intent or can be types. A variable number
of parameters is not supported. This allows the call site to pass a
different number of actual arguments. There must be at least one actual
argument.</p>
<p>If the variable argument expression contains an identifier prepended by
a question mark, the number of actual arguments can vary, and the
identifier will be bound to an integer parameter value indicating the
number of arguments at a given call site. If the variable argument
expression contains an expression without a question mark, that
expression must evaluate to an integer parameter value requiring the
call site to pass that number of arguments to the function.</p>
<p>Within the function, the formal argument that is marked with a
variable argument expression is a tuple of the actual arguments.  If
the actual arguments all have the same type, the formal will be a
homogeneous tuple, otherwise it will be a heterogeneous tuple.</p>
<blockquote>
<div><p><em>Example (varargs.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">mywriteln</span><span class="p">(</span><span class="nx">xs</span> <span class="o">..</span><span class="p">.?</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">x</span> <span class="kd">in</span> <span class="nx">xs</span> <span class="k">do</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines a generic procedure called <code class="docutils literal notranslate"><span class="pre">mywriteln</span></code> that takes a
variable number of arguments of any type and then writes them out
on separate lines.  The type of <code class="docutils literal notranslate"><span class="pre">xs</span></code> can also be constrained in
the formal argument list to require that the actuals all have the
same type.  For example <code class="docutils literal notranslate"><span class="pre">xs:</span> <span class="pre">string...?k</span></code> would accept a variable
number of string arguments.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (varargs-with-type.chpl)</em>.</p>
<p>Either or both the number of variable arguments and their types can
be specified. For example, a basic procedure to sum the values of
three integers can be written as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="o">..</span><span class="mf">.3</span><span class="p">)</span> <span class="k">return</span> <span class="nx">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Specifying the type is useful if it is important that each argument
have the same type. Specifying the number is useful in, for example,
defining a method on a class that is instantiated over a rank
parameter.</p>
<p><em>Example (varargs-returns-tuples.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">tuple</span><span class="p">(</span><span class="nx">x</span> <span class="o">..</span><span class="p">.)</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<p>defines a generic procedure that is equivalent to building a tuple.
Therefore the expressions <code class="docutils literal notranslate"><span class="pre">tuple(1,</span> <span class="pre">2)</span></code> and <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> are
equivalent, as are the expressions <code class="docutils literal notranslate"><span class="pre">tuple(1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="return-intents">
<span id="return-intent"></span><h2>Return Intents<a class="headerlink" href="#return-intents" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> specifies how the value is returned from a
function, and in what contexts that function is allowed to be used. By
default, or if the <code class="docutils literal notranslate"><span class="pre">return-intent</span></code> is <code class="docutils literal notranslate"><span class="pre">const</span></code>, the function returns
a value that cannot be used as an lvalue.</p>
<div class="section" id="the-ref-return-intent">
<span id="ref-return-intent"></span><h3>The Ref Return Intent<a class="headerlink" href="#the-ref-return-intent" title="Permalink to this headline">¶</a></h3>
<p>When using a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent, the function call is an lvalue
(specifically, a call expression for a procedure and an iterator
variable for an iterator).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent is specified by following the argument list
with the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword. The function must return or yield an lvalue.</p>
<blockquote>
<div><p><em>Example (ref-return-intent.chpl)</em>.</p>
<p>The following code defines a procedure that can be interpreted as a
simple two-element array where the elements are actually module level
variables:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;array access out of bounds&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Calls to this procedure can be assigned to in order to write to the
“elements” of the array as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>It can be called as an expression to access the “elements” as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>This code outputs the number <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="the-const-ref-return-intent">
<span id="const-ref-return-intent"></span><h3>The Const Ref Return Intent<a class="headerlink" href="#the-const-ref-return-intent" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent is also available. It is a restricted
form of the <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent. Calls to functions marked with the
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent are not lvalue expressions.</p>
</div>
<div class="section" id="return-intent-overloads">
<span id="id20"></span><h3>Return Intent Overloads<a class="headerlink" href="#return-intent-overloads" title="Permalink to this headline">¶</a></h3>
<p>In some situations, it is useful to choose the function called based
upon how the returned value is used. In particular, suppose that there
are two functions that have the same formal arguments and differ only in
their return intent. One might expect such a situation to result in an
error indicating that it is ambiguous which function is called. However,
the Chapel language includes a special rule for determining which
function to call when the candidate functions are otherwise ambiguous
except for their return intent. This rule enables data structures such
as sparse arrays.</p>
<p>See <a class="reference external" href="#Choosing_Return_Intent_Overload">13.13.5</a> for a detailed
description of how return intent overloads are chosen based upon calling
context.</p>
<blockquote>
<div><p><em>Example (ref-return-intent-pair.chpl)</em>.</p>
<p>Return intent overload can be used to ensure, for example, that the
second element in the pseudo-array is only assigned a value if the
first argument is positive. The following is an example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">doA</span><span class="p">(</span><span class="kd">param</span> <span class="nx">setter</span><span class="p">,</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;array access out of bounds&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="nx">setter</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;cannot assign value to A(1) if A(0) &lt;= 0&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">doA</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">A</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">doA</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="the-param-return-intent">
<span id="param-return-intent"></span><h3>The Param Return Intent<a class="headerlink" href="#the-param-return-intent" title="Permalink to this headline">¶</a></h3>
<p>A <em>parameter function</em>, or a <em>param function</em>, is a function that
returns a parameter expression. It is specified by following the
function’s argument list by the keyword <code class="docutils literal notranslate"><span class="pre">param</span></code>. It is often, but not
necessarily, generic.</p>
<p>It is a compile-time error if a parameter function does not return a
parameter expression. The result of a parameter function is computed
during compilation and substituted for the call expression.</p>
<blockquote>
<div><p><em>Example (param-functions.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sumOfSquares</span><span class="p">(</span><span class="kd">param</span> <span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">param</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">b</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">sumOfSquares</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sumOfSquares</span></code> is a parameter procedure that takes two parameters
as arguments. Calls to this procedure can be used in places where a
parameter expression is required. In this example, the call is used
in the declaration of a homogeneous tuple and so is required to be a
parameter.</p>
</div></blockquote>
<p>Parameter functions may not contain control flow that is not resolved at
compile-time. This includes loops other than the parameter for
loop&nbsp;<a class="reference internal" href="statements.html#parameter-for-loops"><span class="std std-ref">Parameter For Loops</span></a> and conditionals with a
conditional expressions that is not a parameter.</p>
</div>
<div class="section" id="the-type-return-intent">
<span id="type-return-intent"></span><h3>The Type Return Intent<a class="headerlink" href="#the-type-return-intent" title="Permalink to this headline">¶</a></h3>
<p>A <em>type function</em> is a function that returns a type, not a value. It is
specified by following the function’s argument list by the keyword
<code class="docutils literal notranslate"><span class="pre">type</span></code>, without the subsequent return type. It is often, but not
necessarily, generic.</p>
<p>It is a compile-time error if a type function does not return a type.
The result of a type function is computed during compilation.</p>
<p>As with parameter functions, type functions may not contain control flow
that is not resolved at compile-time. This includes loops other than the
parameter for loop&nbsp;<a class="reference internal" href="statements.html#parameter-for-loops"><span class="std std-ref">Parameter For Loops</span></a> and conditionals
with a conditional expression that is not a parameter.</p>
<blockquote>
<div><p><em>Example (type-functions.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">myType</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="kd">type</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">numBits</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">32</span> <span class="k">then</span> <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">myType</span></code> is a type procedure that takes a single argument <code class="docutils literal notranslate"><span class="pre">x</span></code> and
returns <code class="docutils literal notranslate"><span class="pre">int(32)</span></code> if the number of bits used to represent <code class="docutils literal notranslate"><span class="pre">x</span></code> is
less than or equal to 32, otherwise it returns <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>.
<code class="docutils literal notranslate"><span class="pre">numBits</span></code> is a param procedure defined in the standard Types
module.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="the-return-statement">
<span id="id21"></span><h2>The Return Statement<a class="headerlink" href="#the-return-statement" title="Permalink to this headline">¶</a></h2>
<p>The return statement can only appear in a function. It causes control to
exit that function, returning it to the point at which that function was
called.</p>
<p>A procedure can return a value by executing a return statement that
includes an expression. If it does, that expression’s value becomes the
value of the invoking call expression.</p>
<p>A return statement in a procedure of a non-<code class="docutils literal notranslate"><span class="pre">void</span></code> return type
(<a class="reference internal" href="#return-types"><span class="std std-ref">Return Types</span></a>) must include an expression. A return
statement in a procedure of a <code class="docutils literal notranslate"><span class="pre">void</span></code> return type or in an iterator
must not include an expression. A return statement of a variable
procedure must contain an lvalue expression.</p>
<p>The syntax of the return statement is given by</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>return-statement:
  `return&#39; expression[OPT] ;
</pre></div>
</div>
<blockquote>
<div><p><em>Example (return.chpl)</em>.</p>
<p>The following code defines a procedure that returns the sum of three
integers:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">i1</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">i2</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">i3</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">i1</span> <span class="o">+</span> <span class="nx">i2</span> <span class="o">+</span> <span class="nx">i3</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="return-types">
<span id="id22"></span><h2>Return Types<a class="headerlink" href="#return-types" title="Permalink to this headline">¶</a></h2>
<p>Every procedure has a return type. The return type is either specified
explicitly via <code class="docutils literal notranslate"><span class="pre">return-type</span></code> in the procedure declaration, or is
inferred implicitly.</p>
<div class="section" id="explicit-return-types">
<span id="id23"></span><h3>Explicit Return Types<a class="headerlink" href="#explicit-return-types" title="Permalink to this headline">¶</a></h3>
<p>If a return type is specified and is not <code class="docutils literal notranslate"><span class="pre">void</span></code>, each return statement
of the procedure must include an expression. For a non-<code class="docutils literal notranslate"><span class="pre">ref</span></code> return
intent, an implicit conversion occurs from each return expression to the
specified return type. For a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return
intent&nbsp;(<a class="reference internal" href="#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>), the return type must match
the type returned in all of the return statements exactly, when checked
after generic instantiation and parameter folding (if applicable).</p>
</div>
<div class="section" id="implicit-return-types">
<span id="id24"></span><h3>Implicit Return Types<a class="headerlink" href="#implicit-return-types" title="Permalink to this headline">¶</a></h3>
<p>If a return type is not specified, it is inferred from the return
statements. It is illegal for a procedure to have a return statement
with an expression and a return statement without an expression. For
procedures without any return statements, or when none of the return
statements include an expression, the return type is <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>Otherwise, the types of the expressions in all of the procedure’s return
statements are considered. If a function has a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent
(<a class="reference internal" href="#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>), they all must be the same exact
type, which becomes the inferred return type. Otherwise, there must
exist exactly one type such that an implicit conversion is allowed
between every other type and that type, and that type becomes the
inferred return type. If the above requirements are not satisfied, it is
an error.</p>
</div>
</div>
<div class="section" id="where-clauses">
<span id="id25"></span><h2>Where Clauses<a class="headerlink" href="#where-clauses" title="Permalink to this headline">¶</a></h2>
<p>The list of function candidates can be constrained by <em>where clauses</em>. A
where clause is specified in the definition of a
function&nbsp;(<a class="reference internal" href="#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>). The expression in the
where clause must be a boolean parameter expression that evaluates to
either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. If it evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the function
is rejected and thus is not a possible candidate for function
resolution.</p>
<blockquote>
<div><p><em>Example (whereClause.chpl)</em>.</p>
<p>Given two overloaded function definitions</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="k">where</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="kt">int</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="k">where</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="kt">real</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;real&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>the call foo(3) resolves to the first definition because the where
clause on the second function evaluates to false.</p>
</div></blockquote>
</div>
<div class="section" id="nested-functions">
<span id="id26"></span><h2>Nested Functions<a class="headerlink" href="#nested-functions" title="Permalink to this headline">¶</a></h2>
<p>A function defined in another function is called a nested function.
Nesting of functions may be done to arbitrary degrees, i.e., a function
can be nested in a nested function.</p>
<p>Nested functions are only visible to function calls within the lexical
scope in which they are defined.</p>
<p>Nested functions may refer to variables defined in the function(s) in
which they are nested.</p>
</div>
<div class="section" id="function-and-operator-overloading">
<span id="function-overloading"></span><h2>Function and Operator Overloading<a class="headerlink" href="#function-and-operator-overloading" title="Permalink to this headline">¶</a></h2>
<p>Functions that have the same name but different argument lists are
called overloaded functions. Function calls to overloaded functions are
resolved according to the function resolution algorithm
in&nbsp;<a class="reference internal" href="#function-resolution"><span class="std std-ref">Function Resolution</span></a>.</p>
<p>Operator overloading is achieved by defining a function with a name
specified by that operator. The operators that may be overloaded are
listed in the following table:</p>
<p>arity    operators
======== ===============================
unary    <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> <code class="docutils literal notranslate"><span class="pre">+</span></code> <code class="docutils literal notranslate"><span class="pre">-</span></code> <code class="docutils literal notranslate"><span class="pre">!</span></code> <code class="docutils literal notranslate"><span class="pre">~</span></code>
binary   <code class="docutils literal notranslate"><span class="pre">+</span></code> <code class="docutils literal notranslate"><span class="pre">-</span></code> <code class="docutils literal notranslate"><span class="pre">*</span></code> <code class="docutils literal notranslate"><span class="pre">/</span></code> <code class="docutils literal notranslate"><span class="pre">%</span></code> <code class="docutils literal notranslate"><span class="pre">**</span></code>
binary   <code class="docutils literal notranslate"><span class="pre">==</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>
binary   <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> <code class="docutils literal notranslate"><span class="pre">|</span></code> <code class="docutils literal notranslate"><span class="pre">^</span></code> <code class="docutils literal notranslate"><span class="pre">by</span></code>
binary   <code class="docutils literal notranslate"><span class="pre">=</span></code> <code class="docutils literal notranslate"><span class="pre">+=</span></code> <code class="docutils literal notranslate"><span class="pre">-=</span></code> <code class="docutils literal notranslate"><span class="pre">*=</span></code> <code class="docutils literal notranslate"><span class="pre">/=</span></code> <code class="docutils literal notranslate"><span class="pre">%=</span></code> <code class="docutils literal notranslate"><span class="pre">**=</span></code>
binary   <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code> <code class="docutils literal notranslate"><span class="pre">|=</span></code> <code class="docutils literal notranslate"><span class="pre">^=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;~&gt;</span></code></p>
<p>The arity and precedence of the operator must be maintained when it is
overloaded. Operator resolution follows the same algorithm as function
resolution.</p>
<p>Assignment overloads are not supported for class types.</p>
</div>
<div class="section" id="function-resolution">
<span id="id27"></span><h2>Function Resolution<a class="headerlink" href="#function-resolution" title="Permalink to this headline">¶</a></h2>
<p><em>Function resolution</em> is the algorithm that determines which function to
invoke for a given call expression. Function resolution is defined as
follows.</p>
<ul class="simple">
<li>Identify the set of visible functions for the function call. A
<em>visible function</em> is any function that satisfies the criteria
in&nbsp;<a class="reference internal" href="#determining-visible-functions"><span class="std std-ref">Determining Visible Functions</span></a>. If no visible
function can be found, the compiler will issue an error stating that
the call cannot be resolved.</li>
<li>From the set of visible functions for the function call, determine
the set of candidate functions for the function call. A <em>candidate
function</em> is any function that satisfies the criteria
in&nbsp;<a class="reference internal" href="#determining-candidate-functions"><span class="std std-ref">Determining Candidate Functions</span></a>. If no candidate
function can be found, the compiler will issue an error stating that
the call cannot be resolved. If exactly one candidate function is
found, this is determined to be the function.</li>
<li>From the set of candidate functions, determine the set of most
specific functions. In most cases, there is one most specific
function, but there can be several if they differ only in return
intent. The set of most specific functions is the set of functions
that are not <em>more specific</em> than each other but that are <em>more
specific</em> than every other candidate function. The <em>more specific</em>
relationship is defined in
&nbsp;<a class="reference internal" href="#determining-more-specific-functions"><span class="std std-ref">Determining More Specific Functions</span></a>.</li>
<li>From the set of most specific functions, the compiler determines a
best function for each return intent as described in
&nbsp;<a class="reference internal" href="#determining-best-functions"><span class="std std-ref">Determining Best Functions</span></a>. If there is more than
one best function for a given return intent, the compiler will issue
an error stating that the call is ambiguous. Otherwise, it will
choose which function to call based on the calling context as
described in&nbsp;<a class="reference internal" href="#choosing-return-intent-overload"><span class="std std-ref">Choosing Return Intent Overloads Based on Calling Context</span></a>.</li>
</ul>
<div class="section" id="determining-visible-functions">
<span id="id28"></span><h3>Determining Visible Functions<a class="headerlink" href="#determining-visible-functions" title="Permalink to this headline">¶</a></h3>
<p>Given a function call, a function is determined to be a <em>visible
function</em> if the name of the function is the same as the name of the
function call and the function is defined in the same scope as the
function call or a lexical outer scope of the function call, or if the
function is publicly declared in a module that is used from the same
scope as the function call or a lexical outer scope of the function
call. Function visibility in generic functions is discussed
in&nbsp;<a class="reference internal" href="generics.html#function-visibility-in-generic-functions"><span class="std std-ref">Function Visibility in Generic Functions</span></a>.</p>
</div>
<div class="section" id="determining-candidate-functions">
<span id="id29"></span><h3>Determining Candidate Functions<a class="headerlink" href="#determining-candidate-functions" title="Permalink to this headline">¶</a></h3>
<p>Given a function call, a function is determined to be a <em>candidate
function</em> if there is a <em>valid mapping</em> from the function call to the
function and each actual argument is mapped to a formal argument that is
a <em>legal argument mapping</em>.</p>
<div class="section" id="valid-mapping">
<span id="id30"></span><h4>Valid Mapping<a class="headerlink" href="#valid-mapping" title="Permalink to this headline">¶</a></h4>
<p>The following algorithm determines a valid mapping from a function call
to a function if one exists:</p>
<ul class="simple">
<li>Each actual argument that is passed by name is matched to the formal
argument with that name. If there is no formal argument with that
name, there is no valid mapping.</li>
<li>The remaining actual arguments are mapped in order to the remaining
formal arguments in order. If there are more actual arguments then
formal arguments, there is no valid mapping. If any formal argument
that is not mapped to by an actual argument does not have a default
value, there is no valid mapping.</li>
<li>The valid mapping is the mapping of actual arguments to formal
arguments plus default values to formal arguments that are not mapped
to by actual arguments.</li>
</ul>
</div>
<div class="section" id="legal-argument-mapping">
<span id="id31"></span><h4>Legal Argument Mapping<a class="headerlink" href="#legal-argument-mapping" title="Permalink to this headline">¶</a></h4>
<p>An actual argument of type <span class="math notranslate nohighlight">\(T_A\)</span> can be mapped to a formal
argument of type <span class="math notranslate nohighlight">\(T_F\)</span> if any of the following conditions hold:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(T_A\)</span> and <span class="math notranslate nohighlight">\(T_F\)</span> are the same type.</li>
<li>There is an implicit conversion from <span class="math notranslate nohighlight">\(T_A\)</span> to <span class="math notranslate nohighlight">\(T_F\)</span>.</li>
<li><span class="math notranslate nohighlight">\(T_A\)</span> is derived from <span class="math notranslate nohighlight">\(T_F\)</span>.</li>
<li><span class="math notranslate nohighlight">\(T_A\)</span> is scalar promotable to <span class="math notranslate nohighlight">\(T_F\)</span>.</li>
</ul>
</div>
</div>
<div class="section" id="determining-more-specific-functions">
<span id="id32"></span><h3>Determining More Specific Functions<a class="headerlink" href="#determining-more-specific-functions" title="Permalink to this headline">¶</a></h3>
<p>Given two functions <span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span>, the more specific
function is determined by the first of the following steps that applies:</p>
<ul class="simple">
<li>If <span class="math notranslate nohighlight">\(F_1\)</span> does not require promotion and <span class="math notranslate nohighlight">\(F_2\)</span> does
require promotion, then <span class="math notranslate nohighlight">\(F_1\)</span> is more specific.</li>
<li>If <span class="math notranslate nohighlight">\(F_2\)</span> does not require promotion and <span class="math notranslate nohighlight">\(F_1\)</span> does
require promotion, then <span class="math notranslate nohighlight">\(F_2\)</span> is more specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_1\)</span> is a
<em>more specific argument mapping</em> than the corresponding legal
argument mapping to <span class="math notranslate nohighlight">\(F_2\)</span> and none of the legal argument
mappings to <span class="math notranslate nohighlight">\(F_2\)</span> is a more specific argument mapping than the
corresponding legal argument mapping to <span class="math notranslate nohighlight">\(F_1\)</span>, then <span class="math notranslate nohighlight">\(F_1\)</span>
is more specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_2\)</span> is a
<em>more specific argument mapping</em> than the corresponding legal
argument mapping to <span class="math notranslate nohighlight">\(F_1\)</span> and none of the legal argument
mappings to <span class="math notranslate nohighlight">\(F_1\)</span> is a more specific argument mapping than the
corresponding legal argument mapping to <span class="math notranslate nohighlight">\(F_2\)</span>, then <span class="math notranslate nohighlight">\(F_2\)</span>
is more specific.</li>
<li>If <span class="math notranslate nohighlight">\(F_1\)</span> shadows <span class="math notranslate nohighlight">\(F_2\)</span>, then <span class="math notranslate nohighlight">\(F_1\)</span> is more
specific.</li>
<li>If <span class="math notranslate nohighlight">\(F_2\)</span> shadows <span class="math notranslate nohighlight">\(F_1\)</span>, then <span class="math notranslate nohighlight">\(F_2\)</span> is more
specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_1\)</span> is
<em>weak preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_2\)</span> are <em>weak preferred</em>, then <span class="math notranslate nohighlight">\(F_1\)</span> is more specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_2\)</span> is
<em>weak preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_1\)</span> are <em>weak preferred</em>, then <span class="math notranslate nohighlight">\(F_2\)</span> is more specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_1\)</span> is
<em>weaker preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_2\)</span> are <em>weaker preferred</em>, then <span class="math notranslate nohighlight">\(F_1\)</span> is more
specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_2\)</span> is
<em>weaker preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_1\)</span> are <em>weaker preferred</em>, then <span class="math notranslate nohighlight">\(F_2\)</span> is more
specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_1\)</span> is
<em>weakest preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_2\)</span> are <em>weakest preferred</em>, then <span class="math notranslate nohighlight">\(F_1\)</span> is more
specific.</li>
<li>If at least one of the legal argument mappings to <span class="math notranslate nohighlight">\(F_2\)</span> is
<em>weakest preferred</em> and none of the legal argument mappings to
<span class="math notranslate nohighlight">\(F_1\)</span> are <em>weakest preferred</em>, then <span class="math notranslate nohighlight">\(F_2\)</span> is more
specific.</li>
<li>Otherwise neither function is more specific.</li>
</ul>
<p>Given an argument mapping, <span class="math notranslate nohighlight">\(M_1\)</span>, from an actual argument,
<span class="math notranslate nohighlight">\(A\)</span>, of type <span class="math notranslate nohighlight">\(T_A\)</span> to a formal argument, <span class="math notranslate nohighlight">\(F1\)</span>, of type
<span class="math notranslate nohighlight">\(T_{F1}\)</span> and an argument mapping, <span class="math notranslate nohighlight">\(M_2\)</span>, from the same
actual argument to a formal argument, <span class="math notranslate nohighlight">\(F2\)</span>, of type
<span class="math notranslate nohighlight">\(T_{F2}\)</span>, the level of preference for one of these argument
mappings is determined by the first of the following steps that applies:</p>
<ul>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are the same type, <span class="math notranslate nohighlight">\(F1\)</span> is
an instantiated parameter, and <span class="math notranslate nohighlight">\(F2\)</span> is not an instantiated
parameter, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are the same type, <span class="math notranslate nohighlight">\(F2\)</span> is
an instantiated parameter, and <span class="math notranslate nohighlight">\(F1\)</span> is not an instantiated
parameter, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(M_1\)</span> does not require scalar promotion and <span class="math notranslate nohighlight">\(M_2\)</span>
requires scalar promotion, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(M_1\)</span> requires scalar promotion and <span class="math notranslate nohighlight">\(M_2\)</span> does not
require scalar promotion, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are the same type, <span class="math notranslate nohighlight">\(F1\)</span> is
generic, and <span class="math notranslate nohighlight">\(F2\)</span> is not generic, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are the same type, <span class="math notranslate nohighlight">\(F2\)</span> is
generic, and <span class="math notranslate nohighlight">\(F1\)</span> is not generic, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F1\)</span> is not generic over all types and <span class="math notranslate nohighlight">\(F2\)</span> is generic
over all types, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F1\)</span> is generic over all types and <span class="math notranslate nohighlight">\(F2\)</span> is not generic
over all types, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F1\)</span> and <span class="math notranslate nohighlight">\(F2\)</span> are both generic, and <span class="math notranslate nohighlight">\(F1\)</span> is
partially concrete but <span class="math notranslate nohighlight">\(F2\)</span> is not, then <span class="math notranslate nohighlight">\(M_1\)</span> is more
specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F1\)</span> and <span class="math notranslate nohighlight">\(F2\)</span> are both generic, and <span class="math notranslate nohighlight">\(F2\)</span> is
partially concrete but <span class="math notranslate nohighlight">\(F1\)</span> is not, then <span class="math notranslate nohighlight">\(M_2\)</span> is more
specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F1\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument but <span class="math notranslate nohighlight">\(F2\)</span> is not, then
<span class="math notranslate nohighlight">\(M_1\)</span> is weak preferred.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(F2\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument but <span class="math notranslate nohighlight">\(F1\)</span> is not, then
<span class="math notranslate nohighlight">\(M_2\)</span> is weak preferred.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(A\)</span> is not a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size and
<span class="math notranslate nohighlight">\(F2\)</span> requires a narrowing conversion but <span class="math notranslate nohighlight">\(F1\)</span> does not,
then <span class="math notranslate nohighlight">\(M_1\)</span> is weak preferred.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(A\)</span> is not a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size and
<span class="math notranslate nohighlight">\(F1\)</span> requires a narrowing conversion but <span class="math notranslate nohighlight">\(F2\)</span> does not,
then <span class="math notranslate nohighlight">\(M_2\)</span> is weak preferred.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_A\)</span> and <span class="math notranslate nohighlight">\(T_{F1}\)</span> are the same type and <span class="math notranslate nohighlight">\(T_A\)</span>
and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are not the same type, <span class="math notranslate nohighlight">\(M_1\)</span> is more
specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_A\)</span> and <span class="math notranslate nohighlight">\(T_{F1}\)</span> are not the same type and
<span class="math notranslate nohighlight">\(T_A\)</span> and <span class="math notranslate nohighlight">\(T_{F2}\)</span> are the same type, <span class="math notranslate nohighlight">\(M_2\)</span> is more
specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(A\)</span> uses a scalar promotion type equal to <span class="math notranslate nohighlight">\(T_{F1}\)</span> but
different from <span class="math notranslate nohighlight">\(T_{F2}\)</span>, then <span class="math notranslate nohighlight">\(M_1\)</span> will be preferred as
follows:</p>
<ul class="simple">
<li>if <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size, then
<span class="math notranslate nohighlight">\(M_1\)</span> is weakest preferred</li>
<li>if <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with non-default size, then
<span class="math notranslate nohighlight">\(M_1\)</span> is weaker preferred</li>
<li>otherwise, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific</li>
</ul>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(A\)</span> uses a scalar promotion type equal to <span class="math notranslate nohighlight">\(T_{F2}\)</span> but
different from <span class="math notranslate nohighlight">\(T_{F1}\)</span>, then <span class="math notranslate nohighlight">\(M_2\)</span> will be preferred as
follows:</p>
<ul class="simple">
<li>if <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size, then
<span class="math notranslate nohighlight">\(M_2\)</span> is weakest preferred</li>
<li>if <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with non-default size, then
<span class="math notranslate nohighlight">\(M_2\)</span> is weaker preferred</li>
<li>otherwise, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific</li>
</ul>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_A\)</span> or its scalar promotion type prefers conversion to
<span class="math notranslate nohighlight">\(T_{F1}\)</span> over conversion to <span class="math notranslate nohighlight">\(T_{F2}\)</span>, then <span class="math notranslate nohighlight">\(M_1\)</span> is
preferred. If <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size,
then <span class="math notranslate nohighlight">\(M_1\)</span> is weakest preferred. Otherwise, <span class="math notranslate nohighlight">\(M_1\)</span> is
weaker preferred.</p>
<p>Type conversion preferences are as follows:</p>
<ul class="simple">
<li>Prefer converting a numeric argument to a numeric argument of a
different width but the same category over converting to another
type. Categories are<ul>
<li>bool</li>
<li>enum</li>
<li>int or uint</li>
<li>real</li>
<li>imag</li>
<li>complex</li>
</ul>
</li>
<li>Prefer an enum or bool cast to int over uint</li>
<li>Prefer an enum or bool cast to a default-sized int or uint over
another size of int or uint</li>
<li>Prefer an enum, bool, int, or uint cast to a default-sized real
over another size of real or complex</li>
<li>Prefer an enum, bool, int, or uint cast to a default-sized complex
over another size of complex</li>
<li>Prefer real/imag cast to the complex with that component size (ie
total width of twice the real/imag) over another size of complex</li>
</ul>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_A\)</span> or its scalar promotion type prefers conversion to
<span class="math notranslate nohighlight">\(T_{F2}\)</span> over conversion to <span class="math notranslate nohighlight">\(T_{F1}\)</span>, then <span class="math notranslate nohighlight">\(M_2\)</span> is
preferred. If <span class="math notranslate nohighlight">\(A\)</span> is a <code class="docutils literal notranslate"><span class="pre">param</span></code> argument with a default size,
then <span class="math notranslate nohighlight">\(M_2\)</span> is weakest preferred. Otherwise, <span class="math notranslate nohighlight">\(M_2\)</span> is
weaker preferred.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> is derived from <span class="math notranslate nohighlight">\(T_{F2}\)</span>, then <span class="math notranslate nohighlight">\(M_1\)</span> is
more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F2}\)</span> is derived from <span class="math notranslate nohighlight">\(T_{F1}\)</span>, then <span class="math notranslate nohighlight">\(M_2\)</span> is
more specific.</p>
</li>
<li><p class="first">If there is an implicit conversion from <span class="math notranslate nohighlight">\(T_{F1}\)</span> to
<span class="math notranslate nohighlight">\(T_{F2}\)</span>, then <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If there is an implicit conversion from <span class="math notranslate nohighlight">\(T_{F2}\)</span> to
<span class="math notranslate nohighlight">\(T_{F1}\)</span>, then <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F1}\)</span> is any <code class="docutils literal notranslate"><span class="pre">int</span></code> type and <span class="math notranslate nohighlight">\(T_{F2}\)</span> is any
<code class="docutils literal notranslate"><span class="pre">uint</span></code> type, <span class="math notranslate nohighlight">\(M_1\)</span> is more specific.</p>
</li>
<li><p class="first">If <span class="math notranslate nohighlight">\(T_{F2}\)</span> is any <code class="docutils literal notranslate"><span class="pre">int</span></code> type and <span class="math notranslate nohighlight">\(T_{F1}\)</span> is any
<code class="docutils literal notranslate"><span class="pre">uint</span></code> type, <span class="math notranslate nohighlight">\(M_2\)</span> is more specific.</p>
</li>
<li><p class="first">Otherwise neither mapping is more specific.</p>
</li>
</ul>
</div>
<div class="section" id="determining-best-functions">
<span id="id33"></span><h3>Determining Best Functions<a class="headerlink" href="#determining-best-functions" title="Permalink to this headline">¶</a></h3>
<p>Given the set of most specific functions for a given return intent, only
the following function(s) are selected as best functions:</p>
<ul class="simple">
<li>all functions, if none of them contain a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause;</li>
<li>only those functions that have a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, otherwise.</li>
</ul>
</div>
<div class="section" id="choosing-return-intent-overloads-based-on-calling-context">
<span id="choosing-return-intent-overload"></span><h3>Choosing Return Intent Overloads Based on Calling Context<a class="headerlink" href="#choosing-return-intent-overloads-based-on-calling-context" title="Permalink to this headline">¶</a></h3>
<p>See also <a class="reference external" href="#Return_Intent_Overloads">13.7.3</a>.</p>
<p>The compiler can choose between overloads differing in return intent
when:</p>
<ul class="simple">
<li>there are zero or one best functions for each of <code class="docutils literal notranslate"><span class="pre">ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span></code>, or the default (blank) return intent</li>
<li>at least two of the above return intents have a best function.</li>
</ul>
<p>In that case, the compiler is able to choose between <code class="docutils literal notranslate"><span class="pre">ref</span></code> return,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return, and value return functions based upon the context
of the call. The compiler chooses between these return intent overloads
as follows:</p>
<p>If present, a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return version will be chosen when:</p>
<ul class="simple">
<li>the call appears on the left-hand side of a variable initialization
or assignment statement</li>
<li>the call is passed to another function as a formal argument with
<code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>, or <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent</li>
<li>the call is captured into a <code class="docutils literal notranslate"><span class="pre">ref</span></code> variable</li>
<li>the call is returned from a function with <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent</li>
</ul>
<p>Otherwise, the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return or value return version will be
chosen. If only one of these is in the set of most specific functions,
it will be chosen. If both are present in the set, the choice will be
made as follows:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> version will be chosen when:</p>
<ul class="simple">
<li>the call is passed to another function as a formal argument with
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent</li>
<li>the call is captured into a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> variable</li>
<li>the call is returned from a function with <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent</li>
</ul>
<p>Otherwise, the value version will be chosen.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="methods.html" class="btn btn-neutral float-right" title="Methods" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>