

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tuples &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Classes" href="classes.html" />
    <link rel="prev" title="Error Handling" href="error-handling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "language/spec/tuples";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tuples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tuple-types">Tuple Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-values">Tuple Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-indexing">Tuple Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iteration-over-tuples">Iteration over Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-assignment">Tuple Assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-destructuring">Tuple Destructuring</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#splitting-a-tuple-with-assignment">Splitting a Tuple with Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#splitting-a-tuple-in-a-declaration">Splitting a Tuple in a Declaration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#splitting-a-tuple-into-multiple-indices-of-a-loop">Splitting a Tuple into Multiple Indices of a Loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#splitting-a-tuple-into-multiple-formal-arguments-in-a-function-call">Splitting a Tuple into Multiple Formal Arguments in a Function Call</a></li>
<li class="toctree-l4"><a class="reference internal" href="#splitting-a-tuple-via-tuple-expansion">Splitting a Tuple via Tuple Expansion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#value-tuples-and-referential-tuples">Value Tuples and Referential Tuples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tuple-expression-behavior">Tuple Expression Behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-variable-behavior">Tuple Variable Behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-argument-intents">Tuple Argument Intents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-argument-behavior">Tuple Argument Behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-return-behavior">Tuple Return Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-operators">Tuple Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unary-operators">Unary Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binary-operators">Binary Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relational-operators">Relational Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#predefined-functions-and-methods-on-tuples">Predefined Functions and Methods on Tuples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Tuples</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/tuples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tuples">
<span id="chapter-tuples"></span><h1>Tuples<a class="headerlink" href="#tuples" title="Permalink to this headline">¶</a></h1>
<p>A tuple is an ordered set of components that allows for the
specification of a light-weight collection of values. As the examples in
this chapter illustrate, tuples are a boon to the Chapel programmer. In
addition to making it easy to return multiple values from a function,
tuples help to support multidimensional indices, to group arguments to
functions, and to specify mathematical concepts.</p>
<div class="section" id="tuple-types">
<span id="id1"></span><h2>Tuple Types<a class="headerlink" href="#tuple-types" title="Permalink to this headline">¶</a></h2>
<p>A tuple type is defined by a fixed number (a compile-time constant) of
component types. It can be specified by a parenthesized, comma-separated
list of types. The number of types in the list defines the size of the
tuple; the types themselves specify the component types.</p>
<p>The syntax of a tuple type is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>tuple-type:
  ( type-expression , type-list )
  ( type-expression , )

type-list:
  type-expression
  type-expression , type-list
</pre></div>
</div>
<p>A homogeneous tuple is a special-case of a general tuple where the types
of the components are identical. Homogeneous tuples have fewer
restrictions for how they can be
indexed&nbsp;(<a class="reference internal" href="#tuple-indexing"><span class="std std-ref">Tuple Indexing</span></a>). Homogeneous tuple types can be
defined using the above syntax, or they can be defined as a product of
an integral parameter (a compile-time constant integer) and a type.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Homogeneous tuples require the size to be specified as a parameter (a
compile-time constant). This avoids any overhead associated with
storing the runtime size in the tuple. It also avoids the question as
to whether a non-parameter size should be part of the type of the
tuple. If a programmer requires a non-parameter value to define a
data structure, an array may be a better choice.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (homogeneous.chpl)</em>.</p>
<p>The statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">real</span><span class="p">),</span>
    <span class="nx">x2</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span>
    <span class="nx">x3</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>defines three variables. Variable <code class="docutils literal notranslate"><span class="pre">x1</span></code> is a 2-tuple with component
types <code class="docutils literal notranslate"><span class="pre">string</span></code> and <code class="docutils literal notranslate"><span class="pre">real</span></code>. Variables <code class="docutils literal notranslate"><span class="pre">x2</span></code> and <code class="docutils literal notranslate"><span class="pre">x3</span></code> are
homogeneous 3-tuples with component type <code class="docutils literal notranslate"><span class="pre">int</span></code>. The types of <code class="docutils literal notranslate"><span class="pre">x2</span></code>
and <code class="docutils literal notranslate"><span class="pre">x3</span></code> are identical even though they are specified in different
ways.</p>
</div></blockquote>
<p>Note that if a single type is delimited by parentheses, the parentheses
only impact precedence. Thus <code class="docutils literal notranslate"><span class="pre">(int)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Nevertheless, tuple types with a single component type are legal and
useful. One way to specify a 1-tuple is to use the overloaded <code class="docutils literal notranslate"><span class="pre">*</span></code>
operator since every 1-tuple is trivially a homogeneous tuple.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Like parentheses around expressions, parentheses around types are
necessary for grouping in order to avoid the default precedence of
the grammar. Thus it is not the case that we would always want to
create a tuple. The type <code class="docutils literal notranslate"><span class="pre">3*(3*int)</span></code> specifies a 3-tuple of
3-tuples of integers rather than a 3-tuple of 1-tuples of 3-tuples of
integers. The type <code class="docutils literal notranslate"><span class="pre">3*3*int</span></code>, on the other hand, specifies a
9-tuple of integers.</p>
</div></blockquote>
</div>
<div class="section" id="tuple-values">
<span id="id2"></span><h2>Tuple Values<a class="headerlink" href="#tuple-values" title="Permalink to this headline">¶</a></h2>
<p>A value of a tuple type attaches a value to each component type. Tuple
values can be specified by a parenthesized, comma-separated list of
expressions. The number of expressions in the list defines the size of
the tuple; the types of these expressions specify the component types of
the tuple. A trailing comma is allowed.</p>
<p>The syntax of a tuple expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>tuple-expression:
  ( tuple-component , )
  ( tuple-component , tuple-component-list )
  ( tuple-component , tuple-component-list , )

tuple-component:
  expression
  `_&#39;

tuple-component-list:
  tuple-component
  tuple-component , tuple-component-list
</pre></div>
</div>
<p>An underscore can be used to omit components when splitting a tuple (see
<a class="reference external" href="#Assignments_in_a_Tuple">16.6.1</a>).</p>
<blockquote>
<div><p><em>Example (values.chpl)</em>.</p>
<p>The statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">real</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">),</span>
    <span class="nx">x2</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="nx">x3</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</pre></div>
</div>
<p>defines three tuple variables. Variable <code class="docutils literal notranslate"><span class="pre">x1</span></code> is a 2-tuple with
component types <code class="docutils literal notranslate"><span class="pre">string</span></code> and <code class="docutils literal notranslate"><span class="pre">real</span></code>. It is initialized such
that the two components are <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">3.14</span></code>, respectively.
Variables <code class="docutils literal notranslate"><span class="pre">x2</span></code> and <code class="docutils literal notranslate"><span class="pre">x3</span></code> are homogeneous 3-tuples with component
type <code class="docutils literal notranslate"><span class="pre">int</span></code>. Their initialization expressions specify 3-tuples of
integers.</p>
</div></blockquote>
<p>Note that if a single expression is delimited by parentheses, the
parentheses only impact precedence. Thus <code class="docutils literal notranslate"><span class="pre">(1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
To specify a 1-tuple, use the form with the trailing comma <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>.</p>
<blockquote>
<div><p><em>Example (onetuple.chpl)</em>.</p>
<p>The statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,);</span>
</pre></div>
</div>
<p>creates a 1-tuple of integers storing the value 7.</p>
</div></blockquote>
<p>Tuple expressions are evaluated similarly to function calls where the
arguments are all generic with no explicit intent. So a tuple expression
containing an array does not copy the array.</p>
<p>When a tuple is passed as an argument to a function, it is passed as if
it is a record type containing fields of the same type and in the same
order as in the tuple.</p>
</div>
<div class="section" id="tuple-indexing">
<span id="id3"></span><h2>Tuple Indexing<a class="headerlink" href="#tuple-indexing" title="Permalink to this headline">¶</a></h2>
<p>A tuple component may be accessed by an integral parameter (a
compile-time constant) as if the tuple were an array. Indexing is
0-based, so the first component in the tuple is accessed by the index
<code class="docutils literal notranslate"><span class="pre">0</span></code>, and so forth.</p>
<blockquote>
<div><p><em>Example (access.chpl)</em>.</p>
<p>The loop</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">myTuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">);</span>
<span class="k">for</span> <span class="kd">param</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">myTuple</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</pre></div>
</div>
<p>uses a param loop to output the components of a tuple.</p>
</div></blockquote>
<p>Homogeneous tuples may be accessed by integral values that are not
necessarily compile-time constants.</p>
<blockquote>
<div><p><em>Example (access-homogeneous.chpl)</em>.</p>
<p>The loop</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">myHTuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">myHTuple</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</pre></div>
</div>
<p>uses a serial loop to output the components of a homogeneous tuple.
Since the index is not a compile-time constant, this would result in
an error were tuple not homogeneous.</p>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Non-homogeneous tuples can only be accessed by compile-time constants
since the type of an expression must be statically known.</p>
</div></blockquote>
</div>
<div class="section" id="iteration-over-tuples">
<span id="id4"></span><h2>Iteration over Tuples<a class="headerlink" href="#iteration-over-tuples" title="Permalink to this headline">¶</a></h2>
<p>Homogeneous tuples support iteration via standard <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">forall</span></code>
and <code class="docutils literal notranslate"><span class="pre">coforall</span></code> loops. These loops iterate over all of the tuple’s
elements. A loop of the form:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">for</span><span class="o">|</span><span class="k">forall</span><span class="o">|</span><span class="k">coforall</span><span class="p">]</span> <span class="nx">e</span> <span class="kd">in</span> <span class="nx">t</span> <span class="k">do</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">e</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
<p>where t is a homogeneous tuple of size <code class="docutils literal notranslate"><span class="pre">n</span></code>, is semantically equivalent
to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">for</span><span class="o">|</span><span class="k">forall</span><span class="o">|</span><span class="k">coforall</span><span class="p">]</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span> <span class="k">do</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">t</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
<p>The iterator variable for a tuple iteration is a either a const value
or a reference to the tuple element type, following default intent
semantics.</p>
<p>Heterogeneous tuples support iteration via standard <code class="docutils literal notranslate"><span class="pre">for</span></code> and
<code class="docutils literal notranslate"><span class="pre">coforall</span></code> loops.  These loops iterate over all of the tuple’s
elements, giving each iteration its own index variable that is a
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> to the tuple element (note: this may change in the
future to include <code class="docutils literal notranslate"><span class="pre">const</span></code> or <code class="docutils literal notranslate"><span class="pre">ref</span></code> index variables).  Thus, a
loop of the form:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">e</span> <span class="kd">in</span> <span class="nx">t</span> <span class="k">do</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">e</span><span class="o">..</span><span class="p">.</span>
</pre></div>
</div>
<p>where t is a heterogeneous tuple of size <code class="docutils literal notranslate"><span class="pre">n</span></code> is semantically
equivalent to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="c1">// iteration 0</span>
  <span class="kd">const</span> <span class="kd">ref</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">e</span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
<span class="p">{</span> <span class="c1">// iteration 1</span>
  <span class="kd">const</span> <span class="kd">ref</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">e</span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
<span class="o">..</span><span class="p">.</span>
<span class="p">{</span> <span class="c1">// iteration n-1</span>
  <span class="kd">const</span> <span class="kd">ref</span> <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="o">..</span><span class="p">.</span><span class="nx">e</span><span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, a <cite>coforall</cite> loop is equivalent to the <cite>cobegin</cite> statement
whose body is the series of compound statements from the serial case.</p>
</div>
<div class="section" id="tuple-assignment">
<span id="id5"></span><h2>Tuple Assignment<a class="headerlink" href="#tuple-assignment" title="Permalink to this headline">¶</a></h2>
<p>In tuple assignment, the components of the tuple on the left-hand side
of the assignment operator are each assigned the components of the tuple
on the right-hand side of the assignment. These assignments occur in
component order (component zero followed by component one, etc.).</p>
</div>
<div class="section" id="tuple-destructuring">
<span id="id6"></span><h2>Tuple Destructuring<a class="headerlink" href="#tuple-destructuring" title="Permalink to this headline">¶</a></h2>
<p>Tuples can be split into their components in the following ways:</p>
<ul class="simple">
<li>In assignment where multiple expression on the left-hand side of the
assignment operator are grouped using tuple notation.</li>
<li>In variable declarations where multiple variables in a declaration
are grouped using tuple notation.</li>
<li>In for, forall, and coforall loops (statements and expressions) where
multiple indices in a loop are grouped using tuple notation.</li>
<li>In function calls where multiple formal arguments in a function
declaration are grouped using tuple notation.</li>
<li>In an expression context that accepts a comma-separated list of
expressions where a tuple expression is expanded in place using the
tuple expansion expression.</li>
</ul>
<div class="section" id="splitting-a-tuple-with-assignment">
<span id="assignments-in-a-tuple"></span><h3>Splitting a Tuple with Assignment<a class="headerlink" href="#splitting-a-tuple-with-assignment" title="Permalink to this headline">¶</a></h3>
<p>When multiple expression on the left-hand side of an assignment operator
are grouped using tuple notation, the tuple on the right-hand side is
split into its components. The number of grouped expressions must be
equal to the size of the tuple on the right-hand side. In addition to
the usual assignment evaluation order of left to right, the assignment
is evaluated in component order.</p>
<blockquote>
<div><p><em>Example (splitting.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
<p>defines three integer variables <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>. The second
line then splits the tuple <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">(2,</span> <span class="pre">3))</span></code> such that <code class="docutils literal notranslate"><span class="pre">1</span></code> is
assigned to <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code> is assigned to <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> is assigned
to <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (aliasing.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="nx">i</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
<span class="p">(</span><span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">),</span> <span class="nx">A</span><span class="p">(</span><span class="mi">3</span><span class="o">..</span><span class="mi">4</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="nx">A</span><span class="p">(</span><span class="mi">3</span><span class="o">..</span><span class="mi">4</span><span class="p">),</span> <span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>creates a non-distributed, one-dimensional array containing the four
integers from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">4</span></code>. Line 2 outputs <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span></code>. Line 3 does
what appears to be a swap of array slices. However, because the tuple
is created with array aliases (like a function call), the assignment
to the second component uses the values just overwritten in the
assignment to the first component. Line 4 outputs <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">4</span></code>.</p>
</div></blockquote>
<p>When splitting a tuple with assignment, the underscore token can be used
to omit storing some of the components. In this case, the full
expression on the right-hand side of the assignment operator is
evaluated, but the omitted values will not be assigned to anything.</p>
<blockquote>
<div><p><em>Example (omit-component.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">_</span><span class="p">)</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</pre></div>
</div>
<p>defines a function that returns a 2-tuple, declares an integer
variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, calls the function, assigns the first component in
the returned tuple to <code class="docutils literal notranslate"><span class="pre">x</span></code>, and ignores the other component in the
returned tuple. The value of <code class="docutils literal notranslate"><span class="pre">x</span></code> becomes <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="splitting-a-tuple-in-a-declaration">
<span id="variable-declarations-in-a-tuple"></span><h3>Splitting a Tuple in a Declaration<a class="headerlink" href="#splitting-a-tuple-in-a-declaration" title="Permalink to this headline">¶</a></h3>
<p>When multiple variables in a declaration are grouped using tuple
notation, the tuple initialization expression is split into its type
and/or value components. The number of grouped variables must be equal
to the size of the tuple initialization expression. The variables are
initialized in component order.</p>
<p>The syntax of grouped variable declarations is defined
in&nbsp;<a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">Variable Declarations</span></a>.</p>
<blockquote>
<div><p><em>Example (decl.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
<p>defines three integer variables <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>. It splits
the tuple <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">(2,</span> <span class="pre">3))</span></code> such that <code class="docutils literal notranslate"><span class="pre">1</span></code> initializes <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>
initializes <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> initializes <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</div></blockquote>
<p>Grouping variable declarations using tuple notation allows a 1-tuple to
be destructured by enclosing a single variable declaration in
parentheses.</p>
<blockquote>
<div><p><em>Example (onetuple-destruct.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">);</span>
</pre></div>
</div>
<p>initialize the new variable <code class="docutils literal notranslate"><span class="pre">a</span></code> to 1.</p>
</div></blockquote>
<p>When splitting a tuple into multiple variable declarations, the
underscore token may be used to omit components of the tuple rather than
declaring a new variable for them. In this case, no variables are
defined for the omitted components.</p>
<blockquote>
<div><p><em>Example (omit-component-decl.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="kd">var</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">_</span><span class="p">)</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</pre></div>
</div>
<p>defines a function that returns a 2-tuple, calls the function,
declares and initializes variable <code class="docutils literal notranslate"><span class="pre">x</span></code> to the first component in the
returned tuple, and ignores the other component in the returned
tuple. The value of <code class="docutils literal notranslate"><span class="pre">x</span></code> is initialized to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="splitting-a-tuple-into-multiple-indices-of-a-loop">
<span id="indices-in-a-tuple"></span><h3>Splitting a Tuple into Multiple Indices of a Loop<a class="headerlink" href="#splitting-a-tuple-into-multiple-indices-of-a-loop" title="Permalink to this headline">¶</a></h3>
<p>When multiple indices in a loop are grouped using tuple notation, the
tuple returned by the iterator (<a class="reference internal" href="iterators.html#chapter-iterators"><span class="std std-ref">Iterators</span></a>) is split
across the index tuple’s components. The number of indices in the index
tuple must equal the size of the tuple returned by the iterator.</p>
<blockquote>
<div><p><em>Example (indices.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">iter</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">yield</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">bar</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">);</span>
</pre></div>
</div>
<p>defines a simple iterator that yields two 2-tuples before completing.
The for-loop uses a tuple notation to group two indices that take
their values from the iterator.</p>
</div></blockquote>
<p>When a tuple is split across an index tuple, indices in the index tuple
(left-hand side) may be omitted. In this case, no indices are defined
for the omitted components.</p>
<p>However even when indices are omitted, the iterator is evaluated as if
an index were defined. Execution proceeds as if the omitted indices are
present but invisible. This means that the loop body controlled by the
iterator may be executed multiple times with the same set of (visible)
indices.</p>
</div>
<div class="section" id="splitting-a-tuple-into-multiple-formal-arguments-in-a-function-call">
<span id="formal-argument-declarations-in-a-tuple"></span><h3>Splitting a Tuple into Multiple Formal Arguments in a Function Call<a class="headerlink" href="#splitting-a-tuple-into-multiple-formal-arguments-in-a-function-call" title="Permalink to this headline">¶</a></h3>
<p>When multiple formal arguments in a function declaration are grouped
using tuple notation, the actual expression is split into its components
during a function call. The number of grouped formal arguments must be
equal to the size of the actual tuple expression. The actual arguments
are passed in component order to the formal arguments.</p>
<p>The syntax of grouped formal arguments is defined
in&nbsp;<a class="reference internal" href="procedures.html#function-definitions"><span class="std std-ref">Procedure Definitions</span></a>.</p>
<blockquote>
<div><p><em>Example (formals.chpl)</em>.</p>
<p>The function</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">):</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// body</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is defined to take an integer value and a 2-tuple of integer values.
The 2-tuple is split when the function is called into two formals. A
call may look like the following:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>An implicit <code class="docutils literal notranslate"><span class="pre">where</span></code> clause is created when arguments are grouped using
tuple notation, to ensure that the function is called with an actual
tuple of the correct size. Arguments grouped in tuples may be nested
arbitrarily. Functions with arguments grouped into tuples may not be
called using named-argument passing on the tuple-grouped arguments.</p>
<p>In addition, tuple-grouped arguments may not be specified individually with
types or default values (only in aggregate). They may not be specified
with any qualifier appearing before the group of arguments (or
individual arguments) such as <code class="docutils literal notranslate"><span class="pre">inout</span></code> or <code class="docutils literal notranslate"><span class="pre">type</span></code>. They may not be
followed by <code class="docutils literal notranslate"><span class="pre">...</span></code> to indicate that there are a variable number of
them.</p>
<blockquote>
<div><p><em>Example (implicit-where.chpl)</em>.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">f</span></code> defined as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)))</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to the function <code class="docutils literal notranslate"><span class="pre">g</span></code> defined as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">isTuple</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">isTuple</span><span class="p">(</span><span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">((</span><span class="nx">t</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>except without the definition of the argument name <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</div></blockquote>
<p>Grouping formal arguments using tuple notation allows a 1-tuple to be
destructured by enclosing a single formal argument in parentheses.</p>
<blockquote>
<div><p><em>Example (grouping-Formals.chpl)</em>.</p>
<p>The empty function</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">((</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>accepts a 1-tuple actual with any component type.</p>
</div></blockquote>
<p>When splitting a tuple into multiple formal arguments, the arguments
that are grouped using the tuple notation may be omitted. In this case,
no names are associated with the omitted components. The call is
evaluated as if an argument were defined.</p>
</div>
<div class="section" id="splitting-a-tuple-via-tuple-expansion">
<span id="tuple-expansion"></span><h3>Splitting a Tuple via Tuple Expansion<a class="headerlink" href="#splitting-a-tuple-via-tuple-expansion" title="Permalink to this headline">¶</a></h3>
<p>Tuples can be expanded in place using the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>tuple-expand-expression:
  ( ... expression )
</pre></div>
</div>
<p>In this expression, the tuple defined by <code class="docutils literal notranslate"><span class="pre">expression</span></code> is expanded in
place to represent its components. This can only be used in a context
where a comma-separated list of components is valid.</p>
<blockquote>
<div><p><em>Example (expansion.chpl)</em>.</p>
<p>Given two 2-tuples</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="nx">x2</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>the following statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x3</span> <span class="o">=</span> <span class="p">((</span><span class="o">..</span><span class="p">.</span><span class="nx">x1</span><span class="p">),</span> <span class="p">(</span><span class="o">..</span><span class="p">.</span><span class="nx">x2</span><span class="p">));</span>
</pre></div>
</div>
<p>creates the 4-tuple <code class="docutils literal notranslate"><span class="pre">x3</span></code> with the value
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2.0,</span> <span class="pre">&quot;three&quot;,</span> <span class="pre">&quot;four&quot;)</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (expansion-2.chpl)</em>.</p>
<p>The following code defines two functions, a function <code class="docutils literal notranslate"><span class="pre">first</span></code> that
returns the initial component of a tuple and a function <code class="docutils literal notranslate"><span class="pre">rest</span></code> that
returns a tuple containing all of the remaining components:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">first</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">isTuple</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">rest</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="k">where</span> <span class="nx">isTuple</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">rest</span><span class="o">..</span><span class="p">.)</span>
    <span class="k">return</span> <span class="nx">rest</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">helper</span><span class="p">((</span><span class="o">..</span><span class="p">.</span><span class="nx">t</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="value-tuples-and-referential-tuples">
<span id="id7"></span><h2>Value Tuples and Referential Tuples<a class="headerlink" href="#value-tuples-and-referential-tuples" title="Permalink to this headline">¶</a></h2>
<p>Throughout the next few sections, the terms referential tuple and value
tuple are used frequently to describe two different ways that tuples can
capture elements.</p>
<p>Tuple expressions or tuple arguments with default argument intent are two
examples of referential tuples. They store elements by reference where it
makes sense to do so. Referential tuples may be viewed as analogous to a
group of function arguments that each have default argument intent.</p>
<p>Tuple variables or tuple arguments with <code class="docutils literal notranslate"><span class="pre">in</span></code> intent are two examples of
value tuples. They store all elements by value and may store elements copy
initialized from another tuple. Value tuples may be viewed as analogous to
a group of function arguments that each have the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent.</p>
<p>In short, some or all of the elements of a referential tuple may be
references, while a value tuple will never contain a reference.</p>
<div class="section" id="tuple-expression-behavior">
<span id="id8"></span><h3>Tuple Expression Behavior<a class="headerlink" href="#tuple-expression-behavior" title="Permalink to this headline">¶</a></h3>
<p>Tuple expressions are a form of referential tuple. Like most other
referential tuples, tuple expressions capture each element based on the
default argument intent of the element’s type.</p>
<p>More specifically:</p>
<ul class="simple">
<li>If the default argument intent of the element’s type is a variation of
<code class="docutils literal notranslate"><span class="pre">ref</span></code>, then the tuple expression will refer to the element instead of
capturing it by value.</li>
<li>Otherwise, the tuple expression will capture the element by value.</li>
</ul>
<p>Consider the following example:</p>
<blockquote>
<div><p><em>Example (tuple-expression-behavior.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">0</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r</span><span class="p">:</span> <span class="nx">R</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// The int `i` is copied when captured into the tuple expression,</span>
<span class="c1">// but `a` and `r` are not.</span>
<span class="c1">//</span>
<span class="nx">test</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">));</span>

<span class="c1">// Modify the globals, then print the tuple.</span>
<span class="k">proc</span> <span class="nf">test</span><span class="p">(</span><span class="nx">tup</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// Outputs (1, 0, (x = 3)).</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The tuple expression <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">i,</span> <span class="pre">r)</span></code> will capture the array <code class="docutils literal notranslate"><span class="pre">a</span></code> and the
record <code class="docutils literal notranslate"><span class="pre">r</span></code> by <code class="docutils literal notranslate"><span class="pre">ref</span></code>, but will create a copy of the integer <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em></p>
<p>Tuple expressions and other forms of referential tuple are designed to act
like a light-weight bundle of arguments. They behave similarly to the
individual arguments of a function call.</p>
<p>It would be prohibitively expensive for some argument types (such as
arrays) to be copied by default when passed as an argument to a
function call.</p>
<p>The same logic applies to tuple expressions. When the default argument
intent of a value’s type is some form of <code class="docutils literal notranslate"><span class="pre">ref</span></code>, a tuple expression will
capture the value by reference in order to avoid a potentially
expensive copy operation.</p>
</div></blockquote>
</div>
<div class="section" id="tuple-variable-behavior">
<h3>Tuple Variable Behavior<a class="headerlink" href="#tuple-variable-behavior" title="Permalink to this headline">¶</a></h3>
<p>Tuple variables are a form of value tuple. Like other value tuples, tuple
variables will copy elements in a manner similar to passing the element
to an <code class="docutils literal notranslate"><span class="pre">in</span></code> intent argument.</p>
<p>For example, in this code:</p>
<blockquote>
<div><p><em>Example (tuple-variable-behavior.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">0</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// The tuple variable `tup` stores copies of `a`, `i`, and `r`.</span>
<span class="kd">var</span> <span class="nx">tup</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">);</span>

<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// This will output (0, 0, (x = 0)).</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Initialization of the tuple variable <code class="docutils literal notranslate"><span class="pre">tup</span></code> will make a copy of the
array <code class="docutils literal notranslate"><span class="pre">a</span></code>, the record <code class="docutils literal notranslate"><span class="pre">r</span></code>, and the integer <code class="docutils literal notranslate"><span class="pre">i</span></code>. Because <code class="docutils literal notranslate"><span class="pre">tup</span></code> stores
a copy of these three variables, changes made to them are not visible
in <code class="docutils literal notranslate"><span class="pre">tup</span></code> when it is written to standard output.</p>
</div>
<div class="section" id="tuple-argument-intents">
<span id="id9"></span><h3>Tuple Argument Intents<a class="headerlink" href="#tuple-argument-intents" title="Permalink to this headline">¶</a></h3>
<p>A tuple argument to a function may be either a referential tuple or a value
tuple depending on its argument intent.</p>
<p>If the tuple argument has the default argument intent, then it is a
referential tuple and some of its elements may be captured by <code class="docutils literal notranslate"><span class="pre">ref</span></code>
depending on their default argument intent.</p>
<p>A tuple argument declared with <code class="docutils literal notranslate"><span class="pre">const</span></code> intent will work similarly to one
with a default intent, except that all the elements of the tuple are
considered to be <code class="docutils literal notranslate"><span class="pre">const</span></code> and cannot be modified.</p>
<p>If the tuple argument has the <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intent, then it is a
value tuple. All of its elements are captured by value as though each
element is passed to an <code class="docutils literal notranslate"><span class="pre">in</span></code> intent argument.</p>
</div>
<div class="section" id="tuple-argument-behavior">
<span id="id10"></span><h3>Tuple Argument Behavior<a class="headerlink" href="#tuple-argument-behavior" title="Permalink to this headline">¶</a></h3>
<p>If a function argument is a tuple with the default argument intent and a
value tuple (such as a tuple variable) is passed to it, the value tuple
will be implicitly converted into a referential tuple. The resulting
referential tuple may refer to elements from the original value tuple.</p>
<p>A conversion from referential tuple to value tuple also occurs when a
referential tuple (such as a tuple expression) is passed to a tuple argument
that has the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent. The referential tuple will be converted to
a value tuple by copy initializing each element.</p>
<p>Consider the following example:</p>
<blockquote>
<div><p><em>Example (tuple-argument-behavior.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">modTup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="c1">//</span>
<span class="c1">// The argument `tup` of `referentialTupleArg` is a referential tuple</span>
<span class="c1">// due to the default argument intent.</span>
<span class="c1">//</span>
<span class="k">proc</span> <span class="nf">referentialTupleArg</span><span class="p">(</span><span class="nx">tup</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Modify the module variable `modTup`.</span>
  <span class="nx">modTup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>

  <span class="c1">//</span>
  <span class="c1">// Should print (0, (x = 6)). Recall that a tuple argument with the</span>
  <span class="c1">// default argument intent copies integer elements.</span>
  <span class="c1">//</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>

  <span class="c1">//</span>
  <span class="c1">// When `tup` is passed to `valueTupleArg`, a copy of each element</span>
  <span class="c1">// is made because the `valueTup` argument has the `in` intent.</span>
  <span class="c1">//</span>
  <span class="nx">valueTupleArg</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>

  <span class="c1">// Should still print (0, (x = 6)).</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The argument `valueTup` is a value tuple due to the `in` intent.</span>
<span class="k">proc</span> <span class="nf">valueTupleArg</span><span class="p">(</span><span class="kd">in</span> <span class="nx">valueTup</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">valueTup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">128</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="c1">// When `modTup` is passed to `referentialTupleArg`, its first</span>
<span class="c1">// element is copied while its second element is passed as though</span>
<span class="c1">// it were `const ref`.</span>
<span class="c1">//</span>
<span class="nx">referentialTupleArg</span><span class="p">(</span><span class="nx">modTup</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Tuple arguments with the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent are references to value tuples.
Actual arguments are restricted to value tuples (a tuple variable or a
returned tuple). Since the argument itself is passed by <code class="docutils literal notranslate"><span class="pre">ref</span></code>, the
entire tuple will refer to a tuple from the call site.</p>
<blockquote>
<div><p><em>Example (tuple-argument-ref-intent.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Because the intent of `tup` is `ref`, only value tuples can be</span>
<span class="c1">// passed to `passTupleByRef`.</span>
<span class="c1">//</span>
<span class="k">proc</span> <span class="nf">passTupleByRef</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">tup</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">modTup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Passing `modTup` to `passTupleByRef` will construct a referential</span>
<span class="c1">// tuple where each element refers to an element from `modTup`.</span>
<span class="c1">//</span>
<span class="nx">passTupleByRef</span><span class="p">(</span><span class="nx">modTup</span><span class="p">);</span>

<span class="c1">// Should print (64, 128).</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">modTup</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tuple-return-behavior">
<span id="id11"></span><h3>Tuple Return Behavior<a class="headerlink" href="#tuple-return-behavior" title="Permalink to this headline">¶</a></h3>
<p>When a tuple is returned from a function with <code class="docutils literal notranslate"><span class="pre">ref</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return
intent, it must refer to some form of value tuple that exists outside of
the current scope. Otherwise there is a compilation error.</p>
<p>Functions that return by value always return a value tuple. If an expression
returned by such a function is a referential tuple, it will be implicitly
converted to a value tuple.</p>
<blockquote>
<div><p><em>Example (tuple-return-behavior.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">0</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// The value tuple returned by `returnTuple` is passed to the</span>
<span class="c1">// function `updateGlobalsAndOutput`. It is implicitly converted</span>
<span class="c1">// into a referential tuple because the formal argument `tup`</span>
<span class="c1">// has the default argument intent.</span>
<span class="c1">//</span>
<span class="nx">updateGlobalsAndOutput</span><span class="p">(</span><span class="nx">returnTuple</span><span class="p">());</span>

<span class="c1">//</span>
<span class="c1">// The function `returnTuple` returns a value tuple that contains</span>
<span class="c1">// a copy of the array `a`, the integer `i`, and the record `r`.</span>
<span class="c1">//</span>
<span class="k">proc</span> <span class="nf">returnTuple</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">updateGlobalsAndOutput</span><span class="p">(</span><span class="nx">tup</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">//</span>
  <span class="c1">// Because the tuple passed to `updateGlobalsAndOutput` is a value</span>
  <span class="c1">// tuple and contains no references, the assignments made to `a`,</span>
  <span class="c1">// `i`, and `r` above are not visible in `tup` when it is printed.</span>
  <span class="c1">// This `writeln` will output (0, 0, (x = 0)).</span>
  <span class="c1">//</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">tup</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="tuple-operators">
<span id="id12"></span><h2>Tuple Operators<a class="headerlink" href="#tuple-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="unary-operators">
<span id="tuple-unary-operators"></span><h3>Unary Operators<a class="headerlink" href="#unary-operators" title="Permalink to this headline">¶</a></h3>
<p>The unary operators <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">~</span></code>, and <code class="docutils literal notranslate"><span class="pre">!</span></code> are overloaded on
tuples by applying the operator to each argument component and returning
the results as a new tuple.</p>
<p>The size of the result tuple is the same as the size of the argument
tuple. The type of each result component is the result type of the
operator when applied to the corresponding argument component.</p>
<p>The type of every element of the operand tuple must have a well-defined
operator matching the unary operator being applied. That is, if the
element type is a user-defined type, it must supply an overloaded
definition for the unary operator being used. Otherwise, a compile-time
error will be issued.</p>
</div>
<div class="section" id="binary-operators">
<span id="tuple-binary-operators"></span><h3>Binary Operators<a class="headerlink" href="#binary-operators" title="Permalink to this headline">¶</a></h3>
<p>The binary operators <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>,
<code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> are overloaded on tuples by applying
them to pairs of the respective argument components and returning the
results as a new tuple. The sizes of the two argument tuples must be the
same. These operators are also defined for homogeneous tuples and scalar
values of matching type.</p>
<p>The size of the result tuple is the same as the argument tuple(s). The
type of each result component is the result type of the operator when
applied to the corresponding pair of the argument components.</p>
<p>When a tuple binary operator is used, the same operator must be
well-defined for successive pairs of operands in the two tuples.
Otherwise, the operation is illegal and a compile-time error will
result.</p>
<blockquote>
<div><p><em>Example (binary-ops.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>creates a 3-tuple of an int, a real and a string with the value
<code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3.0,</span> <span class="pre">&quot;12&quot;)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="relational-operators">
<span id="tuple-relational-operators"></span><h3>Relational Operators<a class="headerlink" href="#relational-operators" title="Permalink to this headline">¶</a></h3>
<p>The relational operators <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, and
<code class="docutils literal notranslate"><span class="pre">!=</span></code> are defined over tuples of matching size. They return a single
boolean value indicating whether the two arguments satisfy the
corresponding relation.</p>
<p>The operators <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> check the corresponding
lexicographical order based on pair-wise comparisons between the
argument tuples’ components. The operators <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> check
whether the two arguments are pair-wise equal or not. The relational
operators on tuples may be short-circuiting, i.e. they may execute only
the pair-wise comparisons that are necessary to determine the result.</p>
<p>However, just as for other binary tuple operators, the corresponding
operation must be well-defined on each successive pair of operand types
in the two operand tuples. Otherwise, a compile-time error will result.</p>
<blockquote>
<div><p><em>Example (relational-ops.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>creates a variable initialized to <code class="docutils literal notranslate"><span class="pre">true</span></code>. After comparing the first
components and determining they are equal, the next components are
compared to determine that the first tuple is greater than the second
tuple.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="predefined-functions-and-methods-on-tuples">
<span id="id13"></span><h2>Predefined Functions and Methods on Tuples<a class="headerlink" href="#predefined-functions-and-methods-on-tuples" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descname">proc tuple.size param</code></dt>
<dd><p>Returns the size of the tuple.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc tuple.indices</code></dt>
<dd><p>Returns the range <code class="docutils literal notranslate"><span class="pre">1..this.size</span></code> representing the indices that are
legal for indexing into the tuple.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isHomogeneousTuple(t: tuple) param</code></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a homogeneous tuple; otherwise false.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isTuple(t: tuple) param</code></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a tuple; otherwise false.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isTupleType(type t) param</code></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a tuple of types; otherwise false.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc max(type t) where isTupleType(t)</code></dt>
<dd><p>Returns a tuple of type <code class="docutils literal notranslate"><span class="pre">t</span></code> with each component set to the maximum
value that can be stored in its position.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc min(type t) where isTupleType(t)</code></dt>
<dd><p>Returns a tuple of type <code class="docutils literal notranslate"><span class="pre">t</span></code> with each component set to the minimum
value that can be stored in its position.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="classes.html" class="btn btn-neutral float-right" title="Classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="error-handling.html" class="btn btn-neutral float-left" title="Error Handling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>