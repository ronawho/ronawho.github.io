

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Task Parallelism and Synchronization &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Data Parallelism" href="data-parallelism.html" />
    <link rel="prev" title="Input and Output" href="input-and-output.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "language/spec/task-parallelism-and-synchronization";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Task Parallelism and Synchronization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tasks-and-task-parallelism">Tasks and Task Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-begin-statement">The Begin Statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronization-variables">Synchronization Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#predefined-single-and-sync-methods">Predefined Single and Sync Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-variables">Atomic Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#predefined-atomic-methods">Predefined Atomic Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-cobegin-statement">The Cobegin Statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-coforall-loop">The Coforall Loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#task-intents">Task Intents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-sync-statement">The Sync Statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-serial-statement">The Serial Statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-statements">Atomic Statements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Task Parallelism and Synchronization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/task-parallelism-and-synchronization.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="task-parallelism-and-synchronization">
<span id="chapter-task-parallelism-and-synchronization"></span><h1>Task Parallelism and Synchronization<a class="headerlink" href="#task-parallelism-and-synchronization" title="Permalink to this headline">¶</a></h1>
<p>Chapel supports both task parallelism and data parallelism. This chapter
details task parallelism as follows:</p>
<ul class="simple">
<li><a class="reference internal" href="#task-parallelism"><span class="std std-ref">Tasks and Task Parallelism</span></a> introduces tasks and task
parallelism.</li>
<li><a class="reference internal" href="#begin"><span class="std std-ref">The Begin Statement</span></a> describes the begin statement, an unstructured
way to introduce concurrency into a program.</li>
<li><a class="reference internal" href="#synchronization-variables"><span class="std std-ref">Synchronization Variables</span></a> describes synchronization
variables, an unstructured mechanism for synchronizing tasks.</li>
<li><a class="reference internal" href="#atomic-variables"><span class="std std-ref">Atomic Variables</span></a> describes atomic variables, a
mechanism for supporting atomic operations.</li>
<li><a class="reference internal" href="#cobegin"><span class="std std-ref">The Cobegin Statement</span></a> describes the cobegin statement, a structured
way to introduce concurrency into a program.</li>
<li><a class="reference internal" href="#coforall"><span class="std std-ref">The Coforall Loop</span></a> describes the coforall loop, another
structured way to introduce concurrency into a program.</li>
<li><a class="reference internal" href="#task-intents"><span class="std std-ref">Task Intents</span></a> specifies how variables from outer scopes
are handled within <code class="docutils literal notranslate"><span class="pre">begin</span></code>, <code class="docutils literal notranslate"><span class="pre">cobegin</span></code> and <code class="docutils literal notranslate"><span class="pre">coforall</span></code>
statements.</li>
<li><a class="reference internal" href="#sync-statement"><span class="std std-ref">The Sync Statement</span></a> describes the sync statement, a
structured way to control parallelism.</li>
<li><a class="reference internal" href="#serial"><span class="std std-ref">The Serial Statement</span></a> describes the serial statement, a structured
way to suppress parallelism.</li>
<li><a class="reference internal" href="#atomic-statement"><span class="std std-ref">Atomic Statements</span></a> describes the atomic statement, a
construct to support atomic transactions.</li>
</ul>
<div class="section" id="tasks-and-task-parallelism">
<span id="task-parallelism"></span><h2>Tasks and Task Parallelism<a class="headerlink" href="#tasks-and-task-parallelism" title="Permalink to this headline">¶</a></h2>
<p>A Chapel <em>task</em> is a distinct context of execution that may be running
concurrently with other tasks. Chapel provides a simple construct, the
<code class="docutils literal notranslate"><span class="pre">begin</span></code> statement, to create tasks, introducing concurrency into a
program in an unstructured way. In addition, Chapel introduces two type
qualifiers, <code class="docutils literal notranslate"><span class="pre">sync</span></code> and <code class="docutils literal notranslate"><span class="pre">single</span></code>, for synchronization between tasks.</p>
<p>Chapel provides two constructs, the <code class="docutils literal notranslate"><span class="pre">cobegin</span></code> and <code class="docutils literal notranslate"><span class="pre">coforall</span></code>
statements, to introduce concurrency in a more structured way. These
constructs create multiple tasks but do not continue until these tasks
have completed. In addition, Chapel provides two constructs, the
<code class="docutils literal notranslate"><span class="pre">sync</span></code> and <code class="docutils literal notranslate"><span class="pre">serial</span></code> statements, to insert synchronization and
suppress parallelism. All four of these constructs can be implemented
through judicious uses of the unstructured task-parallel constructs
described in the previous paragraph.</p>
<p>Tasks are considered to be created when execution reaches the start of a
<code class="docutils literal notranslate"><span class="pre">begin</span></code>, <code class="docutils literal notranslate"><span class="pre">cobegin</span></code>, or <code class="docutils literal notranslate"><span class="pre">coforall</span></code> statement. When the tasks are
actually executed depends on the Chapel implementation and run-time
execution state.</p>
<p>A task is represented as a call to a <em>task function</em>, whose body
contains the Chapel code for the task. Variables defined in outer scopes
are considered to be passed into a task function by default intent,
unless a different <em>task intent</em> is specified explicitly by a
<code class="docutils literal notranslate"><span class="pre">task-intent-clause</span></code>.</p>
<p>Accesses to the same variable from different tasks are subject to the
Memory Consistency Model
(<a class="reference internal" href="memory-consistency-model.html#chapter-memory-consistency-model"><span class="std std-ref">Memory Consistency Model</span></a>). Such
accesses can result from aliasing due to <code class="docutils literal notranslate"><span class="pre">ref</span></code> argument intents or
task intents, among others.</p>
</div>
<div class="section" id="the-begin-statement">
<span id="begin"></span><h2>The Begin Statement<a class="headerlink" href="#the-begin-statement" title="Permalink to this headline">¶</a></h2>
<p>The begin statement creates a task to execute a statement. The syntax
for the begin statement is given by</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>begin-statement:
  `begin&#39; task-intent-clause[OPT] statement
</pre></div>
</div>
<p>Control continues concurrently with the statement following the begin
statement.</p>
<blockquote>
<div><p><em>Example (beginUnordered.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;output from spawned task&quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;output from main task&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>executes two <code class="docutils literal notranslate"><span class="pre">writeln</span></code> statements that output the strings to the
terminal, but the ordering is purposely unspecified. There is no
guarantee as to which statement will execute first. When the begin
statement is executed, a new task is created that will execute the
<code class="docutils literal notranslate"><span class="pre">writeln</span></code> statement within it. However, execution will continue
immediately after task creation with the next statement.</p>
</div></blockquote>
<p>A begin statement creates a single task function, whose body is the body
of the begin statement. The handling of the outer variables within the
task function and the role of <code class="docutils literal notranslate"><span class="pre">task-intent-clause</span></code> are defined in
<a class="reference internal" href="#task-intents"><span class="std std-ref">Task Intents</span></a>.</p>
<p>Yield and return statements are not allowed in begin blocks. Break and
continue statements may not be used to exit a begin block.</p>
</div>
<div class="section" id="synchronization-variables">
<span id="id1"></span><h2>Synchronization Variables<a class="headerlink" href="#synchronization-variables" title="Permalink to this headline">¶</a></h2>
<p>Synchronization variables have a logical state associated with the
value. The state of the variable is either <em>full</em> or <em>empty</em>. Normal
reads of a synchronization variable cannot proceed until the variable’s
state is full. Normal writes of a synchronization variable cannot
proceed until the variable’s state is empty.</p>
<p>Chapel supports two types of synchronization variables: sync and single.
Both types behave similarly, except that a single variable may only be
written once. Consequently, when a sync variable is read, its state
transitions to empty, whereas when a single variable is read, its state
does not change. When either type of synchronization variable is
written, its state transitions to full.</p>
<p><code class="docutils literal notranslate"><span class="pre">sync</span></code> and <code class="docutils literal notranslate"><span class="pre">single</span></code> are type qualifiers and precede the type of the
variable’s value in the declaration. Sync and single are supported for
all Chapel primitive types (&nbsp;<a class="reference internal" href="types.html#primitive-types"><span class="std std-ref">Primitive Types</span></a>) except
complex. They are also supported for enumerated types
(&nbsp;<a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>) and variables of class type
(&nbsp;<a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>). For sync variables of class type, the
full/empty state applies to the reference to the class object, not to
its member fields.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>It is only well-formed to apply full-empty semantics to types that
have no more than a single logical value. Booleans, integers, real
and imaginary numbers, enums, and class references all meet this
criteria. Since it is possible to read/write the individual elements
of a complex value, it’s not obvious how the full-empty semantics
would interact with such operations. While one could argue that
record types with a single field could also be included, the user can
more directly express such cases by declaring the field itself to be
of sync type.</p>
</div></blockquote>
<p>If a task attempts to read or write a synchronization variable that is
not in the correct state, the task is suspended. When the variable
transitions to the correct state, the task is resumed. If there are
multiple tasks blocked waiting for the state transition, one is
non-deterministically selected to proceed and the others continue to
wait if it is a sync variable; all tasks are selected to proceed if it
is a single variable.</p>
<p>A synchronization variable is specified with a sync or single type given
by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>sync-type:
  `sync&#39; type-expression

single-type:
  `single&#39; type-expression
</pre></div>
</div>
<p>A default-initialized synchronization variable will be empty. A
synchronization variable initialized from another expression will be
full and store the value from that expression.</p>
<blockquote>
<div><p><em>Example (beginWithSyncVar.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">isLeaf</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">Tree</span><span class="p">?;</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">sum</span><span class="p">():</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isLeaf</span><span class="p">)</span> <span class="k">then</span>
       <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">x$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span><span class="p">;</span>
    <span class="k">begin</span> <span class="nx">x$</span> <span class="o">=</span> <span class="nx">left</span><span class="o">!</span><span class="p">.</span><span class="nx">sum</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">right</span><span class="o">!</span><span class="p">.</span><span class="nx">sum</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">x$</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>the sync variable <code class="docutils literal notranslate"><span class="pre">x$</span></code> is assigned by an
asynchronous task created with the begin statement. The task
returning the sum waits on the reading of <code class="docutils literal notranslate"><span class="pre">x$</span></code>
until it has been assigned. By convention, synchronization variables
end in <code class="docutils literal notranslate"><span class="pre">$</span></code> to provide a visual cue to the programmer indicating
that the task may block.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (syncCounter.chpl)</em>.</p>
<p>Sync variables are useful for tallying data from multiple tasks as
well. If all updates to an initialized sync variable are via compound
assignment operators (or equivalently, traditional assignments that
read and write the variable once), the full/empty state of the sync
variable guarantees that the reads and writes will be interleaved in
a manner that makes the updates atomic. For example, the code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">count$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">cobegin</span> <span class="p">{</span>
  <span class="nx">count$</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">count$</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">count$</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>creates three tasks that increment <code class="docutils literal notranslate"><span class="pre">count$</span></code>. If
<code class="docutils literal notranslate"><span class="pre">count$</span></code> were not a sync variable, this code
would be unsafe because two tasks could then read the same value
before either had written its updated value, causing one of the
increments to be lost.</p>
<p><em>Example (singleVar.chpl)</em>.</p>
<p>The following code implements a simple split-phase barrier using a
single variable.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">count$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>  <span class="c1">// counter which also serves as a lock</span>
<span class="kd">var</span> <span class="nx">release$</span><span class="p">:</span> <span class="k">single</span> <span class="kt">bool</span><span class="p">;</span> <span class="c1">// barrier release</span>

<span class="k">forall</span> <span class="nx">t</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="k">begin</span> <span class="p">{</span>
  <span class="nx">work</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">myc</span> <span class="o">=</span> <span class="nx">count$</span><span class="p">;</span>  <span class="c1">// read the count, set state to empty</span>
  <span class="k">if</span> <span class="nx">myc</span><span class="o">!=</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">write</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">);</span>
    <span class="nx">count$</span> <span class="o">=</span> <span class="nx">myc</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// update the count, set state to full</span>
    <span class="c1">// we could also do some work here before blocking</span>
    <span class="nx">release$</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">release$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>  <span class="c1">// last one here, release everyone</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In each iteration of the forall loop after the work is completed, the
task reads the <code class="docutils literal notranslate"><span class="pre">count$</span></code> variable, which is used
to tally the number of tasks that have arrived. All tasks except the
last task to arrive will block while trying to read the variable
<code class="docutils literal notranslate"><span class="pre">release$</span></code>. The last task to arrive will write
to <code class="docutils literal notranslate"><span class="pre">release$</span></code>, setting its state to full at
which time all the other tasks can be unblocked and run.</p>
</div></blockquote>
<p>If a formal argument with a default intent either has a synchronization
type or the formal is generic
(<a class="reference internal" href="generics.html#formal-arguments-of-generic-type"><span class="std std-ref">Formal Arguments of Generic Type</span></a>) and the actual has a
synchronization type, the actual must be an lvalue and is passed by
reference. In these cases the formal itself is an lvalue, too. The
actual argument is not read or written during argument passing; its
state is not changed or waited on. The qualifier <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">single</span></code>
without the value type can be used to specify a generic formal argument
that requires a <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">single</span></code> actual.</p>
<p>When the actual argument is a <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">single</span></code> and the
corresponding formal has the actual’s base type or is implicitly
converted from that type, a normal read of the actual is performed when
the call is made, and the read value is passed to the formal.</p>
<div class="section" id="predefined-single-and-sync-methods">
<span id="functions-on-synchronization-variables"></span><h3>Predefined Single and Sync Methods<a class="headerlink" href="#predefined-single-and-sync-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are defined for variables of sync and single type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">readFE</span><span class="p">():</span> <span class="n">t</span>
</pre></div>
</div>
<p>Returns the value of the sync variable. This method blocks until the
sync variable is full. The state of the sync variable is set to empty
when this method completes. This method implements the normal read of a
<code class="docutils literal notranslate"><span class="pre">sync</span></code> variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">readFF</span><span class="p">():</span> <span class="n">t</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">single</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">readFF</span><span class="p">():</span> <span class="n">t</span>
</pre></div>
</div>
<p>Returns the value of the sync or single variable. This method blocks
until the sync or single variable is full. The state of the sync or
single variable remains full when this method completes. This method
implements the normal read of a <code class="docutils literal notranslate"><span class="pre">single</span></code> variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">readXX</span><span class="p">():</span> <span class="n">t</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">single</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">readXX</span><span class="p">():</span> <span class="n">t</span>
</pre></div>
</div>
<p>Returns the value of the sync or single variable. This method is
non-blocking and the state of the sync or single variable is unchanged
when this method completes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">writeEF</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">single</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">writeEF</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Assigns <code class="docutils literal notranslate"><span class="pre">v</span></code> to the value of the sync or single variable. This method
blocks until the sync or single variable is empty. The state of the sync
or single variable is set to full when this method completes. This
method implements the normal write of a <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">single</span></code> variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">writeFF</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Assigns <code class="docutils literal notranslate"><span class="pre">v</span></code> to the value of the sync variable. This method blocks
until the sync variable is full. The state of the sync variable remains
full when this method completes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">writeXF</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Assigns <code class="docutils literal notranslate"><span class="pre">v</span></code> to the value of the sync variable. This method is
non-blocking and the state of the sync variable is set to full when this
method completes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</pre></div>
</div>
<p>Assigns the default value of type <code class="docutils literal notranslate"><span class="pre">t</span></code> to the value of the sync
variable. This method is non-blocking and the state of the sync variable
is set to empty when this method completes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">sync</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">isFull</span><span class="p">:</span> <span class="nb">bool</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">single</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">isFull</span><span class="p">:</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the sync or single variable is full and <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise. This method is non-blocking and the state of the sync or
single variable is unchanged when this method completes.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">writeEF</span></code> and <code class="docutils literal notranslate"><span class="pre">readFE</span></code>/<code class="docutils literal notranslate"><span class="pre">readFF</span></code> methods (for <code class="docutils literal notranslate"><span class="pre">sync</span></code>
and <code class="docutils literal notranslate"><span class="pre">single</span></code> variables, respectively) are implicitly invoked for
normal writes and reads of synchronization variables.</p>
<blockquote>
<div><p><em>Example (syncMethods.chpl)</em>.</p>
<p>Given the following declarations</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y$</span><span class="p">:</span> <span class="k">single</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">x$</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">y$</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="nx">z</span> <span class="o">=</span> <span class="nx">x$</span> <span class="o">+</span> <span class="nx">y$</span><span class="p">;</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">x$</span><span class="p">.</span><span class="nx">writeEF</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">y$</span><span class="p">.</span><span class="nx">writeEF</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="nx">z</span> <span class="o">=</span> <span class="nx">x$</span><span class="p">.</span><span class="nx">readFE</span><span class="p">()</span> <span class="o">+</span> <span class="nx">y$</span><span class="p">.</span><span class="nx">readFF</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="atomic-variables">
<span id="id2"></span><h2>Atomic Variables<a class="headerlink" href="#atomic-variables" title="Permalink to this headline">¶</a></h2>
<p>Atomic variables are variables that support atomic operations. Chapel
currently supports atomic operations for bools, all supported sizes of
signed and unsigned integers, as well as all supported sizes of reals.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The choice of supported atomic variable types as well as the atomic
operations was strongly influenced by the C11 standard.</p>
</div></blockquote>
<p>Atomic is a type qualifier that precedes the variable’s type in the
declaration. Atomic operations are supported for bools, and all sizes of
ints, uints, and reals.</p>
<p>An atomic variable is specified with an atomic type given by the
following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>atomic-type:
  `atomic&#39; type-expression
</pre></div>
</div>
<div class="section" id="predefined-atomic-methods">
<span id="functions-on-atomic-variables"></span><h3>Predefined Atomic Methods<a class="headerlink" href="#predefined-atomic-methods" title="Permalink to this headline">¶</a></h3>
<p>The following methods are defined for variables of atomic type. Note
that not all operations are supported for all atomic types. The
supported types are listed for each method.</p>
<p>Most of the predefined atomic methods accept an optional argument named
<code class="docutils literal notranslate"><span class="pre">order</span></code> of type memoryOrder. The <code class="docutils literal notranslate"><span class="pre">order</span></code> argument is used to specify
the ordering constraints of atomic operations. The supported memoryOrder
values are:</p>
<ul class="simple">
<li>memoryOrder.relaxed</li>
<li>memoryOrder.acquire</li>
<li>memoryOrder.release</li>
<li>memoryOrder.acqRel</li>
<li>memoryOrder.seqCst</li>
</ul>
<p>Unless specified, the default for the memoryOrder parameter is
memoryOrder.seqCst.</p>
<blockquote>
<div><p><em>Implementors’ note</em>.</p>
<p>Not all architectures or implementations may support all memoryOrder
values. In these cases, the implementation should default to a more
conservative ordering than specified.</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
</pre></div>
</div>
<p>Reads and returns the stored value. Defined for all atomic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">v</span></code> as the new value. Defined for all atomic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">v</span></code> as the new value and returns the original value. Defined
for all atomic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">compareExchange</span><span class="p">(</span><span class="n">ref</span> <span class="n">e</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="nb">bool</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">compareExchange</span><span class="p">(</span><span class="n">ref</span> <span class="n">e</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">failure</span><span class="p">:</span><span class="n">memoryOrder</span><span class="p">,</span> <span class="n">param</span> <span class="n">success</span><span class="p">:</span><span class="n">memoryOrder</span><span class="p">):</span> <span class="nb">bool</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">compareExchangeWeak</span><span class="p">(</span><span class="n">ref</span> <span class="n">e</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="nb">bool</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">compareExchangeWeak</span><span class="p">(</span><span class="n">ref</span> <span class="n">e</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">failure</span><span class="p">:</span><span class="n">memoryOrder</span><span class="p">,</span> <span class="n">param</span> <span class="n">success</span><span class="p">:</span><span class="n">memoryOrder</span><span class="p">):</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">v</span></code> as the new value, if and only if the original value is
equal to <code class="docutils literal notranslate"><span class="pre">e</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">v</span></code> was stored, otherwise
returns <code class="docutils literal notranslate"><span class="pre">false</span></code> and updates <code class="docutils literal notranslate"><span class="pre">e</span></code> to the old value.  The weak
version is allowed to spuriously fail, but when using
<code class="docutils literal notranslate"><span class="pre">compareExchange</span></code> in a loop anyways, it can can offer better
performance on some platforms. Defined for all atomic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">compareAndSwap</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">v</span></code> as the new value, if and only if the original value is
equal to <code class="docutils literal notranslate"><span class="pre">e</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">v</span></code> was stored, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise. Defined for all atomic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="ow">or</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="ow">and</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
</pre></div>
</div>
<p>Applies the appropriate operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>) to
the original value and <code class="docutils literal notranslate"><span class="pre">v</span></code> and stores the result. All of the methods
are defined for integral atomic types. Only add and sub (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>)
are defined for <code class="docutils literal notranslate"><span class="pre">real</span></code> atomic types. None of the methods are defined
for the <code class="docutils literal notranslate"><span class="pre">bool</span></code> atomic type.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>Future</em>.</p>
<p class="last">In the future we may overload certain operations such as <code class="docutils literal notranslate"><span class="pre">+=</span></code> to call
the above methods automatically for atomic variables.</p>
</div>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">fetchAdd</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">fetchSub</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">fetchOr</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">fetchAnd</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
<span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">fetchXor</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="n">T</span>
</pre></div>
</div>
<p>Applies the appropriate operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>) to
the original value and <code class="docutils literal notranslate"><span class="pre">v</span></code>, stores the result, and returns the original
value. All of the methods are defined for integral atomic types. Only add
and sub (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>) are defined for <code class="docutils literal notranslate"><span class="pre">real</span></code> atomic types. None of the
methods are defined for the <code class="docutils literal notranslate"><span class="pre">bool</span></code> atomic type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">testAndSet</span><span class="p">(</span><span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">):</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">true</span></code> as the new value and returns the old value. Equivalent
to <code class="docutils literal notranslate"><span class="pre">exchange(true)</span></code>. Only defined for the <code class="docutils literal notranslate"><span class="pre">bool</span></code> atomic type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">param</span> <span class="n">order</span><span class="p">:</span><span class="n">memoryOrder</span> <span class="o">=</span> <span class="n">memoryOrder</span><span class="o">.</span><span class="n">seqCst</span><span class="p">)</span>
</pre></div>
</div>
<p>Stores <code class="docutils literal notranslate"><span class="pre">false</span></code> as the new value. Equivalent to <code class="docutils literal notranslate"><span class="pre">write(false)</span></code>. Only
defined for the <code class="docutils literal notranslate"><span class="pre">bool</span></code> atomic type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proc</span> <span class="p">(</span><span class="n">atomic</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">waitFor</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>Waits until the stored value is equal to <code class="docutils literal notranslate"><span class="pre">v</span></code>. The implementation may
yield the running task while waiting. Defined for all atomic types.</p>
</div>
</div>
<div class="section" id="the-cobegin-statement">
<span id="cobegin"></span><h2>The Cobegin Statement<a class="headerlink" href="#the-cobegin-statement" title="Permalink to this headline">¶</a></h2>
<p>The cobegin statement is used to introduce concurrency within a block.
The <code class="docutils literal notranslate"><span class="pre">cobegin</span></code> statement syntax is</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>cobegin-statement:
  `cobegin&#39; task-intent-clause[OPT] block-statement
</pre></div>
</div>
<p>A new task and a corresponding task function are created for each
statement in the <code class="docutils literal notranslate"><span class="pre">block-statement</span></code>. Control continues when all of the
tasks have finished. The handling of the outer variables within each
task function and the role of <code class="docutils literal notranslate"><span class="pre">task-intent-clause</span></code> are defined in
<a class="reference internal" href="#task-intents"><span class="std std-ref">Task Intents</span></a>.</p>
<p>Return statements are not allowed in cobegin blocks. Yield statement may
only be lexically enclosed in cobegin blocks in parallel
iterators&nbsp;(<a class="reference internal" href="iterators.html#parallel-iterators"><span class="std std-ref">Parallel Iterators</span></a>). Break and continue
statements may not be used to exit a cobegin block.</p>
<blockquote>
<div><p><em>Example (cobeginAndEquivalent.chpl)</em>.</p>
<p>The cobegin statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">cobegin</span> <span class="p">{</span>
  <span class="nx">stmt1</span><span class="p">();</span>
  <span class="nx">stmt2</span><span class="p">();</span>
  <span class="nx">stmt3</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to the following code that uses only begin statements
and single variables to introduce concurrency and synchronize:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s1$</span><span class="p">,</span> <span class="nx">s2$</span><span class="p">,</span> <span class="nx">s3$</span><span class="p">:</span> <span class="k">single</span> <span class="kt">bool</span><span class="p">;</span>
<span class="k">begin</span> <span class="p">{</span> <span class="nx">stmt1</span><span class="p">();</span> <span class="nx">s1$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
<span class="k">begin</span> <span class="p">{</span> <span class="nx">stmt2</span><span class="p">();</span> <span class="nx">s2$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
<span class="k">begin</span> <span class="p">{</span> <span class="nx">stmt3</span><span class="p">();</span> <span class="nx">s3$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
<span class="nx">s1$</span><span class="p">;</span> <span class="nx">s2$</span><span class="p">;</span> <span class="nx">s3$</span><span class="p">;</span>
</pre></div>
</div>
<p>Each begin statement is executed concurrently but control does not
continue past the final line above until each of the single variables
is written, thereby ensuring that each of the functions has finished.</p>
</div></blockquote>
</div>
<div class="section" id="the-coforall-loop">
<span id="coforall"></span><h2>The Coforall Loop<a class="headerlink" href="#the-coforall-loop" title="Permalink to this headline">¶</a></h2>
<p>The coforall loop is a variant of the cobegin statement in loop form.
The syntax for the coforall loop is given by</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>coforall-statement:
  `coforall&#39; index-var-declaration `in&#39; iteratable-expression task-intent-clause[OPT] `do&#39; statement
  `coforall&#39; index-var-declaration `in&#39; iteratable-expression task-intent-clause[OPT] block-statement
  `coforall&#39; iteratable-expression task-intent-clause[OPT] `do&#39; statement
  `coforall&#39; iteratable-expression task-intent-clause[OPT] block-statement
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">coforall</span></code> loop creates a separate task for each iteration of the
loop. Control continues with the statement following the <code class="docutils literal notranslate"><span class="pre">coforall</span></code>
loop after all tasks corresponding to the iterations of the loop have
completed.</p>
<p>The single task function created for a <code class="docutils literal notranslate"><span class="pre">coforall</span></code> and invoked by each
task contains the loop body. The handling of the outer variables within
the task function and the role of <code class="docutils literal notranslate"><span class="pre">task-intent-clause</span></code> are defined in
<a class="reference internal" href="#task-intents"><span class="std std-ref">Task Intents</span></a>.</p>
<p>Return statements are not allowed in coforall blocks. Yield statement
may only be lexically enclosed in coforall blocks in parallel
iterators&nbsp;(<a class="reference internal" href="iterators.html#parallel-iterators"><span class="std std-ref">Parallel Iterators</span></a>). Break and continue
statements may not be used to exit a coforall block.</p>
<blockquote>
<div><p><em>Example (coforallAndEquivalent.chpl)</em>.</p>
<p>The coforall statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">coforall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">iterator</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">body</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to the following code that uses only begin statements
and sync and single variables to introduce concurrency and
synchronize:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">runningCount$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">finished$</span><span class="p">:</span> <span class="k">single</span> <span class="kt">bool</span><span class="p">;</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">iterator</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">runningCount$</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">begin</span> <span class="p">{</span>
    <span class="nx">body</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">runningCount$</span><span class="p">;</span>
    <span class="nx">runningCount$</span> <span class="o">=</span> <span class="nx">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="nx">tmp</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="nx">finished$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">runningCount$</span><span class="p">;</span>
<span class="nx">runningCount$</span> <span class="o">=</span> <span class="nx">tmp</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="nx">tmp</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="nx">finished$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">finished$</span><span class="p">;</span>
</pre></div>
</div>
<p>Each call to <code class="docutils literal notranslate"><span class="pre">body()</span></code> executes concurrently because it is in a
begin statement. The sync variable
<code class="docutils literal notranslate"><span class="pre">runningCount$</span></code> is used to keep track of the
number of executing tasks plus one for the main task. When this
variable reaches zero, the single variable
<code class="docutils literal notranslate"><span class="pre">finished$</span></code> is used to signal that all of the
tasks have completed. Thus control does not continue past the last
line until all of the tasks have completed.</p>
</div></blockquote>
</div>
<div class="section" id="task-intents">
<span id="id3"></span><h2>Task Intents<a class="headerlink" href="#task-intents" title="Permalink to this headline">¶</a></h2>
<p>If a variable is referenced within the lexical scope of a <code class="docutils literal notranslate"><span class="pre">begin</span></code>,
<code class="docutils literal notranslate"><span class="pre">cobegin</span></code>, or <code class="docutils literal notranslate"><span class="pre">coforall</span></code> statement and is declared outside that
statement, it is subject to <em>task intents</em>. That is, it is considered to
be passed as an actual argument to the corresponding task function at
task creation time. All references to the variable within the task
function implicitly refer to a <em>shadow variable</em>, i.e. the task
function’s corresponding formal argument.</p>
<p>When the task construct is inside a method on a record and accesses a
field of <code class="docutils literal notranslate"><span class="pre">this</span></code>, the field is treated as a regular variable. That is,
it is passed as an actual argument to the task function and all
references to the field within the task function implicitly refer to the
corresponding shadow variable.</p>
<p>Each formal argument of a task function has the default argument intent
by default. For variables of primitive and class types, this has the
effect of capturing the value of the variable at task creation time and
referencing that value instead of the original variable within the
lexical scope of the task construct.</p>
<p>A formal can be given another argument intent explicitly by listing it
with that intent in the optional <code class="docutils literal notranslate"><span class="pre">task-intent-clause</span></code>. For example,
for variables of most types, the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent allows the task
construct to modify the corresponding original variable or to read its
updated value after concurrent modifications.</p>
<p>The syntax of the task intent clause is:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>task-intent-clause:
  `with&#39; ( task-intent-list )

task-intent-list:
  task-intent-item
  task-intent-item, task-intent-list

task-intent-item:
  formal-intent identifier
  task-private-var-decl
</pre></div>
</div>
<div class="line-block">
<div class="line">where the following intents can be used as a <code class="docutils literal notranslate"><span class="pre">formal-intent</span></code>:
<code class="docutils literal notranslate"><span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>.
<code class="docutils literal notranslate"><span class="pre">task-private-var-decl</span></code> is defined in
<a class="reference internal" href="data-parallelism.html#task-private-variables"><span class="std std-ref">Task-Private Variables</span></a>. In addition,
<code class="docutils literal notranslate"><span class="pre">task-intent-item</span></code> may define a <code class="docutils literal notranslate"><span class="pre">reduce</span></code> intent. Reduce intents
are described in the <em>Reduce Intents</em> technical note in the online
documentation:</div>
<div class="line"><a class="reference external" href="https://chapel-lang.org/docs/technotes/reduceIntents.html">https://chapel-lang.org/docs/technotes/reduceIntents.html</a></div>
</div>
<p>The implicit treatment of outer scope variables as the task function’s
formal arguments applies to both module level and local variables. It
applies to variable references within the lexical scope of a task
construct, but does not extend to its dynamic scope, i.e., to the
functions called from the task(s) but declared outside of the lexical
scope. The loop index variables of a <code class="docutils literal notranslate"><span class="pre">coforall</span></code> statement are not
subject to such treatment within that statement; however, they are
subject to such treatment within nested task constructs, if any.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The primary motivation for task intents is to avoid some races on
scalar/record variables, which are possible when one task modifies a
variable and another task reads it. Without task intents, for
example, it would be easy to introduce and overlook a bug illustrated
by this simplified example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="k">begin</span> <span class="p">{</span>
      <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If all the tasks created by the <code class="docutils literal notranslate"><span class="pre">begin</span></code> statement start executing
only after the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop completes, and <code class="docutils literal notranslate"><span class="pre">i</span></code> within the
<code class="docutils literal notranslate"><span class="pre">begin</span></code> is treated as a reference to the original <code class="docutils literal notranslate"><span class="pre">i</span></code>, there will
be ten tasks executing <code class="docutils literal notranslate"><span class="pre">f(10)</span></code>. However, the user most likely
intended to generate ten tasks executing <code class="docutils literal notranslate"><span class="pre">f(0)</span></code>, <code class="docutils literal notranslate"><span class="pre">f(1)</span></code>, …,
<code class="docutils literal notranslate"><span class="pre">f(9)</span></code>. Task intents ensure that, regardless of the timing of task
execution.</p>
<p>Another motivation for task intents is that referring to a captured
copy in a task is often more efficient than referring to the original
variable. That’s because the copy is a local constant, e.g. it could
be placed in a register when it fits. Without task intents,
references to the original variable would need to be implemented
using a pointer dereference. This is less efficient and can hinder
optimizations in the surrounding code, for example loop-invariant
code motion.</p>
<p>Furthermore, in the above example the scope where <code class="docutils literal notranslate"><span class="pre">i</span></code> is declared
may exit before all the ten tasks complete. Without task intents, the
user would have to protect <code class="docutils literal notranslate"><span class="pre">i</span></code> to make sure its lexical scope
doesn’t exit before the tasks referencing it complete.</p>
<p>We decided to treat <code class="docutils literal notranslate"><span class="pre">cobegin</span></code> and <code class="docutils literal notranslate"><span class="pre">coforall</span></code> statements the same
way as <code class="docutils literal notranslate"><span class="pre">begin</span></code>. This is for consistency and to make the
race-avoidance benefit available to more code.</p>
<p>We decided to apply task intents to module level variables, in
addition to local variables. Again, this is for consistency. One
could view module level variables differently than local variables
(e.g. a module level variable is “always available”), but we favored
consistency over such an approach.</p>
<p>We decided not to apply task intents to “closure” variables, i.e.,
the variables in the dynamic scope of a task construct. This is to
keep this feature manageable, so that all variables subject to task
intents can be obtained by examining just the lexical scope of the
task construct. In general, the set of closure variables can be hard
to determine, unwieldy to implement and reason about, it is unclear
what to do with extern functions, etc.</p>
<p>We do not provide <code class="docutils literal notranslate"><span class="pre">inout</span></code> or <code class="docutils literal notranslate"><span class="pre">out</span></code> as task intents because they
will necessarily create a data race in a <code class="docutils literal notranslate"><span class="pre">cobegin</span></code> or <code class="docutils literal notranslate"><span class="pre">coforall</span></code>.
<code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">param</span></code> intents are not available either as they do
not seem useful as task intents.</p>
</div></blockquote>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>Future</em>.</p>
<p class="last">For a given intent, we would also like to provide a blanket clause,
which would apply the intent to all variables. An example of syntax
for a blanket <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent would be <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">*</span></code>.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="the-sync-statement">
<span id="sync-statement"></span><h2>The Sync Statement<a class="headerlink" href="#the-sync-statement" title="Permalink to this headline">¶</a></h2>
<p>The sync statement acts as a join of all dynamically encountered begins
from within a statement. The syntax for the sync statement is given by</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>sync-statement:
  `sync&#39; statement
  `sync&#39; block-statement
</pre></div>
</div>
<p>Return statements are not allowed in sync statement blocks. Yield
statement may only be lexically enclosed in sync statement blocks in
parallel iterators&nbsp;(<a class="reference internal" href="iterators.html#parallel-iterators"><span class="std std-ref">Parallel Iterators</span></a>). Break and
continue statements may not be used to exit a sync statement block.</p>
<blockquote>
<div><p><em>Example (syncStmt1.chpl)</em>.</p>
<p>The sync statement can be used to wait for many dynamically created
tasks.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">sync</span> <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="k">begin</span> <span class="nx">work</span><span class="p">();</span>
</pre></div>
</div>
<p>The for loop is within a sync statement and thus the tasks created in
each iteration of the loop must complete before the continuing past
the sync statement.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (syncStmt2.chpl)</em>.</p>
<p>The sync statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">sync</span> <span class="p">{</span>
  <span class="k">begin</span> <span class="nx">stmt1</span><span class="p">();</span>
  <span class="k">begin</span> <span class="nx">stmt2</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is similar to the following cobegin statement</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">cobegin</span> <span class="p">{</span>
  <span class="nx">stmt1</span><span class="p">();</span>
  <span class="nx">stmt2</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>except that if begin statements are dynamically encountered when
<code class="docutils literal notranslate"><span class="pre">stmt1()</span></code> or <code class="docutils literal notranslate"><span class="pre">stmt2()</span></code> are executed, then the former code will
wait for these begin statements to complete whereas the latter code
will not.</p>
</div></blockquote>
</div>
<div class="section" id="the-serial-statement">
<span id="serial"></span><h2>The Serial Statement<a class="headerlink" href="#the-serial-statement" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">serial</span></code> statement can be used to dynamically disable parallelism.
The syntax is:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>serial-statement:
  `serial&#39; expression[OPT] `do&#39; statement
  `serial&#39; expression[OPT] block-statement
</pre></div>
</div>
<p>where the optional <code class="docutils literal notranslate"><span class="pre">expression</span></code> evaluates to a boolean value. If the
expression is omitted, it is as though ’true’ were specified. Whatever
the expression’s value, the statement following it is evaluated. If the
expression is true, any dynamically encountered code that would normally
create new tasks within the statement is instead executed by the
original task without creating any new ones. In effect, execution is
serialized. If the expression is false, code within the statement will
generates task according to normal Chapel rules.</p>
<blockquote>
<div><p><em>Example (serialStmt1.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">serial</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">13</span> <span class="p">{</span>
    <span class="k">cobegin</span> <span class="p">{</span>
      <span class="nx">work</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="nx">work</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">lo</span><span class="o">..</span><span class="nx">hi</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>the serial statement in procedure f() inhibits concurrent execution
of work() if the variable i is less than 13.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (serialStmt2.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">serial</span> <span class="p">{</span>
  <span class="k">begin</span> <span class="nx">stmt1</span><span class="p">();</span>
  <span class="k">cobegin</span> <span class="p">{</span>
    <span class="nx">stmt2</span><span class="p">();</span>
    <span class="nx">stmt3</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">coforall</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="nx">stmt4</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">stmt1</span><span class="p">();</span>
<span class="p">{</span>
  <span class="nx">stmt2</span><span class="p">();</span>
  <span class="nx">stmt3</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span> <span class="nx">stmt4</span><span class="p">();</span>
</pre></div>
</div>
<p>because the expression evaluated to determine whether to serialize
always evaluates to true.</p>
</div></blockquote>
</div>
<div class="section" id="atomic-statements">
<span id="atomic-statement"></span><h2>Atomic Statements<a class="headerlink" href="#atomic-statements" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>This section describes a feature that is a work-in-progress. We seek
feedback and collaboration in this area from the broader community.</p>
</div></blockquote>
<p>The <em>atomic statement</em> is used to specify that a statement should appear
to execute atomically from other tasks’ point of view. In particular, no
task will see memory in a state that would reflect that the atomic
statement had begun executing but had not yet completed.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>This definition of the atomic statement provides a notion of <em>strong
atomicity</em> since the action will appear atomic to any task at any
point in its execution. For performance reasons, it could be more
practical to support <em>weak atomicity</em> in which the statement’s
atomicity is only guaranteed with respect to other atomic statements.
We may also pursue using atomic type qualifiers as a means of marking
data that should be accessed atomically inside or outside an atomic
section.</p>
</div></blockquote>
<p>The syntax for the atomic statement is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>atomic-statement:
  `atomic&#39; statement
</pre></div>
</div>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code illustrates the use of an atomic statement to
perform an insertion into a doubly-linked list:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">Node.insertAfter</span><span class="p">(</span><span class="nx">newNode</span><span class="p">:</span> <span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">atomic</span> <span class="p">{</span>
    <span class="nx">newNode</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">this</span><span class="p">;</span>
    <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">next</span> <span class="k">then</span> <span class="nx">this</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The use of the atomic statement in this routine prevents other tasks
from viewing the list in a partially-updated state in which the
pointers might not be self-consistent.</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="data-parallelism.html" class="btn btn-neutral float-right" title="Data Parallelism" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input-and-output.html" class="btn btn-neutral float-left" title="Input and Output" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>