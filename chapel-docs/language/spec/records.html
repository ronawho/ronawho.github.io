

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Records &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Unions" href="unions.html" />
    <link rel="prev" title="Classes" href="classes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "language/spec/records";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Records</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#record-declarations">Record Declarations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#record-types">Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-fields">Record Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-methods">Record Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nested-record-types">Nested Record Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#record-variable-declarations">Record Variable Declarations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#storage-allocation">Storage Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-initialization">Record Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-deinitializer">Record Deinitializer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#record-arguments">Record Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#record-field-access">Record Field Access</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#field-getter-methods">Field Getter Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#record-method-calls">Record Method Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-operations">Common Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#copy-initialization-of-records">Copy Initialization of Records</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-copy-initialization">Advanced Copy Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-assignment">Record Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-comparison-operators">Default Comparison Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#differences-between-classes-and-records">Differences between Classes and Records</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#declarations">Declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#storage-allocation-differences">Storage Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assignment">Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arguments">Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-nil-value">No <em>nil</em> Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-delete-operator">The <em>delete</em> operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-operator-differences">Default Comparison Operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Records</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/records.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="records">
<span id="chapter-records"></span><h1>Records<a class="headerlink" href="#records" title="Permalink to this headline">¶</a></h1>
<p>A record is a data structure that is similar to a class except it has
value semantics, similar to primitive types. Value semantics mean that
assignment, argument passing and function return values are by default
all done by copying. Value semantics also imply that a variable of
record type is associated with only one piece of storage and has only
one type throughout its lifetime. Storage is allocated for a variable of
record type when the variable declaration is executed, and the record
variable is also initialized at that time. When the record variable goes
out of scope, or at the end of the program if it is declared at module
scope, it is deinitialized and its storage is deallocated.</p>
<p>A record declaration statement creates a record
type&nbsp;<a class="reference internal" href="#record-declarations"><span class="std std-ref">Record Declarations</span></a>. A variable of record type
contains all and only the fields defined by that type
(<a class="reference internal" href="#record-types"><span class="std std-ref">Record Types</span></a>). Value semantics imply that the type of a
record variable is known at compile time (i.e. it is statically typed).</p>
<p>A record can be created using the <code class="docutils literal notranslate"><span class="pre">new</span></code> operator, which allocates
storage, initializes it via a call to a record initializer, and returns
it. A record is also created upon a variable declaration of a record
type.</p>
<p>A record type is generic if it contains generic fields. Generic record
types are discussed in detail in&nbsp;<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<div class="section" id="record-declarations">
<span id="id1"></span><h2>Record Declarations<a class="headerlink" href="#record-declarations" title="Permalink to this headline">¶</a></h2>
<p>A record type is defined with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>record-declaration-statement:
  simple-record-declaration-statement
  external-record-declaration-statement

simple-record-declaration-statement:
  `record&#39; identifier { record-statement-list }

record-statement-list:
  record-statement
  record-statement record-statement-list

record-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">record-declaration-statement</span></code> defines a new type symbol specified
by the identifier. As in a class declaration, the body of a record
declaration can contain variable, method, and type declarations.</p>
<p>If a record declaration contains a type alias or parameter field, or it
contains a variable or constant field without a specified type and
without an initialization expression, then it declares a generic record
type. Generic record types are described
in&nbsp;<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword appears before the <code class="docutils literal notranslate"><span class="pre">record</span></code> keyword, then an
external record type is declared. An external record is used within
Chapel for type and field resolution, but no corresponding backend
definition is generated. It is presumed that the definition of an
external record is supplied by a library or the execution environment.
See the chapter on interoperability
(<a class="reference internal" href="interoperability.html#chapter-interoperability"><span class="std std-ref">Interoperability</span></a>) for more information on
external records.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>Future:</em></p>
<p class="last">Privacy controls for classes and records are currently not specified,
as discussion is needed regarding its impact on inheritance, for
instance.</p>
</div>
</div></blockquote>
<div class="section" id="record-types">
<span id="id2"></span><h3>Record Types<a class="headerlink" href="#record-types" title="Permalink to this headline">¶</a></h3>
<p>A record type specifier simply names a record type, using the following
syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>record-type:
  identifier
  identifier ( named-expression-list )
</pre></div>
</div>
<p>A record type specifier may appear anywhere a type specifier is
permitted.</p>
<p>For non-generic records, the record name by itself is sufficient to
specify the type. Generic records must be instantiated to serve as a
fully-specified type, for example to declare a variable. This is done
with type constructors, which are defined in
Section&nbsp;<a class="reference external" href="#Type_Constructors">24.3.6</a>.</p>
</div>
<div class="section" id="record-fields">
<span id="id3"></span><h3>Record Fields<a class="headerlink" href="#record-fields" title="Permalink to this headline">¶</a></h3>
<p>Variable declarations within a record type declaration define fields
within that record type. The presence of at least one parameter field
causes the record type to become generic. Variable fields define the
storage associated with a record.</p>
<blockquote>
<div><p><em>Example (defineActorRecord.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">ActorRecord</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">age</span><span class="p">:</span> <span class="kt">uint</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines a new record type called <code class="docutils literal notranslate"><span class="pre">ActorRecord</span></code> that has two fields:
the string field <code class="docutils literal notranslate"><span class="pre">name</span></code> and the unsigned integer field <code class="docutils literal notranslate"><span class="pre">age</span></code>. The
data contained by a record of this type is exactly the same as that
contained by an instance of the <code class="docutils literal notranslate"><span class="pre">Actor</span></code> class defined in the
preceding chapter&nbsp;<a class="reference internal" href="classes.html#class-fields"><span class="std std-ref">Class Fields</span></a>.</p>
</div></blockquote>
</div>
<div class="section" id="record-methods">
<span id="id4"></span><h3>Record Methods<a class="headerlink" href="#record-methods" title="Permalink to this headline">¶</a></h3>
<p>A record method is a function or iterator that is bound to a record. See
the methods section&nbsp;<a class="reference internal" href="methods.html#chapter-methods"><span class="std std-ref">Methods</span></a> for more information
about methods.</p>
<p>Note that the receiver of a record method is passed by <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent by default, depending on whether or not <code class="docutils literal notranslate"><span class="pre">this</span></code> is
modified in the body of the method.</p>
</div>
<div class="section" id="nested-record-types">
<span id="id5"></span><h3>Nested Record Types<a class="headerlink" href="#nested-record-types" title="Permalink to this headline">¶</a></h3>
<p>A record defined within another class or record is a nested record. A
nested record can be referenced only within its immediately enclosing
class or record.</p>
</div>
</div>
<div class="section" id="record-variable-declarations">
<span id="id6"></span><h2>Record Variable Declarations<a class="headerlink" href="#record-variable-declarations" title="Permalink to this headline">¶</a></h2>
<p>A record variable declaration is a variable declaration using a record
type. When a variable of record type is declared, storage is allocated
sufficient to store all of the fields defined in that record type.</p>
<p>In the context of a class or record or union declaration, the fields are
allocated within the object as if they had been declared individually.
In this sense, records provide a way to group related fields within a
containing class or record type.</p>
<p>In the context of a function body, a record variable declaration causes
storage to be allocated sufficient to store all of the fields in that
record type. The record variable is initialized with a call to an
initializer (<a class="reference internal" href="classes.html#class-initializers"><span class="std std-ref">Class Initializers</span></a>) that accepts zero actual
arguments.</p>
<div class="section" id="storage-allocation">
<span id="record-storage"></span><h3>Storage Allocation<a class="headerlink" href="#storage-allocation" title="Permalink to this headline">¶</a></h3>
<p>Storage for a record variable directly contains the data associated with
the fields in the record, in the same manner as variables of primitive
types directly contain the primitive values.  Unlike class variables, the
field data of one record variable is not shared with data of another
record variable.</p>
<p>Record storage is reclaimed automatically. See <a class="reference internal" href="variables.html#variable-lifetimes"><span class="std std-ref">Variable Lifetimes</span></a>
for details on when a record becomes dead.</p>
</div>
<div class="section" id="record-initialization">
<span id="id7"></span><h3>Record Initialization<a class="headerlink" href="#record-initialization" title="Permalink to this headline">¶</a></h3>
<p>A variable of a record type declared without an initialization
expression is initialized through a call to the record’s default
initializer, passing no arguments. The default initializer for a record
is defined in the same way as the default initializer for a class
(<a class="reference internal" href="classes.html#the-compiler-generated-initializer"><span class="std std-ref">The Compiler-Generated Initializer</span></a>).</p>
<p>To create a record as an expression, i.e. without binding it to a
variable, the <code class="docutils literal notranslate"><span class="pre">new</span></code> operator is required. In this case, storage is
allocated and reclaimed as for a record variable declaration
(<a class="reference internal" href="#record-storage"><span class="std std-ref">Storage Allocation</span></a>), except that the temporary record goes
out of scope at the end of the enclosing block.</p>
<p>The initializers for a record are defined in the same way as those for a
class (<a class="reference internal" href="classes.html#class-initializers"><span class="std std-ref">Class Initializers</span></a>). Note that records do not
support inheritance and therefore the initializer rules for inheriting
classes (<a class="reference internal" href="classes.html#initializing-inherited"><span class="std std-ref">Initializing Inherited Classes</span></a>) do not apply to record
initializers.</p>
<blockquote>
<div><p><em>Example (recordCreation.chpl)</em>.</p>
<p>The program</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">TimeStamp</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">time</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;1/1/1011&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">timestampDefault</span><span class="p">:</span> <span class="nx">TimeStamp</span><span class="p">;</span>                  <span class="c1">// use the default for &#39;time&#39;</span>
<span class="kd">var</span> <span class="nx">timestampCustom</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TimeStamp</span><span class="p">(</span><span class="s">&quot;2/2/2022&quot;</span><span class="p">);</span>  <span class="c1">// ... or a different one</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">timestampDefault</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">timestampCustom</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">record</span> <span class="nc">UniqueID</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">id</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="nx">idCounter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">firstID</span> <span class="p">:</span> <span class="nx">UniqueID</span><span class="p">;</span> <span class="c1">// invokes zero-argument initializer</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">firstID</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="k">new</span> <span class="nx">UniqueID</span><span class="p">());</span>  <span class="c1">// create and use a record value without a variable</span>
<span class="nx">writeln</span><span class="p">(</span><span class="k">new</span> <span class="nx">UniqueID</span><span class="p">());</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>(time = 1/1/1011)
(time = 2/2/2022)
(id = 1)
(id = 2)
(id = 3)
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">timestampDefault</span></code> is initialized with
<code class="docutils literal notranslate"><span class="pre">TimeStamp</span></code>’s default initializer. The expression
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">TimeStamp</span></code> creates a record that is assigned to
<code class="docutils literal notranslate"><span class="pre">timestampCustom</span></code>. It effectively initializes <code class="docutils literal notranslate"><span class="pre">timestampCustom</span></code>
via a call to the initializer with desired arguments. The records
created with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">UniqueID()</span></code> are discarded after they are used.</p>
</div></blockquote>
<p>As with classes, the user can provide their own initializers
(<a class="reference internal" href="classes.html#user-defined-initializers"><span class="std std-ref">User-Defined Initializers</span></a>). If any user-defined
initializers are supplied, the default initializer cannot be called
directly.</p>
</div>
<div class="section" id="record-deinitializer">
<span id="id8"></span><h3>Record Deinitializer<a class="headerlink" href="#record-deinitializer" title="Permalink to this headline">¶</a></h3>
<p>A record author may specify additional actions to be performed before
record storage is reclaimed by defining a record deinitializer. A record
deinitializer is a method named <code class="docutils literal notranslate"><span class="pre">deinit()</span></code>. A record deinitializer
takes no arguments (aside from the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument). If
defined, the deinitializer is called on a record object after it goes
out of scope and before its memory is reclaimed.</p>
<blockquote>
<div><p><em>Example (recordDeinitializer.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// A class with nonzero size.</span>
<span class="c1">// If the class were empty, whether or not its memory was reclaimed</span>
<span class="c1">// would not be observable.</span>

<span class="c1">// Defines a record implementing simple memory management.</span>
<span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">deinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">:</span> <span class="nx">R</span><span class="p">;</span> <span class="c1">// Initialized using default initializer.</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
  <span class="c1">// r will go out of scope here.</span>
  <span class="c1">// Its deinitializer will be called to free the C object it contains.</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="record-arguments">
<span id="id9"></span><h2>Record Arguments<a class="headerlink" href="#record-arguments" title="Permalink to this headline">¶</a></h2>
<p>Record formal arguments with the <code class="docutils literal notranslate"><span class="pre">in</span></code> intent will be copy-initialized
into the function’s formal argument
(<a class="reference internal" href="#copy-initialization-of-records"><span class="std std-ref">Copy Initialization of Records</span></a>).</p>
<p>Record formal arguments with <code class="docutils literal notranslate"><span class="pre">inout</span></code> or <code class="docutils literal notranslate"><span class="pre">out</span></code> intent will be updated
by the record assignment function (<a class="reference internal" href="#record-assignment"><span class="std std-ref">Record Assignment</span></a>).</p>
<blockquote>
<div><p><em>Example (paramPassing.chpl)</em>.</p>
<p>The program</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyColor</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">color</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">printMyColor</span><span class="p">(</span><span class="kd">in</span> <span class="nx">mc</span><span class="p">:</span> <span class="nx">MyColor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;my color is &quot;</span><span class="p">,</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
  <span class="nx">mc</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>   <span class="c1">// does not affect the caller&#39;s record</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">mc1</span><span class="p">:</span> <span class="nx">MyColor</span><span class="p">;</span>        <span class="c1">// &#39;color&#39; defaults to 0</span>
<span class="kd">var</span> <span class="nx">mc2</span><span class="p">:</span> <span class="nx">MyColor</span> <span class="o">=</span> <span class="nx">mc1</span><span class="p">;</span>  <span class="c1">// mc1&#39;s value is copied into mc2</span>
<span class="nx">mc1</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>           <span class="c1">// mc1&#39;s value is modified</span>
<span class="nx">printMyColor</span><span class="p">(</span><span class="nx">mc2</span><span class="p">);</span>       <span class="c1">// mc2 is not affected by assignment to mc1</span>
<span class="nx">printMyColor</span><span class="p">(</span><span class="nx">mc2</span><span class="p">);</span>       <span class="c1">// ... or by assignment in printMyColor()</span>

<span class="k">proc</span> <span class="nf">modifyMyColor</span><span class="p">(</span><span class="kd">inout</span> <span class="nx">mc</span><span class="p">:</span> <span class="nx">MyColor</span><span class="p">,</span> <span class="nx">newcolor</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mc</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">newcolor</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">modifyMyColor</span><span class="p">(</span><span class="nx">mc2</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>   <span class="c1">// mc2 is affected because of the &#39;inout&#39; intent</span>
<span class="nx">printMyColor</span><span class="p">(</span><span class="nx">mc2</span><span class="p">);</span>
</pre></div>
</div>
<p>produces</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>my color is 0
my color is 0
my color is 7
</pre></div>
</div>
<p>The assignment to <code class="docutils literal notranslate"><span class="pre">mc1.color</span></code> affects only the record stored in
<code class="docutils literal notranslate"><span class="pre">mc1</span></code>. The record in <code class="docutils literal notranslate"><span class="pre">mc2</span></code> is not affected by the assignment to
<code class="docutils literal notranslate"><span class="pre">mc1</span></code> or by the assignment in <code class="docutils literal notranslate"><span class="pre">printMyColor</span></code>. <code class="docutils literal notranslate"><span class="pre">mc2</span></code> is affected
by the assignment in <code class="docutils literal notranslate"><span class="pre">modifyMyColor</span></code> because the intent <code class="docutils literal notranslate"><span class="pre">inout</span></code>
is used.</p>
</div></blockquote>
</div>
<div class="section" id="record-field-access">
<span id="id10"></span><h2>Record Field Access<a class="headerlink" href="#record-field-access" title="Permalink to this headline">¶</a></h2>
<p>A record field is accessed the same way as a class field
(<a class="reference internal" href="classes.html#class-field-accesses"><span class="std std-ref">Field Accesses</span></a>). When a field access is used as an
rvalue, the value of that field is returned. When it is used as an
lvalue, the value of the record field is updated.</p>
<p>Accessing a parameter or type field returns a parameter or type,
respectively. Also, parameter and type fields can be accessed from an
instantiated record type in addition to from a record value.</p>
<div class="section" id="field-getter-methods">
<span id="id11"></span><h3>Field Getter Methods<a class="headerlink" href="#field-getter-methods" title="Permalink to this headline">¶</a></h3>
<p>As in classes, field accesses are performed via getter methods
(<a class="reference internal" href="classes.html#getter-methods"><span class="std std-ref">Variable Getter Methods</span></a>). By default, these methods simply return
a reference to the specified field (so they can be written as well as
read). The user may redefine these as needed.</p>
</div>
</div>
<div class="section" id="record-method-calls">
<span id="record-method-access"></span><h2>Record Method Calls<a class="headerlink" href="#record-method-calls" title="Permalink to this headline">¶</a></h2>
<p>Record method calls are written the same way as other method calls
(<a class="reference internal" href="methods.html#method-calls"><span class="std std-ref">Method Calls</span></a>). Unlike class methods, record methods are
always resolved at compile time.</p>
</div>
<div class="section" id="common-operations">
<span id="common-operations-1"></span><h2>Common Operations<a class="headerlink" href="#common-operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="copy-initialization-of-records">
<span id="id12"></span><h3>Copy Initialization of Records<a class="headerlink" href="#copy-initialization-of-records" title="Permalink to this headline">¶</a></h3>
<p>When a new record variable is created based upon an existing variable,
it is <em>copy initialized</em> or <em>move initialized</em> as described in
<a class="reference internal" href="variables.html#copy-and-move-initialization"><span class="std std-ref">Copy and Move Initialization</span></a>. When a record is <em>copy initialized</em>,
its <code class="docutils literal notranslate"><span class="pre">init=</span></code> initializer will be used to create the new record.</p>
<p>Copy initialization is implemented by a method named <code class="docutils literal notranslate"><span class="pre">init=</span></code>, known as the
<em>copy initializer</em>. A copy initializer may only accept one argument, which
represents the value from which the record will be initialized. These methods
share the same rules as a normal initializer (<a class="reference internal" href="classes.html#class-initializers"><span class="std std-ref">Class Initializers</span></a>), along
with some additional restrictions.</p>
<p>The compiler-generated copy initializer for a non-generic record accepts an
argument of the same type and simply initializes each field from the argument’s
corresponding field:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// identical to compiler-generated implementation</span>
<span class="c1">// proc R.init=(other: R) {</span>
<span class="c1">//   this.x = other.x;</span>
<span class="c1">//   this.y = other.y;</span>
<span class="c1">//   this.z = other.z;</span>
<span class="c1">// }</span>
</pre></div>
</div>
<p>In order to override the compiler-generated implementation, the user must
implement an <code class="docutils literal notranslate"><span class="pre">init=</span></code> method with the same signature.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">R.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="nx">R</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;copied R!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a user implements their own <code class="docutils literal notranslate"><span class="pre">init=</span></code> method, they must also implement an
assignment operator for the same record type. Implementing one without the
other will cause the compiler to issue an error. <em>Rationale</em>: this
requirement exists to mitigate hard-to-debug problems by requiring that type
authors take responsibility for both <code class="docutils literal notranslate"><span class="pre">init=</span></code> and <code class="docutils literal notranslate"><span class="pre">=</span></code> implementations, or
neither implementation.</p>
</div>
<p>A user may indicate that a type is not copyable by adding a where-clause to
the <code class="docutils literal notranslate"><span class="pre">init=</span></code> implementation that evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">R.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="nx">R</span><span class="p">)</span> <span class="k">where</span> <span class="kc">false</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The compiler-generated copy initializer for a generic type uses the expression
<code class="docutils literal notranslate"><span class="pre">this.type</span></code> as the argument’s type to ensure that the types of the original
record and its copy are the same:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">G</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// compiler-generated init= for &#39;G&#39;</span>
<span class="c1">// proc G.init=(other: this.type) {</span>
<span class="c1">//   this.T = other.T;</span>
<span class="c1">//   this.x = other.x;</span>
<span class="c1">// }</span>
</pre></div>
</div>
<p>Note that the generic fields must still be manually initialized, despite
the type already being known. Future work may allow these fields to be inferred.</p>
</div>
<div class="section" id="advanced-copy-initialization">
<span id="id13"></span><h3>Advanced Copy Initialization<a class="headerlink" href="#advanced-copy-initialization" title="Permalink to this headline">¶</a></h3>
<p>A copy initializer can also be used to specify how a record should be
initialized from a value of an arbitrary type. This kind of copy initializer is
invoked when a variable declaration’s initialization expression is not of the
same type as the record being initialized. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyString</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">s</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// normal copy initializer</span>
<span class="k">proc</span> <span class="nf">MyString.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="nx">MyString</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">s</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;normal init=&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// initialize from a string</span>
<span class="k">proc</span> <span class="nf">MyString.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">s</span> <span class="o">=</span> <span class="nx">other</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;string init=&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyString</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">A</span><span class="p">;</span> <span class="c1">// &quot;normal init=&quot;</span>
<span class="kd">var</span> <span class="nx">C</span> <span class="p">:</span> <span class="nx">MyString</span> <span class="o">=</span> <span class="s">&quot;goodbye&quot;</span><span class="p">;</span> <span class="c1">// &quot;string init=&quot;</span>
</pre></div>
</div>
<p>Generic types can rely on the <code class="docutils literal notranslate"><span class="pre">this.type</span></code> expression to implement these kinds
of copy initializers with the desired type constraints. The <code class="docutils literal notranslate"><span class="pre">this.type</span></code>
expression will evaluate to the type provided by the user at the variable
declaration:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// normal copy initializer</span>
<span class="k">proc</span> <span class="nf">Wrapper.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

<span class="c1">// An incorrect attempt: ignores the user-specified type, and uses the</span>
<span class="c1">// value&#39;s type (which might not be the same!)</span>
<span class="c1">// i.e. &#39;var w : Wrapper(int) = &quot;hi&quot;&#39;, tries to create a &#39;Wrapper(string)&#39;</span>
<span class="c1">// proc Wrapper.init=(other: ?T) {</span>
<span class="c1">//   this.T = T;</span>
<span class="c1">//   this.x = other;</span>
<span class="c1">// }</span>

<span class="c1">// initialize a Wrapper from the desired wrapped type &#39;T&#39;</span>
<span class="k">proc</span> <span class="nf">Wrapper.init</span><span class="o">=</span><span class="p">(</span><span class="nx">other</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="kd">type</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="nx">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">other</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">Wrapper</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="p">:</span> <span class="nx">Wrapper</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="record-assignment">
<span id="id14"></span><h3>Record Assignment<a class="headerlink" href="#record-assignment" title="Permalink to this headline">¶</a></h3>
<p>A variable of record type may be updated by assignment. The compiler
provides a default assignment operator for each record type <code class="docutils literal notranslate"><span class="pre">R</span></code> having
the signature:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">=</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">lhs</span><span class="p">:</span><span class="nx">R</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">:</span><span class="nx">R</span><span class="p">)</span> <span class="p">:</span> <span class="nx">void</span> <span class="k">where</span> <span class="nx">lhs</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
</pre></div>
</div>
<p>In it, the value of each field of the record on the right-hand side is
assigned to the corresponding field of the record on the left-hand side.</p>
<p>The compiler-provided assignment operator may be overridden as described
in <a class="reference external" href="#Assignment_Statements">11.3</a>.</p>
<p>The following example demonstrates record assignment.</p>
<blockquote>
<div><p><em>Example (assignment.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;i = &quot;</span><span class="p">,</span> <span class="nx">this</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="s">&quot;, x = &quot;</span><span class="p">,</span> <span class="nx">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="nx">R</span><span class="p">;</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span>        <span class="c1">// &quot;i = 3, x = 0.0&quot;</span>

<span class="kd">var</span> <span class="nx">C</span><span class="p">:</span> <span class="nx">R</span><span class="p">;</span>
<span class="nx">A</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span>        <span class="c1">// &quot;i = 0, x = 0.0&quot;</span>

<span class="nx">C</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">print</span><span class="p">();</span>        <span class="c1">// &quot;i = 0, x = 0.0&quot;</span>
</pre></div>
</div>
<p>Prior to the first call to <code class="docutils literal notranslate"><span class="pre">R.print</span></code>, the record <code class="docutils literal notranslate"><span class="pre">A</span></code> is created
and initialized to all zeroes. Then, its <code class="docutils literal notranslate"><span class="pre">i</span></code> field is set to <code class="docutils literal notranslate"><span class="pre">3</span></code>.
For the second call to <code class="docutils literal notranslate"><span class="pre">R.print</span></code>, the record <code class="docutils literal notranslate"><span class="pre">C</span></code> is created
assigned to <code class="docutils literal notranslate"><span class="pre">A</span></code>. Since <code class="docutils literal notranslate"><span class="pre">C</span></code> is default-initialized to all zeroes,
those zero values overwrite both values in <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The next clause demonstrates that <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> are distinct
entities, rather than two references to the same object. Assigning
<code class="docutils literal notranslate"><span class="pre">3.14</span></code> to <code class="docutils literal notranslate"><span class="pre">C.x</span></code> does not affect the <code class="docutils literal notranslate"><span class="pre">x</span></code> field in <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="default-comparison-operators">
<span id="record-comparison-operators"></span><h3>Default Comparison Operators<a class="headerlink" href="#default-comparison-operators" title="Permalink to this headline">¶</a></h3>
<p>Default functions to overload comparison operators are defined for
records if none are explicitly defined. <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> functions have the
following signatures for a record <code class="docutils literal notranslate"><span class="pre">R</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">lhs</span><span class="p">:</span><span class="nx">R</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">:</span><span class="nx">R</span><span class="p">)</span> <span class="p">:</span> <span class="kt">bool</span> <span class="k">where</span> <span class="nx">lhs</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">lhs</span><span class="p">:</span><span class="nx">R</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">:</span><span class="nx">R</span><span class="p">)</span> <span class="p">:</span> <span class="kt">bool</span> <span class="k">where</span> <span class="nx">lhs</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="nx">rhs</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
</pre></div>
</div>
<p>Other comparison operator overloads (namely <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>)
have similar signatures but their where clauses also check whether the relevant
operator is supported by each field.</p>
<p>Record comparisons have a similar behavior to <a class="reference internal" href="tuples.html#tuple-relational-operators"><span class="std std-ref">tuple comparisons</span></a>.  The operators <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>
check the corresponding lexicographical order based on pair-wise comparisons
between the arguments’ fields.  The operators <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> check whether
the two arguments are pair-wise equal or not.  The fields are compared in the
order they are declared in the record definition.</p>
</div>
</div>
<div class="section" id="differences-between-classes-and-records">
<span id="class-and-record-differences"></span><h2>Differences between Classes and Records<a class="headerlink" href="#differences-between-classes-and-records" title="Permalink to this headline">¶</a></h2>
<p>The key differences between records and classes are listed below.</p>
<div class="section" id="declarations">
<span id="declaration-differences"></span><h3>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h3>
<p>Syntactically, class and record type declarations are identical, except
that they begin with the <code class="docutils literal notranslate"><span class="pre">class</span></code> and <code class="docutils literal notranslate"><span class="pre">record</span></code> keywords,
respectively. In contrast to classes, records do not support
inheritance.</p>
</div>
<div class="section" id="storage-allocation-differences">
<span id="id15"></span><h3>Storage Allocation<a class="headerlink" href="#storage-allocation-differences" title="Permalink to this headline">¶</a></h3>
<p>For a variable of record type, storage necessary to contain the data
fields has a lifetime equivalent to the scope in which it is declared.
No two record variables share the same data. It is not necessary to call
<code class="docutils literal notranslate"><span class="pre">new</span></code> to create a record.</p>
<p>By contrast, a class variable contains only a reference to a class
instance. A class instance is created through a call to its <code class="docutils literal notranslate"><span class="pre">new</span></code>
operator. Storage for a class instance, including storage for the data
associated with the fields in the class, is allocated and reclaimed
separately from variables referencing that instance. The same class
instance can be referenced by multiple class variables.</p>
</div>
<div class="section" id="assignment">
<span id="assignment-differences"></span><h3>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h3>
<p>Assignment to a class variable is performed by reference, whereas
assignment to a record is performed by value. When a variable of class
type is assigned to another variable of class type, they both become
names for the same object. In contrast, when a record variable is
assigned to another record variable, then contents of the source record
are copied into the target record field-by-field.</p>
<p>When a variable of class type is assigned to a record, matching fields
(matched by name) are copied from the class instance into the
corresponding record fields. Subsequent changes to the fields in the
target record have no effect upon the class instance.</p>
<p>Assignment of a record to a class variable is not permitted.</p>
</div>
<div class="section" id="arguments">
<span id="argument-differences"></span><h3>Arguments<a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h3>
<p>Record arguments use the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent by default - in contrast
to class arguments which pass by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> intent by default.</p>
<p>Similarly, the <code class="docutils literal notranslate"><span class="pre">this</span></code> receiver argument is passed by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code> by
default for class methods. In contrast, it is passed by <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> by default for record methods.</p>
</div>
<div class="section" id="no-nil-value">
<h3>No <em>nil</em> Value<a class="headerlink" href="#no-nil-value" title="Permalink to this headline">¶</a></h3>
<p>Records do not provide a counterpart of the <code class="docutils literal notranslate"><span class="pre">nil</span></code> value. A variable of
record type is associated with storage throughout its lifetime, so
<code class="docutils literal notranslate"><span class="pre">nil</span></code> has no meaning with respect to records.</p>
</div>
<div class="section" id="the-delete-operator">
<span id="record-delete-illegal"></span><h3>The <em>delete</em> operator<a class="headerlink" href="#the-delete-operator" title="Permalink to this headline">¶</a></h3>
<p>Calling <code class="docutils literal notranslate"><span class="pre">delete</span></code> on a record is illegal.</p>
</div>
<div class="section" id="comparison-operator-differences">
<span id="id16"></span><h3>Default Comparison Operators<a class="headerlink" href="#comparison-operator-differences" title="Permalink to this headline">¶</a></h3>
<p>For records, the compiler will supply default comparison operators if
they are not supplied by the user. In contrast, the user cannot redefine
<code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> for classes. The default comparison operators for a
record examine the arguments’ fields, while the comparison operators for
classes check whether the l.h.s. and r.h.s. refer to the same class
instance or are both <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="unions.html" class="btn btn-neutral float-right" title="Unions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="classes.html" class="btn btn-neutral float-left" title="Classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>