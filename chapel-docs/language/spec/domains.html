

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Domains &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Arrays" href="arrays.html" />
    <link rel="prev" title="Ranges" href="ranges.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "language/spec/domains";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#domain-overview">Domain Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-domain-types-and-values">Base Domain Types and Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rectangular-domains">Rectangular Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#associative-domains">Associative Domains</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simple-subdomain-types-and-values">Simple Subdomain Types and Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-subdomain-types">Simple Subdomain Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-subdomain-values">Simple Subdomain Values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-subdomain-types-and-values">Sparse Subdomain Types and Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sparse-subdomain-types">Sparse Subdomain Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparse-subdomain-values">Sparse Subdomain Values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#domain-index-types">Domain Index Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iteration-over-domains">Iteration Over Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domains-as-arguments">Domains as Arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-of-domain-type">Formal Arguments of Domain Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-promotion-of-scalar-functions">Domain Promotion of Scalar Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#domain-operations">Domain Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#domain-assignment">Domain Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-striding">Domain Striding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-alignment">Domain Alignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-slicing">Domain Slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#count-operator">Count Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-and-removing-domain-indices">Adding and Removing Domain Indices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#predefined-methods-on-domains">Predefined Methods on Domains</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#methods-on-all-domain-types">Methods on All Domain Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methods-on-regular-domains">Methods on Regular Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#methods-on-irregular-domains">Methods on Irregular Domains</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Domains</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/domains.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="domains">
<span id="chapter-domains"></span><h1>Domains<a class="headerlink" href="#domains" title="Permalink to this headline">¶</a></h1>
<p>A <em>domain</em> is a first-class representation of an index set. Domains are
used to specify iteration spaces, to define the size and shape of arrays
(<a class="reference internal" href="arrays.html#chapter-arrays"><span class="std std-ref">Arrays</span></a>), and to specify aggregate operations like
slicing. A domain can specify a single- or multi-dimensional rectangular
iteration space or represent a set of indices of a given type. Domains
can also represent a subset of another domain’s index set, using either
a dense or sparse representation. A domain’s indices may potentially be
distributed across multiple locales as described
in&nbsp;<a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Domain Maps</span></a>, thus supporting global-view data
structures.</p>
<p>In the next subsection, we introduce the key characteristics of domains.
In&nbsp;<a class="reference internal" href="#base-domain-types-and-values"><span class="std std-ref">Base Domain Types and Values</span></a>, we discuss the types and
values that can be associated with a base domain.
In&nbsp;<a class="reference internal" href="#simple-subdomain-types-and-values"><span class="std std-ref">Simple Subdomain Types and Values</span></a>, we discuss the
types and values of simple subdomains that can be created from those
base domains. In&nbsp;<a class="reference internal" href="#sparse-subdomain-types-and-values"><span class="std std-ref">Sparse Subdomain Types and Values</span></a>, we
discuss the types and values of sparse subdomains. The remaining
sections describe the important manipulations that can be performed with
domains, as well as the predefined operators and functions defined for
domains.</p>
<div class="section" id="domain-overview">
<h2>Domain Overview<a class="headerlink" href="#domain-overview" title="Permalink to this headline">¶</a></h2>
<p>There are three <em>kinds</em> of domain, distinguished by their subset
dependencies: <em>base domains</em>, <em>subdomains</em> and <em>sparse subdomains</em>. A
base domain describes an index set spanning one or more dimensions. A
subdomain creates an index set that is a subset of the indices in a base
domain or another subdomain. Sparse subdomains are subdomains which can
represent sparse index subsets efficiently. Simple subdomains are
subdomains that are not sparse. These relationships can be represented
as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-type:
  base-domain-type
  simple-subdomain-type
  sparse-subdomain-type
</pre></div>
</div>
<p>Domains can be further classified according to whether they are
<em>regular</em> or <em>irregular</em>. A regular domain represents a rectangular
iteration space and can have a compact representation whose size is
independent of the number of indices. Rectangular domains, with the
exception of sparse subdomains, are regular.</p>
<p>An irregular domain can store an arbitrary set of indices of an
arbitrary but homogeneous index type. Irregular domains typically
require space proportional to the number of indices being represented.
All <em>associative</em> domain types and their subdomains (including sparse
subdomains) are irregular. Sparse subdomains of regular domains are also
irregular.</p>
<p>An index set can be either <em>ordered</em> or <em>unordered</em> depending on whether
its members have a well-defined order relationship. All regular domains
are ordered. All associative domains are unordered.</p>
<p>The type of a domain describes how a domain is represented and the
operations that can be performed upon it, while its value is the set of
indices it represents. In addition to storing a value, each domain
variable has an identity that distinguishes it from other domains that
may have the same type and value. This identity is used to define the
domain’s relationship with subdomains, index
types&nbsp;(<a class="reference internal" href="#index-types"><span class="std std-ref">Domain Index Types</span></a>), and
arrays&nbsp;(<a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>).</p>
<p>The runtime representation of a domain is controlled by its domain map.
Domain maps are presented in <a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Domain Maps</span></a>.</p>
</div>
<div class="section" id="base-domain-types-and-values">
<span id="id1"></span><h2>Base Domain Types and Values<a class="headerlink" href="#base-domain-types-and-values" title="Permalink to this headline">¶</a></h2>
<p>Base domain types can be classified as regular or irregular. Dense and
strided rectangular domains are regular domains. Irregular base domain
types include all of the associative domain types.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>base-domain-type:
  rectangular-domain-type
  associative-domain-type
</pre></div>
</div>
<p>These base domain types are discussed in turn in the following
subsections.</p>
<div class="section" id="rectangular-domains">
<h3>Rectangular Domains<a class="headerlink" href="#rectangular-domains" title="Permalink to this headline">¶</a></h3>
<p>Rectangular domains describe multidimensional rectangular index sets.
They are characterized by a tensor product of ranges and represent
indices that are tuples of an integral type. Because their index sets
can be represented using ranges, regular domain values typically require
only <span class="math notranslate nohighlight">\(O(1)\)</span> space.</p>
<div class="section" id="rectangular-domain-types">
<h4>Rectangular Domain Types<a class="headerlink" href="#rectangular-domain-types" title="Permalink to this headline">¶</a></h4>
<p>Rectangular domain types are parameterized by three things:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rank</span></code> a positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value indicating the number of dimensions
that the domain represents;</li>
<li><code class="docutils literal notranslate"><span class="pre">idxType</span></code> a type member representing the index type for each
dimension; and</li>
<li><code class="docutils literal notranslate"><span class="pre">stridable</span></code> a <code class="docutils literal notranslate"><span class="pre">bool</span></code> parameter indicating whether any of the
domain’s dimensions will be characterized by a strided range.</li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">rank</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the index type represented by a rectangular
domain is <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Otherwise, the index type is the homogeneous
tuple type <code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code>. If unspecified, <code class="docutils literal notranslate"><span class="pre">idxType</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">stridable</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>We may represent a rectangular domain’s index type as rank*idxType
even if rank is 1. This would eliminate a lot of code currently used
to support the special (rank == 1) case.</p>
</div></blockquote>
<p>The syntax of a rectangular domain type is summarized as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>rectangular-domain-type:
  `domain&#39; ( named-expression-list )
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">named-expression-list</span></code> permits the values of <code class="docutils literal notranslate"><span class="pre">rank</span></code>,
<code class="docutils literal notranslate"><span class="pre">idxType</span></code>, and <code class="docutils literal notranslate"><span class="pre">stridable</span></code> to be specified using standard type
signature.</p>
<blockquote>
<div><p><em>Example (typeFunctionDomain.chpl)</em>.</p>
<p>The following declarations both create an uninitialized rectangular
domain with three dimensions, with <code class="docutils literal notranslate"><span class="pre">int</span></code> indices:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D1</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nx">idxType</span><span class="o">=</span><span class="kt">int</span><span class="p">,</span> <span class="nx">stridable</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">D2</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="rectangular-domain-values">
<span id="id2"></span><h4>Rectangular Domain Values<a class="headerlink" href="#rectangular-domain-values" title="Permalink to this headline">¶</a></h4>
<p>Each dimension of a rectangular domain is a range of type
<code class="docutils literal notranslate"><span class="pre">range(idxType,</span> <span class="pre">BoundedRangeType.bounded,</span> <span class="pre">stridable)</span></code>. The index set
for a rank&nbsp;1 domain is the set of indices described by its singleton
range. The index set for a rank&nbsp;<span class="math notranslate nohighlight">\(n\)</span> domain is the set of all
<code class="docutils literal notranslate"><span class="pre">n*idxType</span></code> tuples described by the tensor product of its ranges. When
expanded (as by an iterator), rectangular domain indices are ordered
according to the lexicographic order of their values. That is, the index
with the highest rank is listed first and changes most slowly. <a class="footnote-reference" href="#id18" id="id3">[3]</a></p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>Future</em></p>
<p class="last">Domains defined using unbounded ranges may be supported.</p>
</div>
</div></blockquote>
<p>Literal rectangular domain values are represented by a comma-separated
list of range expressions of matching <code class="docutils literal notranslate"><span class="pre">idxType</span></code> enclosed in curly
braces:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>rectangular-domain-literal:
  { range-expression-list }

range-expression-list:
  range-expression
  range-expression, range-expression-list
</pre></div>
</div>
<p>The type of a rectangular domain literal is defined as follows:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rank</span></code> = the number of range expressions in the literal;</li>
<li><code class="docutils literal notranslate"><span class="pre">idxType</span></code> = the type of the range expressions;</li>
<li><code class="docutils literal notranslate"><span class="pre">stridable</span></code> = <code class="docutils literal notranslate"><span class="pre">true</span></code> if any of the range expressions are
stridable, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</li>
</ul>
<p>If the index types in the ranges differ and all of them can be promoted
to the same type, then that type is used as the <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Otherwise,
the domain literal is invalid.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The expression <code class="docutils literal notranslate"><span class="pre">{1..5,</span> <span class="pre">1..5}</span></code> defines a rectangular domain with
type <code class="docutils literal notranslate"><span class="pre">domain(rank=2,</span></code> <code class="docutils literal notranslate"><span class="pre">idxType=int,</span></code> <code class="docutils literal notranslate"><span class="pre">stridable=false)</span></code>. It is
a <span class="math notranslate nohighlight">\(5 \times 5\)</span> domain with the indices:</p>
<div class="math notranslate nohighlight">
\[(1, 1), (1, 2), \ldots, (1, 5), (2, 1), \ldots (5, 5).\]</div>
</div></blockquote>
<p>A domain expression may contain bounds which are evaluated at runtime.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">D</span></code> is defined as a two-dimensional, nonstridable rectangular
domain with an index type of <code class="docutils literal notranslate"><span class="pre">2*int</span></code> and is initialized to contain
the set of indices <span class="math notranslate nohighlight">\((i,j)\)</span> for all <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such
that <span class="math notranslate nohighlight">\(i \in {1, 2, \ldots, n}\)</span> and
<span class="math notranslate nohighlight">\(j \in {1, 2, \ldots, n}\)</span>.</p>
</div></blockquote>
<p>The default value of a domain type is the <code class="docutils literal notranslate"><span class="pre">rank</span></code> default range values
for type:</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">range(idxType,</span> <span class="pre">BoundedRangeType.bounded,</span> <span class="pre">stridable)</span></code></div></blockquote>
<blockquote>
<div><p><em>Example (rectangularDomain.chpl)</em>.</p>
<p>The following creates a two-dimensional rectangular domain and then
uses this to declare an array. The array indices are iterated over
using the domain’s <code class="docutils literal notranslate"><span class="pre">dim()</span></code> method, and each element is filled with
some value. Then the array is printed out.</p>
<p>Thus, the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="p">:</span> <span class="p">[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">for</span> <span class="nx">j</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="nx">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="nx">j</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>produces</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>8 9 10 11 12 13 14
29 30 31 32 33 34 35
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="associative-domains">
<h3>Associative Domains<a class="headerlink" href="#associative-domains" title="Permalink to this headline">¶</a></h3>
<p>Associative domains represent an arbitrary set of indices of a given
type and can be used to describe sets or to create dictionary-style
arrays (hash tables). The type of indices of an associative domain, or
its <code class="docutils literal notranslate"><span class="pre">idxType</span></code>, can be any primitive type except <code class="docutils literal notranslate"><span class="pre">void</span></code> or any class
type.</p>
<div class="section" id="associative-domain-types">
<span id="id4"></span><h4>Associative Domain Types<a class="headerlink" href="#associative-domain-types" title="Permalink to this headline">¶</a></h4>
<p>An associative domain type is parameterized by <code class="docutils literal notranslate"><span class="pre">idxType</span></code>, the type of
the indices that it stores. The syntax is as follows:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>associative-domain-type:
  `domain&#39; ( associative-index-type )

associative-index-type:
  type-expression
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">associative-index-type</span></code> determines the <code class="docutils literal notranslate"><span class="pre">idxType</span></code> of the
associative domain type.</p>
<p>When an associative domain is used as the index set of an array, the
relation between the indices and the array elements can be thought of as
a map between the values of the index set and the elements stored in the
array.</p>
</div>
<div class="section" id="associative-domain-values">
<span id="id5"></span><h4>Associative Domain Values<a class="headerlink" href="#associative-domain-values" title="Permalink to this headline">¶</a></h4>
<p>An associative domain’s value is simply the set of all index values that
the domain describes. The iteration order over the indices of an
associative domain is undefined.</p>
<p>Specification of an associative domain literal value follows a similar
syntax as rectangular domain literal values. What differentiates the two
are the types of expressions specified in the comma separated list. Use
of values of a type other than ranges will result in the construction of
an associative domain.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>associative-domain-literal:
   { associative-expression-list }

associative-expression-list:
   non-range-expression
   non-range-expression, associative-expression-list

non-range-expression:
   expression
</pre></div>
</div>
<p>It is required that the types of the values used in constructing an
associative domain literal value be of the same type. If the types of
the indices does not match a compiler error will be issued.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p><em>Future</em></p>
<p class="last">Due to implementation of <code class="docutils literal notranslate"><span class="pre">==</span></code> over arrays it is currently not possible
to use arrays as indices within an associative domain.</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Assignment of an associative domain literal results in a warning
message being printed alerting the user that whole-domain assignment
has been serialized. This results from the resize operation over
associative arrays not being parsafe.</p>
<p><em>Example (associativeDomain.chpl)</em>.</p>
<p>The following example illustrates construction of an associative
domain containing string indices “bar” and “foo”. Note that due to
internal hashing of indices the order in which the values of the
associative domain are iterated is not the same as their
specification order.</p>
<p>This code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>{foo, bar}
</pre></div>
</div>
</div></blockquote>
<p>If uninitialized, the default value of an associative domain is the
empty index set.</p>
<p>Indices can be added to or removed from an associative domain as
described in <a class="reference internal" href="#adding-and-removing-domain-indices"><span class="std std-ref">Adding and Removing Domain Indices</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="simple-subdomain-types-and-values">
<span id="id6"></span><h2>Simple Subdomain Types and Values<a class="headerlink" href="#simple-subdomain-types-and-values" title="Permalink to this headline">¶</a></h2>
<p>A subdomain is a domain whose indices are guaranteed to be a subset of
those described by another domain known as its <em>parent domain</em>. A
subdomain has the same type as its parent domain, and by default it
inherits the domain map of its parent domain. All domain types support
subdomains.</p>
<p>Simple subdomains are subdomains which are not sparse. Sparse subdomains
are discussed in the following section
(<a class="reference internal" href="#sparse-subdomain-types-and-values"><span class="std std-ref">Sparse Subdomain Types and Values</span></a>). A simple subdomain
inherits its representation (regular or irregular) from its base domain
(or base subdomain). A sparse subdomain is always irregular, even if its
base domain is regular.</p>
<p>In all other respects, the two kinds of subdomain behave identically. In
this specification, “subdomain” refers to both simple and sparse
subdomains, unless it is specifically distinguished as one or the other.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Subdomains are provided in Chapel for a number of reasons: to
facilitate the ability of the compiler or a reader to reason about
the inter-relationship of distinct domain variables; to support the
author’s ability to omit redundant domain mapping specifications; to
support the compiler’s ability to reason about the relative alignment
of multiple domains; and to improve the compiler’s ability to prove
away bounds checks for array accesses.</p>
</div></blockquote>
<div class="section" id="simple-subdomain-types">
<span id="id7"></span><h3>Simple Subdomain Types<a class="headerlink" href="#simple-subdomain-types" title="Permalink to this headline">¶</a></h3>
<p>A simple subdomain type is specified using the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>simple-subdomain-type:
  `subdomain&#39; ( domain-expression )
</pre></div>
</div>
<p>This declares that <code class="docutils literal notranslate"><span class="pre">domain-expression</span></code> is the parent domain of this
subdomain type. A simple subdomain specifies a subdomain with the same
underlying representation as its base domain.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>An open semantic issue for subdomains is when a subdomain’s subset
property should be re-verified once its parent domain is reassigned
and whether this should be done aggressively or lazily.</p>
</div></blockquote>
</div>
<div class="section" id="simple-subdomain-values">
<h3>Simple Subdomain Values<a class="headerlink" href="#simple-subdomain-values" title="Permalink to this headline">¶</a></h3>
<p>The value of a simple subdomain is the set of all index values that the
subdomain describes.</p>
<p>The default value of a simple subdomain type is the same as the default
value of its parent’s type (<a class="reference internal" href="#rectangular-domain-values"><span class="std std-ref">Rectangular Domain Values</span></a>,
<a class="reference internal" href="#associative-domain-values"><span class="std std-ref">Associative Domain Values</span></a>).</p>
<p>A simple subdomain variable can be initialized or assigned to with a
tuple of values of the parent’s <code class="docutils literal notranslate"><span class="pre">idxType</span></code>. Indices can also be added
to or removed from a simple subdomain as described in
<a class="reference internal" href="#adding-and-removing-domain-indices"><span class="std std-ref">Adding and Removing Domain Indices</span></a>. It is an error to
attempt to add an index to a subdomain that is not also a member of the
parent domain.</p>
</div>
</div>
<div class="section" id="sparse-subdomain-types-and-values">
<span id="id8"></span><h2>Sparse Subdomain Types and Values<a class="headerlink" href="#sparse-subdomain-types-and-values" title="Permalink to this headline">¶</a></h2>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>sparse-subdomain-type:
  `sparse&#39; `subdomain&#39;[OPT] ( domain-expression )
</pre></div>
</div>
<p>This declaration creates a sparse subdomain. <em>Sparse subdomains</em> are
irregular domains that describe an arbitrary subset of a domain, even if
the parent domain is a regular domain. Sparse subdomains are useful in
Chapel for defining <em>sparse arrays</em> in which a single element value
(usually “zero”) occurs frequently enough that it is worthwhile to avoid
storing it redundantly. The set difference between a sparse subdomain’s
index set and that of parent domain is the set of indices for which the
sparse array will store this replicated value.
See&nbsp;<a class="reference internal" href="arrays.html#sparse-arrays"><span class="std std-ref">Sparse Arrays</span></a> for details about sparse arrays.</p>
<div class="section" id="sparse-subdomain-types">
<h3>Sparse Subdomain Types<a class="headerlink" href="#sparse-subdomain-types" title="Permalink to this headline">¶</a></h3>
<p>Each root domain type has a unique corresponding sparse subdomain type.
Sparse subdomains whose parent domains are also sparse subdomains share
the same type.</p>
</div>
<div class="section" id="sparse-subdomain-values">
<span id="sparse-domain-values"></span><h3>Sparse Subdomain Values<a class="headerlink" href="#sparse-subdomain-values" title="Permalink to this headline">¶</a></h3>
<p>A sparse subdomain’s value is simply the set of all index values that
the domain describes. If the parent domain defines an iteration order
over its indices, the sparse subdomain inherits that order.</p>
<p>There is no literal syntax for a sparse subdomain. However, a variable
of a sparse subdomain type can be initialized using a tuple of values of
the parent domain’s index type.</p>
<p>The default value for a sparse subdomain value is the empty set.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code declares a two-dimensional dense domain <code class="docutils literal notranslate"><span class="pre">D</span></code>,
followed by a two dimensional sparse subdomain of <code class="docutils literal notranslate"><span class="pre">D</span></code> named
<code class="docutils literal notranslate"><span class="pre">SpsD</span></code>. Since <code class="docutils literal notranslate"><span class="pre">SpsD</span></code> is uninitialized, it will initially describe
an empty set of indices from <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">SpsD</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="domain-index-types">
<span id="index-types"></span><h2>Domain Index Types<a class="headerlink" href="#domain-index-types" title="Permalink to this headline">¶</a></h2>
<p>Each domain value has a corresponding compiler-provided <em>index type</em>
which can be used to represent values belonging to that domain’s index
set. Index types are described using the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>index-type:
  `index&#39; ( domain-expression )
</pre></div>
</div>
<p>A variable with a given index type is constrained to take on only values
available within the domain on which it is defined. This restriction
allows the compiler to prove away the bound checking that code safety
considerations might otherwise require. Due to the subset relationship
between a base domain and its subdomains, a variable of an index type
defined with respect to a subdomain is also necessarily a valid index
into the base domain.</p>
<p>Since an index types are known to be legal for a given domain, it may
also afford the opportunity to represent that index using an optimized
format that doesn’t simply store the index variable’s value. This fact
could be used to support accelerated access to arrays declared over that
domain. For example, iteration over an index type could be implemented
using memory pointers and strides, rather than explicitly calculating
the offset of each index within the domain.</p>
<p>These potential optimizations may make it less expensive to index into
arrays using index type variables of their domains or subdomains.</p>
<p>In addition, since an index type is associated with a specific domain or
subdomain, it carries more semantic weight than a generic index. For
example, one could iterate over a rectangular domain with integer bounds
using an <code class="docutils literal notranslate"><span class="pre">int(n)</span></code> as the index variable. However, it would be more
precise to use a variable of the domain’s index type.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>An open issue for index types is what the semantics should be for an
index type value that is live across a modification to its domain’s
index set—particularly one that shrinks the index set. Our hypothesis
is that most stored indices will either have short lifespans or
belong to constant or monotonically growing domains. But these
semantics need to be defined nevertheless.</p>
</div></blockquote>
</div>
<div class="section" id="iteration-over-domains">
<span id="id9"></span><h2>Iteration Over Domains<a class="headerlink" href="#iteration-over-domains" title="Permalink to this headline">¶</a></h2>
<p>All domains support iteration via standard <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">forall</span></code>, and
<code class="docutils literal notranslate"><span class="pre">coforall</span></code> loops. These loops iterate over all of the indices that the
domain describes. If the domain defines an iteration order of its
indices, then the indices are visited in that order.</p>
<p>The type of the iterator variable for an iteration over a domain named
<code class="docutils literal notranslate"><span class="pre">D</span></code> is that domain’s index type, <code class="docutils literal notranslate"><span class="pre">index(D)</span></code>.</p>
</div>
<div class="section" id="domains-as-arguments">
<span id="domain-arguments"></span><h2>Domains as Arguments<a class="headerlink" href="#domains-as-arguments" title="Permalink to this headline">¶</a></h2>
<p>This section describes the semantics of passing domains as arguments to
functions.</p>
<div class="section" id="formal-arguments-of-domain-type">
<h3>Formal Arguments of Domain Type<a class="headerlink" href="#formal-arguments-of-domain-type" title="Permalink to this headline">¶</a></h3>
<p>When a domain value is passed to a formal argument of compatible domain
type by default intent, it is passed by reference in order to preserve
the domain’s identity.</p>
</div>
<div class="section" id="domain-promotion-of-scalar-functions">
<span id="id10"></span><h3>Domain Promotion of Scalar Functions<a class="headerlink" href="#domain-promotion-of-scalar-functions" title="Permalink to this headline">¶</a></h3>
<p>Domain values may be passed to a scalar function argument whose type
matches the domain’s index type. This results in a promotion of the
scalar function as defined in&nbsp;<a class="reference internal" href="data-parallelism.html#promotion"><span class="std std-ref">Promotion</span></a>.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>Given a function <code class="docutils literal notranslate"><span class="pre">foo()</span></code> that accepts real floating point values
and an associative domain <code class="docutils literal notranslate"><span class="pre">D</span></code> of type <code class="docutils literal notranslate"><span class="pre">domain(real)</span></code>, <code class="docutils literal notranslate"><span class="pre">foo</span></code> can
be called with <code class="docutils literal notranslate"><span class="pre">D</span></code> as its actual argument which will result in the
function being invoked for each value in the index set of <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example</em>.</p>
<p>Given an array <code class="docutils literal notranslate"><span class="pre">A</span></code> with element type <code class="docutils literal notranslate"><span class="pre">int</span></code> declared over a
one-dimensional domain <code class="docutils literal notranslate"><span class="pre">D</span></code> with <code class="docutils literal notranslate"><span class="pre">idxType</span></code> <code class="docutils literal notranslate"><span class="pre">int</span></code>, the array
elements can be assigned their corresponding index values by writing:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="o">=</span> <span class="nx">D</span><span class="p">;</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span><span class="nx">D</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="domain-operations">
<h2>Domain Operations<a class="headerlink" href="#domain-operations" title="Permalink to this headline">¶</a></h2>
<p>Chapel supplies predefined operators and functions that can be used to
manipulate domains. Unless otherwise noted, these operations are
applicable to a domain of any type, whether a base domain or a
subdomain.</p>
<div class="section" id="domain-assignment">
<span id="id11"></span><h3>Domain Assignment<a class="headerlink" href="#domain-assignment" title="Permalink to this headline">¶</a></h3>
<p>All domain types support domain assignment.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-expression:
  domain-literal
  domain-name
  domain-assignment-expression
  domain-striding-expression
  domain-alignment-expression
  domain-slice-expression

domain-literal:
  rectangular-domain-literal
  associative-domain-literal

domain-assignment-expression:
  domain-name = domain-expression

domain-name:
  identifier
</pre></div>
</div>
<p>Domain assignment is by value and causes the target domain variable to
take on the index set of the right-hand side expression. In practice,
the right-hand side expression is often another domain value; a tuple of
ranges (for regular domains); or a tuple of indices or a loop that
enumerates indices (for irregular domains). If the domain variable being
assigned was used to declare arrays, these arrays are reallocated as
discussed in&nbsp;<a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>.</p>
<p>It is an error to assign a stridable domain to an unstridable domain
without an explicit conversion.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following three assignments show ways of assigning indices to a
sparse domain, <code class="docutils literal notranslate"><span class="pre">SpsD</span></code>. The first assigns the domain two index
values, <code class="docutils literal notranslate"><span class="pre">(1,1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(n,n)</span></code>. The second assigns the domain all of
the indices along the diagonal from
<code class="docutils literal notranslate"><span class="pre">(1,1)</span></code><span class="math notranslate nohighlight">\(\ldots\)</span><code class="docutils literal notranslate"><span class="pre">(n,n)</span></code>. The third invokes an iterator
that is written to <code class="docutils literal notranslate"><span class="pre">yield</span></code> indices read from a file named
“inds.dat”. Each of these assignments has the effect of replacing the
previous index set with a completely new set of values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">SpsD</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">));</span>
<span class="nx">SpsD</span> <span class="o">=</span> <span class="p">[</span><span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">i</span><span class="p">);</span>
<span class="nx">SpsD</span> <span class="o">=</span> <span class="nx">readIndicesFromFile</span><span class="p">(</span><span class="s">&quot;inds.dat&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="domain-striding">
<span id="id12"></span><h3>Domain Striding<a class="headerlink" href="#domain-striding" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">by</span></code> operator can be applied to a rectangular domain value in
order to create a strided rectangular domain value. The right-hand
operand to the <code class="docutils literal notranslate"><span class="pre">by</span></code> operator can either be an integral value or an
integral tuple whose size matches the domain’s rank.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-striding-expression:
  domain-expression `by&#39; expression
</pre></div>
</div>
<p>The type of the resulting domain is the same as the original domain but
with <code class="docutils literal notranslate"><span class="pre">stridable</span></code> set to true. In the case of an integer stride value,
the value of the resulting domain is computed by applying the integer
value to each range in the value using the <code class="docutils literal notranslate"><span class="pre">by</span></code> operator. In the case
of a tuple stride value, the resulting domain’s value is computed by
applying each tuple component to the corresponding range using the
<code class="docutils literal notranslate"><span class="pre">by</span></code> operator.</p>
</div>
<div class="section" id="domain-alignment">
<span id="id13"></span><h3>Domain Alignment<a class="headerlink" href="#domain-alignment" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">align</span></code> operator can be applied to a rectangular domain value in
order to change the alignment of a rectangular domain value. The
right-hand operand to the <code class="docutils literal notranslate"><span class="pre">align</span></code> operator can either be an integral
value or an integral tuple whose size matches the domain’s rank.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-alignment-expression:
  domain-expression `align&#39; expression
</pre></div>
</div>
<p>The type of the resulting domain is the same as the original domain but
with <code class="docutils literal notranslate"><span class="pre">stridable</span></code> set to true. In the case of an integer alignment
value, the value of the resulting domain is computed by applying the
integer value to each range in the value using the <code class="docutils literal notranslate"><span class="pre">align</span></code> operator.
In the case of a tuple alignment value, the resulting domain’s value is
computed by applying each tuple component to the corresponding range
using the <code class="docutils literal notranslate"><span class="pre">align</span></code> operator.</p>
</div>
<div class="section" id="domain-slicing">
<span id="id14"></span><h3>Domain Slicing<a class="headerlink" href="#domain-slicing" title="Permalink to this headline">¶</a></h3>
<p>Slicing is the application of an index set to a domain. It can be
written using either parentheses or square brackets. The index set can
be defined with either a domain or a list of ranges.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>domain-slice-expression:
  domain-expression [ slicing-index-set ]
  domain-expression ( slicing-index-set )

slicing-index-set:
  domain-expression
  range-expression-list
</pre></div>
</div>
<p>The result of slicing, or a <em>slice</em>, is a new domain value that
represents the intersection of the index set of the domain being sliced
and the index set being applied. The type and domain map of the slice
match the domain being sliced.</p>
<p>Slicing can also be performed on an array, resulting in aliasing a
subset of the array’s elements (<a class="reference internal" href="arrays.html#array-slicing"><span class="std std-ref">Array Slicing</span></a>).</p>
<div class="section" id="domain-based-slicing">
<h4>Domain-based Slicing<a class="headerlink" href="#domain-based-slicing" title="Permalink to this headline">¶</a></h4>
<p>If the brackets or parentheses contain a domain value, its index set is
applied for slicing.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Can we say that it is an alias in the case of sparse/associative?</p>
</div></blockquote>
</div>
<div class="section" id="range-based-slicing">
<span id="id15"></span><h4>Range-based Slicing<a class="headerlink" href="#range-based-slicing" title="Permalink to this headline">¶</a></h4>
<p>When slicing rectangular domains or arrays, the brackets or parentheses
can contain a list of <code class="docutils literal notranslate"><span class="pre">rank</span></code> ranges. These ranges can either be
bounded or unbounded. When unbounded, they inherit their bounds from the
domain or array being sliced. The Cartesian product of the ranges’ index
sets is applied for slicing.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code declares a two dimensional rectangular domain
<code class="docutils literal notranslate"><span class="pre">D</span></code>, and then a number of subdomains of <code class="docutils literal notranslate"><span class="pre">D</span></code> by slicing into <code class="docutils literal notranslate"><span class="pre">D</span></code>
using bounded and unbounded ranges. The <code class="docutils literal notranslate"><span class="pre">InnerD</span></code> domain describes
the inner indices of D, <code class="docutils literal notranslate"><span class="pre">Col2OfD</span></code> describes the 2nd column of
<code class="docutils literal notranslate"><span class="pre">D</span></code>, and <code class="docutils literal notranslate"><span class="pre">AllButLastRow</span></code> describes all of <code class="docutils literal notranslate"><span class="pre">D</span></code> except for the
last row.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">},</span>
      <span class="nx">InnerD</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="nx">Col2OfD</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="o">..</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="mi">2</span><span class="p">],</span>
      <span class="nx">AllButLastRow</span> <span class="o">=</span> <span class="nx">D</span><span class="p">[</span><span class="o">..</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="rank-change-slicing">
<span id="id16"></span><h4>Rank-Change Slicing<a class="headerlink" href="#rank-change-slicing" title="Permalink to this headline">¶</a></h4>
<p>For multidimensional rectangular domains and arrays, substituting
integral values for one or more of the ranges in a range-based slice
will result in a domain or array of lower rank.</p>
<p>The result of a rank-change slice on an array is an alias to a subset of
the array’s elements as described
in&nbsp;<a class="reference internal" href="arrays.html#rectangular-array-slicing"><span class="std std-ref">Rectangular Array Slicing</span></a>.</p>
<p>The result of rank-change slice on a domain is a subdomain of the domain
being sliced. The resulting subdomain’s type will be the same as the
original domain, but with a <code class="docutils literal notranslate"><span class="pre">rank</span></code> equal to the number of dimensions
that were sliced by ranges rather than integers.</p>
</div>
</div>
<div class="section" id="count-operator">
<span id="count-operator-domains"></span><h3>Count Operator<a class="headerlink" href="#count-operator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> operator can be applied to dense rectangular domains with a
tuple argument whose size matches the rank of the domain (or optionally
an integer in the case of a 1D domain). The operator is equivalent to
applying the <code class="docutils literal notranslate"><span class="pre">#</span></code> operator to the component ranges of the domain and
then using them to slice the domain as in
Section&nbsp;<a class="reference external" href="#Range_Based_Slicing">21.8.4.2</a>.</p>
</div>
<div class="section" id="adding-and-removing-domain-indices">
<span id="id17"></span><h3>Adding and Removing Domain Indices<a class="headerlink" href="#adding-and-removing-domain-indices" title="Permalink to this headline">¶</a></h3>
<p>All irregular domain types support the ability to incrementally add and
remove indices from their index sets. This can either be done using
<code class="docutils literal notranslate"><span class="pre">add(i:idxType)</span></code> and <code class="docutils literal notranslate"><span class="pre">remove(i:idxType)</span></code> methods on a domain
variable or by using the <code class="docutils literal notranslate"><span class="pre">+=</span></code> and <code class="docutils literal notranslate"><span class="pre">-=</span></code> assignment operators. It is
legal to add the same index to an irregular domain’s index set twice,
but illegal to remove an index that does not belong to the domain’s
index set.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>These remove semantics seem dangerous in a parallel context; maybe
add flags to both the method versions of the call that say whether
they should balk or not? Or add exceptions…</p>
</div></blockquote>
<p>As with normal domain assignments, arrays declared in terms of a domain
being modified in this way will be reallocated as discussed
in&nbsp;<a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a>.</p>
</div>
</div>
<div class="section" id="predefined-methods-on-domains">
<h2>Predefined Methods on Domains<a class="headerlink" href="#predefined-methods-on-domains" title="Permalink to this headline">¶</a></h2>
<p>This section gives a brief description of the library functions provided
for Domains. These are categorized by the type of domain to which they
apply: all, regular or irregular. Within each subsection, entries are
listed in alphabetical order.</p>
<div class="section" id="methods-on-all-domain-types">
<h3>Methods on All Domain Types<a class="headerlink" href="#methods-on-all-domain-types" title="Permalink to this headline">¶</a></h3>
<p>The methods in this subsection can be applied to any domain.</p>
<dl class="function">
<dt>
<code class="descname">proc domain.clear()</code></dt>
<dd><p>Resets this domain’s index set to the empty set.</p>
</dd></dl>

<p><em>Example (clearAssociativeDomain)</em>.</p>
<blockquote>
<div><p>This function provides a way to produce an empty associative domain.</p>
<p>When run, the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nx">Counter</span> <span class="p">{</span> <span class="nx">one</span><span class="p">,</span> <span class="nx">two</span><span class="p">,</span> <span class="nx">three</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">D</span> <span class="p">:</span> <span class="k">domain</span> <span class="p">(</span> <span class="nx">Counter</span> <span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="nx">Counter</span><span class="p">.</span><span class="nx">one</span><span class="p">,</span> <span class="nx">Counter</span><span class="p">.</span><span class="nx">two</span><span class="p">};</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;D has &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&quot; indices.&quot;</span><span class="p">);</span>
<span class="nx">D</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;D has &quot;</span><span class="p">,</span> <span class="nx">D</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&quot; indices.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>D has 2 indices.
D has 0 indices.
</pre></div>
</div>
</div></blockquote>
<dl class="function">
<dt>
<code class="descname">proc domain.dist : dmap</code></dt>
<dd><p>Returns the domain map that implements this domain</p>
</dd></dl>

<p><em>Example (getDomainMap)</em>.</p>
<blockquote>
<div><p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">BlockDist</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">d</span> <span class="p">:</span> <span class="k">domain</span><span class="p">)</span> <span class="k">where</span> <span class="nx">isSubtype</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="kd">type</span><span class="p">,</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Block-distributed domain&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">d</span> <span class="p">:</span> <span class="k">domain</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Unknown distribution&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">}</span> <span class="k">dmapped</span> <span class="nx">Block</span><span class="p">({</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">});</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dist</span></code> is used in a where-clause to determine the type of the
argument’s distribution. The output is:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Block-distributed domain
</pre></div>
</div>
</div></blockquote>
<dl class="function">
<dt>
<code class="descname">proc domain.idxType type</code></dt>
<dd><p>Returns the domain type’s <code class="docutils literal notranslate"><span class="pre">idxType</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc domain.indexOrder(i: index(domain)): idxType</code></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">i</span></code> is a member of the domain, returns the ordinal value of <code class="docutils literal notranslate"><span class="pre">i</span></code>
using a total ordering of the domain’s indices using 0-based indexing.
Otherwise, it returns <code class="docutils literal notranslate"><span class="pre">(-1):idxType</span></code>. For rectangular domains, this
ordering will be based on a row-major ordering of the indices; for other
domains, the ordering may be implementation-defined and unstable as
indices are added and removed from the domain.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isIrregularDom(d: domain) param</code></dt>
<dd><p>Returns a param <code class="docutils literal notranslate"><span class="pre">true</span></code> if the given domain is irregular, false
otherwise.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isRectangularDom(d: domain) param</code></dt>
<dd><p>Returns a param <code class="docutils literal notranslate"><span class="pre">true</span></code> if the given domain is rectangular, false
otherwise.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc isSparseDom(d: domain) param</code></dt>
<dd><p>Returns a param <code class="docutils literal notranslate"><span class="pre">true</span></code> if the given domain is sparse, false otherwise.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc domain.member(i)</code></dt>
<dd><p>Returns true if the given index <code class="docutils literal notranslate"><span class="pre">i</span></code> is a member of this domain’s index
set, and false otherwise.</p>
</dd></dl>

<p><em>Open issue</em>.</p>
<blockquote>
<div>We would like to call the type of i above idxType, but it’s not true
for rectangular domains. That observation provides some motivation to
normalize the behavior.</div></blockquote>
</div>
<div class="section" id="methods-on-regular-domains">
<h3>Methods on Regular Domains<a class="headerlink" href="#methods-on-regular-domains" title="Permalink to this headline">¶</a></h3>
<p>The methods described in this subsection can be applied to regular
domains only.</p>
<dl class="function">
<dt>
<code class="descname">proc domain.dim(d: int): range</code></dt>
<dd><p>Returns the range of indices described by dimension <code class="docutils literal notranslate"><span class="pre">d</span></code> of the domain,
where <code class="docutils literal notranslate"><span class="pre">d</span></code> is a value from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">rank-1</span></code>.</p>
</dd></dl>

<p><em>Example</em>.</p>
<p>The code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span>
   <span class="k">for</span> <span class="nx">j</span> <span class="kd">in</span> <span class="nx">D</span><span class="p">.</span><span class="nx">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
      <span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">));</span>
</pre></div>
</div>
<p>iterates over the indices of a dense 2D domain <code class="docutils literal notranslate"><span class="pre">D</span></code> using two
nested loops, one per dimension.</p>
<dl class="function">
<dt>
<code class="descname">proc domain.dims(): rank*range</code></dt>
<dd><p>Returns a tuple of ranges describing the dimensions of the domain.</p>
</dd></dl>

<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.expand</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
<span class="k">proc</span> <span class="nf">domain.expand</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">rank</span><span class="o">*</span><span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
</pre></div>
</div>
<p>Returns a new domain that is the current domain expanded in dimension
<code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is positive or contracted in dimension
<code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.exterior</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
<span class="k">proc</span> <span class="nf">domain.exterior</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">rank</span><span class="o">*</span><span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
</pre></div>
</div>
<p>Returns a new domain that is the exterior portion of the current domain
with <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>. If <code class="docutils literal notranslate"><span class="pre">off</span></code>
or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the exterior from the low bound of
the dimension; if positive, compute the exterior from the high bound.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.high</span><span class="p">:</span> <span class="k">index</span><span class="p">(</span><span class="k">domain</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the high index of the domain as a value of the domain’s index
type.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.interior</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
<span class="k">proc</span> <span class="nf">domain.interior</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">rank</span><span class="o">*</span><span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
</pre></div>
</div>
<p>Returns a new domain that is the interior portion of the current domain
with <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>. If <code class="docutils literal notranslate"><span class="pre">off</span></code>
or <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the interior from the low bound of
the dimension; if positive, compute the interior from the high bound.</p>
<dl class="function">
<dt>
<code class="descname">proc domain.low: index(domain)</code></dt>
<dd><p>Returns the low index of the domain as a value of the domain’s index
type.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc domain.rank param : int</code></dt>
<dd><p>Returns the rank of the domain.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc domain.size: capType</code></dt>
<dd><p>Returns the number of indices in the domain as a value of the capacity
type.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc domain.stridable param : bool</code></dt>
<dd><p>Returns whether or not the domain is stridable.</p>
</dd></dl>

<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.stride</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">numBits</span><span class="p">(</span><span class="nx">idxType</span><span class="p">))</span> <span class="k">where</span> <span class="nx">rank</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">proc</span> <span class="nf">domain.stride</span><span class="p">:</span> <span class="nx">rank</span><span class="o">*</span><span class="kt">int</span><span class="p">(</span><span class="nx">numBits</span><span class="p">(</span><span class="nx">idxType</span><span class="p">))</span>
</pre></div>
</div>
<p>Returns the stride of the domain as the domain’s stride type (for 1D
domains) or a tuple of the domain’s stride type (for multidimensional
domains).</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">domain.translate</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
<span class="k">proc</span> <span class="nf">domain.translate</span><span class="p">(</span><span class="nx">off</span><span class="p">:</span> <span class="nx">rank</span><span class="o">*</span><span class="nx">integral</span><span class="p">):</span> <span class="k">domain</span>
</pre></div>
</div>
<p>Returns a new domain that is the current domain translated by <code class="docutils literal notranslate"><span class="pre">off</span></code> or
<code class="docutils literal notranslate"><span class="pre">off(d)</span></code> for each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</div>
<div class="section" id="methods-on-irregular-domains">
<h3>Methods on Irregular Domains<a class="headerlink" href="#methods-on-irregular-domains" title="Permalink to this headline">¶</a></h3>
<p>The following methods are available only on irregular domain types.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">d</span><span class="p">:</span> <span class="k">domain</span><span class="p">,</span> <span class="nx">i</span><span class="p">:</span> <span class="k">index</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">d</span><span class="p">:</span> <span class="k">domain</span><span class="p">)</span> <span class="k">where</span> <span class="nx">i</span><span class="p">:</span> <span class="k">index</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</pre></div>
</div>
<p>Adds the given index to the given domain. If the given index is already
a member of that domain, it is ignored.</p>
<dl class="function">
<dt>
<code class="descname">proc +(d1: domain, d2: domain)</code></dt>
<dd><p>Merges the index sets of the two domain arguments.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc -(d: domain, i: index(d))</code></dt>
<dd><p>Removes the given index from the given domain. It is an error if the
domain does not contain the given index.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc -(d1: domain, d2: domain)</code></dt>
<dd><p>Removes the indices in domain <code class="docutils literal notranslate"><span class="pre">d2</span></code> from those in <code class="docutils literal notranslate"><span class="pre">d1</span></code>. It is an
error if <code class="docutils literal notranslate"><span class="pre">d2</span></code> contains indices which are not also in <code class="docutils literal notranslate"><span class="pre">d1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">proc requestCapacity(s: int)</code></dt>
<dd><p>Resizes the domain internal storage to hold at least <code class="docutils literal notranslate"><span class="pre">s</span></code> indices.</p>
</dd></dl>

<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This is also known as row-major ordering.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="arrays.html" class="btn btn-neutral float-right" title="Arrays" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ranges.html" class="btn btn-neutral float-left" title="Ranges" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>