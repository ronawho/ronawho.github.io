

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapel Tasks &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Debugging Chapel Programs" href="debugging.html" />
    <link rel="prev" title="Chapel Launchers" href="launcher.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "usingchapel/tasks";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Using Chapel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="prereqs.html">Chapel Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="chplenv.html">Setting up Your Environment for Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html">Building Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiling.html">Compiling Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="man.html">Chapel Man Page</a></li>
<li class="toctree-l2"><a class="reference internal" href="executing.html">Executing Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="multilocale.html">Multilocale Chapel Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="launcher.html">Chapel Launchers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Chapel Tasks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#task-implementation-layers">Task Implementation Layers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chpl-tasks-qthreads">CHPL_TASKS == qthreads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chpl-tasks-fifo">CHPL_TASKS == fifo</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-the-number-of-threads">Controlling the Number of Threads</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">CHPL_TASKS == fifo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">CHPL_TASKS == qthreads</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#task-call-stacks">Task Call Stacks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">CHPL_TASKS == fifo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">CHPL_TASKS == qthreads</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#task-related-quantification-methods-on-locales">Task-Related Quantification Methods on Locales</a></li>
<li class="toctree-l3"><a class="reference internal" href="#future-tasking-directions">Future Tasking Directions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging Chapel Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="bugs.html">Reporting Chapel Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Using Chapel</a> &raquo;</li>
        
      <li>Chapel Tasks</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/usingchapel/tasks.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapel-tasks">
<span id="readme-tasks"></span><h1><a class="toc-backref" href="#id6">Chapel Tasks</a><a class="headerlink" href="#chapel-tasks" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#chapel-tasks" id="id6">Chapel Tasks</a><ul>
<li><a class="reference internal" href="#overview" id="id7">Overview</a></li>
<li><a class="reference internal" href="#task-implementation-layers" id="id8">Task Implementation Layers</a><ul>
<li><a class="reference internal" href="#chpl-tasks-qthreads" id="id9">CHPL_TASKS == qthreads</a><ul>
<li><a class="reference internal" href="#stack-overflow-detection" id="id10">Stack overflow detection</a></li>
<li><a class="reference internal" href="#environment-variables" id="id11">Environment variables</a></li>
<li><a class="reference internal" href="#worker-affinity-and-number" id="id12">Worker affinity and number</a></li>
<li><a class="reference internal" href="#overloading-system-nodes" id="id13">Overloading system nodes</a></li>
<li><a class="reference internal" href="#hwloc" id="id14">Hwloc</a></li>
<li><a class="reference internal" href="#further-information" id="id15">Further information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chpl-tasks-fifo" id="id16">CHPL_TASKS == fifo</a><ul>
<li><a class="reference internal" href="#id1" id="id17">Stack overflow detection</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-the-number-of-threads" id="id18">Controlling the Number of Threads</a><ul>
<li><a class="reference internal" href="#id2" id="id19">CHPL_TASKS == fifo</a></li>
<li><a class="reference internal" href="#id3" id="id20">CHPL_TASKS == qthreads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-call-stacks" id="id21">Task Call Stacks</a><ul>
<li><a class="reference internal" href="#id4" id="id22">CHPL_TASKS == fifo</a></li>
<li><a class="reference internal" href="#id5" id="id23">CHPL_TASKS == qthreads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-related-quantification-methods-on-locales" id="id24">Task-Related Quantification Methods on Locales</a></li>
<li><a class="reference internal" href="#future-tasking-directions" id="id25">Future Tasking Directions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id7">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Chapel programs create new tasks via the begin, cobegin, and coforall
statements.  Tasks are computations that can conceptually execute
concurrently, though they may or may not do so in practice.</p>
<p>An implementation of Chapel must include at least one tasking layer.
A tasking layer will in turn implement <em>threads</em> which are a mechanism
for executing work in parallel.</p>
<p>All tasking layers support configuration constants to control system
resources such as the number of threads that are available to execute
tasks and the amount of call stack space reserved for each task.  Generally
speaking, the Chapel programmer can make no assumptions about the
scheduling of threads or the mapping of tasks to threads other than
those semantics defined by the language specification.</p>
<p>This document describes the currently-supported tasking options in more
detail.  The rest of this document includes:</p>
<ul class="simple">
<li>an overview of the different tasking options</li>
<li>a detailed description of each tasking option</li>
<li>a discussion of the number of threads used by each tasking option</li>
<li>a discussion of call stack sizes and overflow handling</li>
<li>a list of tasking-related methods on the locale type</li>
<li>a brief description of future directions for the tasking layer</li>
</ul>
<p>If you have questions about tasks that are not covered in the following,
please send them to <b>c<!-- DISGUISE -->h<!-- DISGUISE -->a<!-- DISGUISE -->p<!-- DISGUISE -->e<!-- DISGUISE -->l<!-- DISGUISE -->_<!-- DISGUISE -->i<!-- DISGUISE -->n<!-- DISGUISE -->f<!-- DISGUISE -->o<!-- DISGUISE -->@<!-- DISGUISE -->c<!-- DISGUISE -->r<!-- DISGUISE -->a<!-- DISGUISE -->y<!-- DISGUISE -->.<!-- DISGUISE -->c<!-- DISGUISE -->o<!-- DISGUISE -->m</b>.</p>
</div>
<div class="section" id="task-implementation-layers">
<h2><a class="toc-backref" href="#id8">Task Implementation Layers</a><a class="headerlink" href="#task-implementation-layers" title="Permalink to this headline">¶</a></h2>
<p>This release contains two distinct tasking layers for Chapel tasks.
The user can select between these options by setting the <code class="docutils literal notranslate"><span class="pre">CHPL_TASKS</span></code>
environment variable to one of the following values:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">qthreads:</th><td class="field-body">best performance; default for most targets</td>
</tr>
<tr class="field-even field"><th class="field-name">fifo:</th><td class="field-body">most portable, but heavyweight; default for NetBSD and Cygwin</td>
</tr>
</tbody>
</table>
<p>Each tasking layer is described in more detail below:</p>
<div class="section" id="chpl-tasks-qthreads">
<h3><a class="toc-backref" href="#id9">CHPL_TASKS == qthreads</a><a class="headerlink" href="#chpl-tasks-qthreads" title="Permalink to this headline">¶</a></h3>
<p>Chapel’s default tasking layer implementation for most targets is based
on the Qthreads user-level threading package from Sandia National Labs.
This provides a lightweight implementation of Chapel tasking as well as
an optimized implementation of sync variables.  To use qthreads tasking,
please take the following steps:</p>
<ol class="arabic">
<li><p class="first">Ensure that the environment variable <code class="docutils literal notranslate"><span class="pre">CHPL_HOME</span></code> points to the
top-level Chapel directory.</p>
</li>
<li><p class="first">Set up your environment to use Qthreads:</p>
<p>ensure <code class="docutils literal notranslate"><span class="pre">CHPL_TASKS</span></code> is not set (if qthreads is the default)</p>
<p>– or –</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">CHPL_TASKS</span><span class="o">=</span>qthreads
</pre></div>
</div>
</li>
<li><p class="first">Follow the instructions in <a class="reference internal" href="chplenv.html#readme-chplenv"><span class="std std-ref">Setting up Your Environment for Chapel</span></a> to set up,
compile and run your Chapel programs.</p>
</li>
</ol>
<p>Please report any apparent bugs in Qthreads tasking to the Chapel team.</p>
<div class="section" id="stack-overflow-detection">
<h4><a class="toc-backref" href="#id10">Stack overflow detection</a><a class="headerlink" href="#stack-overflow-detection" title="Permalink to this headline">¶</a></h4>
<p>The qthreads tasking implementation can arrange to halt programs when
any task overflows its call stack (see <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>).
It does this by placing a guard page, which cannot be referenced, at the
end of each task stack.  When a task tries to extend its stack onto a
guard page, it fails with a segfault.</p>
<p>Normally guard pages for stack overflow detection are configured and
enabled.  There is a performance cost for this, however.  We do not have
a quantitative estimate for this cost, but it is a fixed overhead (a
couple of system calls) added to the time needed to run every task, so
qualitatively speaking it will have a greater effect on programs which
create more or shorter-lived tasks than on programs which create fewer
or longer-lived ones.</p>
<p>As described in <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>, the execution-time default for
stack overflow checking can be set by using the <code class="docutils literal notranslate"><span class="pre">--[no-]stack-checks</span></code>
compiler option.  But whatever the default is, at execution time stack
overflow detection can be turned off by setting the environment variable
<code class="docutils literal notranslate"><span class="pre">QT_GUARD_PAGES</span></code> to any of the values “0”, “no”, or “false”, or on by
setting it to any of “1”, “yes”, or “true”.  When it is off the execution
overhead is negligible (just a couple of scalar tests).  Developers
who wish to remove even this small cost can disable guard pages by
building qthreads with guard pages entirely configured out, as follows:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="nv">$CHPL_HOME</span>/third-party/qthread
make <span class="nv">CHPL_QTHREAD_NO_GUARD_PAGES</span><span class="o">=</span>yes ... clean all
</pre></div>
</div>
<p>As noted, running without guard pages can improve performance and thus
may be desirable for production work.  However, if this is done, test
runs at similar scale with guard pages turned on to check for stack
overflow should be done beforehand if possible, because undetected stack
overflows can cause subtle and intermittent errors in execution.</p>
</div>
<div class="section" id="environment-variables">
<h4><a class="toc-backref" href="#id11">Environment variables</a><a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h4>
<p>Qthreads provides a number of environment variables that can be used to
configure its behavior at execution time.  An introduction to these can
be found in the ENVIRONMENT section of the qthread_init man page.  (Note
that although this man page documents variables named <code class="docutils literal notranslate"><span class="pre">QTHREAD_*</span></code>, each
variable is actually present in both <code class="docutils literal notranslate"><span class="pre">QT_*</span></code> and <code class="docutils literal notranslate"><span class="pre">QTHREAD_*</span></code> forms,
with the former superseding the latter.)  The qthreads man pages are
available by means of the man -M option, for example:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>man -M <span class="nv">$CHPL_HOME</span>/third-party/qthread/qthread-src/man qthread_init
</pre></div>
</div>
<p>Note that in some cases there are Chapel environment variables that
override Qthreads counterparts. <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> overrides
<code class="docutils literal notranslate"><span class="pre">QT_HWPAR</span></code>, for example.  Whenever a Chapel variable overrides a Qthreads
variable, you should use the Chapel one.</p>
</div>
<div class="section" id="worker-affinity-and-number">
<h4><a class="toc-backref" href="#id12">Worker affinity and number</a><a class="headerlink" href="#worker-affinity-and-number" title="Permalink to this headline">¶</a></h4>
<p>Simplistically, there are two kinds of threads in Qthreads: shepherds
that manage work distribution, and workers that host qthreads (Chapel
tasks, for our purposes).  The execution-time environment variable
<code class="docutils literal notranslate"><span class="pre">QT_WORKER_UNIT</span></code> controls how worker threads are distributed on hardware
processors.  The default is “core” to distribute workers across CPU
cores (physical processors).  An alternative is “pu”, which distributes
workers across processing units.  These are instances of the processor
architecture, or hardware threads if the cores have those.  Note that
“pu” will be automatically selected if <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code>
is set to anything larger than the number of cores, so it usually isn’t
necessary to set <code class="docutils literal notranslate"><span class="pre">QT_WORKER_UNIT</span></code>.</p>
</div>
<div class="section" id="overloading-system-nodes">
<span id="overloading-with-qthreads"></span><h4><a class="toc-backref" href="#id13">Overloading system nodes</a><a class="headerlink" href="#overloading-system-nodes" title="Permalink to this headline">¶</a></h4>
<p>By default the qthreads tasking implementation is set up to assume that
its process is not competing with anything else for system resources
(CPUs and memory) on its system node.  In this mode, qthreads optimizes
its internal behavior to favor performance over load balancing.  This
works out well for Chapel programs, because normally Chapel runs with
one process (locale) per system node.  However, with <code class="docutils literal notranslate"><span class="pre">CHPL_COMM=gasnet</span></code>
or <code class="docutils literal notranslate"><span class="pre">CHPL_COMM=ofi</span></code> one can run multiple Chapel locales on a single
system node, say for doing multilocale functional correctness testing
with limited system resources.  (See <a class="reference internal" href="multilocale.html#readme-multilocale"><span class="std std-ref">Multilocale Chapel Execution</span></a> for more
details.)  When this is done qthreads’ optimization for performance can
greatly reduce performance, due to resource starvation among multiple
Chapel processes.  If you need qthreads to share system resources more
cooperatively with other processes set <code class="docutils literal notranslate"><span class="pre">CHPL_RT_OVERSUBSCRIBED=yes</span></code> at
execution time (see <a class="reference internal" href="executing.html#oversubscribed-execution"><span class="std std-ref">Oversubscription</span></a>).</p>
</div>
<div class="section" id="hwloc">
<h4><a class="toc-backref" href="#id14">Hwloc</a><a class="headerlink" href="#hwloc" title="Permalink to this headline">¶</a></h4>
<p>When <code class="docutils literal notranslate"><span class="pre">CHPL_TASKS=qthreads</span></code>, the default for <code class="docutils literal notranslate"><span class="pre">CHPL_HWLOC</span></code> becomes “hwloc”,
and the hwloc third-party package will be built.  Qthreads depends on
this package to provide it with a description of the locale hardware, to
support locality and affinity operations.</p>
</div>
<div class="section" id="further-information">
<h4><a class="toc-backref" href="#id15">Further information</a><a class="headerlink" href="#further-information" title="Permalink to this headline">¶</a></h4>
<p>For more information on Qthreads, see $CHPL_HOME/third-party/README.</p>
</div>
</div>
<div class="section" id="chpl-tasks-fifo">
<h3><a class="toc-backref" href="#id16">CHPL_TASKS == fifo</a><a class="headerlink" href="#chpl-tasks-fifo" title="Permalink to this headline">¶</a></h3>
<p>FIFO tasking over POSIX threads (or pthreads) works on all
platforms and is the default for Cygwin and NetBSD. It is
attractive in its portability, though on most platforms it will
tend to be heavier weight than Chapel strictly requires.  FIFO
tasking is also used when Chapel is configured in ‘Quick Start’
mode (see <a class="reference internal" href="QUICKSTART.html#chapelhome-quickstart"><span class="std std-ref">Chapel Quickstart Instructions</span></a>).  To use FIFO tasking,
please take the following steps:</p>
<ol class="arabic">
<li><p class="first">Ensure that the environment variable <code class="docutils literal notranslate"><span class="pre">CHPL_HOME</span></code> points to the
top-level Chapel directory.</p>
</li>
<li><p class="first">Set up your environment to use FIFO tasking:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">CHPL_TASKS</span><span class="o">=</span>fifo
</pre></div>
</div>
</li>
<li><p class="first">Follow the instructions in <a class="reference internal" href="chplenv.html#readme-chplenv"><span class="std std-ref">Setting up Your Environment for Chapel</span></a> to set up,
compile and run your Chapel programs.</p>
</li>
</ol>
<p>In the FIFO tasking implementation, Chapel tasks are mapped to threads
such that each task is executed by a single thread and is run to
completion before giving up that thread.  As a result, a program can
have no more tasks active (that is, created and started) at any given
time than it has threads on which to run those tasks.  It can create
more tasks than threads, but no more tasks will be run at any time
than there are threads.  Excess tasks are placed in a pool where they
will be picked up and started by threads as they complete their tasks.</p>
<p>The threading implementation uses POSIX threads (pthreads) to run Chapel
tasks.  Because pthreads are relatively expensive to create, it does not
destroy them when there are no tasks for them to execute.  Instead they
stay around and continue to check the task pool for tasks to execute.
Setting the number of pthreads is described in <a class="reference internal" href="#controlling-the-number-of-threads">Controlling the Number of Threads</a>.</p>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id17">Stack overflow detection</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>The fifo tasking implementation can arrange to halt programs when any
task overflows its call stack (see <a class="reference internal" href="#task-call-stacks">Task Call Stacks</a>).  It does
this by placing a guard page, which cannot be referenced, at the end of
each task stack.  When a task tries to extend its stack onto a guard
page, it fails with a segfault.</p>
<p>This feature is enabled in fifo tasking and cannot currently be turned
off.  There is a performance cost for it, which we expect to be small in
most cases.  We do not have a quantitative estimate for this cost, but
it is a fixed overhead (a couple of system calls) added to the time
needed to start each pthread.  Since the pthreads in fifo tasking are
long-lived and can host many tasks over their lifespan, on a per-task
basis we don’t expect stack overflow detection to be expensive.</p>
</div>
</div>
</div>
<div class="section" id="controlling-the-number-of-threads">
<h2><a class="toc-backref" href="#id18">Controlling the Number of Threads</a><a class="headerlink" href="#controlling-the-number-of-threads" title="Permalink to this headline">¶</a></h2>
<p>The number of threads per compute node used to implement a Chapel
program can be controlled by the <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code>
environment variable.  This may be set to either an explicit number
or one of the following symbolic strings:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">‘MAX_PHYSICAL’:</th><td class="field-body">number of physical CPUs (cores) on the node</td>
</tr>
<tr class="field-even field"><th class="field-name">‘MAX_LOGICAL’:</th><td class="field-body">number of logical CPUs (hyperthreads) on the node</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> is not set, the number of threads is
left up to the tasking layer.  See the case-by-case discussions below
for more details.</p>
<p>The Chapel program will generate an error if the requested number of
threads per locale is too large.  For example, when running multi-locale
programs, the GASNet communication layer typically places an upper bound
of 127 or 255 on the number of threads per locale (There are ways to
work around this assumption on certain platforms – please contact us at
<b>c<!-- DISGUISE -->h<!-- DISGUISE -->a<!-- DISGUISE -->p<!-- DISGUISE -->e<!-- DISGUISE -->l<!-- DISGUISE -->_<!-- DISGUISE -->i<!-- DISGUISE -->n<!-- DISGUISE -->f<!-- DISGUISE -->o<!-- DISGUISE -->@<!-- DISGUISE -->c<!-- DISGUISE -->r<!-- DISGUISE -->a<!-- DISGUISE -->y<!-- DISGUISE -->.<!-- DISGUISE -->c<!-- DISGUISE -->o<!-- DISGUISE -->m</b> or peruse the GASNet documentation if you need
to do so.)</p>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id19">CHPL_TASKS == fifo</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The value of <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> indicates the maximum
number of threads that the fifo tasking layer can create on each
locale to execute tasks.  These threads are created on a demand-driven
basis, so a program with a small number of concurrent tasks may never
create the specified number.  If the value is zero, then the number of
threads will be limited by system resources and other constraints
(such as GASNet’s configuration-time limit).</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> can have a major impact on
performance for fifo tasking.  For programs with few inter-task
dependences and high computational intensity, setting it roughly equal
to the number of physical CPUs on each locale can lead to near-optimal
performance.  However, for programs with lots of fine-grained
synchronization in which tasks frequently block on sync or single
variables, <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> can often exceed the number
of physical CPUs without an adverse effect on performance since
blocked threads will not consume the CPU’s cycles.</p>
<p>Note that setting <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> too low can result in
program deadlock for fifo tasking.  For example, for programs written
with an assumption that some minimum number of tasks are executing
concurrently, setting <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code> lower than this
can result in deadlock if there are not enough threads to implement
all of the required tasks.  The <code class="docutils literal notranslate"><span class="pre">-b/--blockreport</span></code> flag can help debug
programs like this that appear to be deadlocked.</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id20">CHPL_TASKS == qthreads</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>In the Qthreads tasking layer, <code class="docutils literal notranslate"><span class="pre">CHPL_RT_NUM_THREADS_PER_LOCALE</span></code>
specifies the number of system threads used to execute tasks.  The
default is to use a number of threads equal to the number of physical
CPUs on the locale.</div></blockquote>
</div>
</div>
<div class="section" id="task-call-stacks">
<h2><a class="toc-backref" href="#id21">Task Call Stacks</a><a class="headerlink" href="#task-call-stacks" title="Permalink to this headline">¶</a></h2>
<p>Each task including the main Chapel program has an associated call
stack.  As documented in <a class="reference internal" href="executing.html#readme-executing"><span class="std std-ref">Executing Chapel Programs</span></a>, the <code class="docutils literal notranslate"><span class="pre">CHPL_RT_CALL_STACK_SIZE</span></code>
environment variable can be used to specify how big these call stacks
will be during execution.  See there for a full description of this
environment variable and the values it can take.</p>
<p>When a task’s call chain becomes so deep that it needs more space than
the size of its call stack, stack overflow occurs.  Whether or not a
program checks for stack overflow checking at execution time can be
specified when it is compiled, via the <code class="docutils literal notranslate"><span class="pre">--[no-]stack-checks</span></code> compilation
option.  The compile-time default is <code class="docutils literal notranslate"><span class="pre">--stack-checks</span></code>; <code class="docutils literal notranslate"><span class="pre">--no-stack-checks</span></code>
can be given directly, and is also implied by <code class="docutils literal notranslate"><span class="pre">--no-checks</span></code>, which in turn
is implied by <code class="docutils literal notranslate"><span class="pre">--fast</span></code>.  By default stack overflow checks are enabled.</p>
<p>Chapel does not yet have a consistent, implementation-independent way to
deal with call stack overflow.  Each tasking layer implementation
handles stacks and stack overflow in its own way, as described below.</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id22">CHPL_TASKS == fifo</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In fifo tasking, Chapel tasks use their host pthreads’ stacks when
executing.  If stack checks are enabled, these stacks are created with
an additional memory page called a “guard page” beyond their end, that
is marked so that it cannot be referenced.  When stack overflow occurs
the task’s attempt to reference the guard page will cause the OS to
react as it usually does when bad memory references are done.  On
Linux, for example, it will kill the program with this message:</p>
<blockquote>
<div>Segmentation fault</div></blockquote>
<p>Unfortunately, many other things that cause improper memory references
result in this same kind of program termination, so as a diagnostic it
is ambiguous.  However, it does at least prevent the program from
continuing on in an erroneous state.</p>
</div></blockquote>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id23">CHPL_TASKS == qthreads</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Like fifo tasks (see above), qthreads tasking can place guard pages
beyond the ends of task stacks.  Stack overflow then results in the
system’s usual response to referencing memory that cannot be reached.
With qthreads tasking, the compiler <code class="docutils literal notranslate"><span class="pre">--stack-checks</span></code> setting specifies
the default setting for execution-time stack overflow checking.  Final
control over stack overflow checks is provided by the <code class="docutils literal notranslate"><span class="pre">QT_GUARD_PAGE</span></code>
environment variable.  See the qthreads subsection of <a class="reference internal" href="#task-implementation-layers">Task
Implementation Layers</a> for more information.</div></blockquote>
</div>
</div>
<div class="section" id="task-related-quantification-methods-on-locales">
<h2><a class="toc-backref" href="#id24">Task-Related Quantification Methods on Locales</a><a class="headerlink" href="#task-related-quantification-methods-on-locales" title="Permalink to this headline">¶</a></h2>
<p>Several methods on the locale type are available to query the state of
the program with respect to its tasks.</p>
<blockquote>
<div><dl class="docutils">
<dt>queuedTasks()</dt>
<dd>returns the number of tasks that are ready to run, but
have not yet begun executing.</dd>
<dt>runningTasks()</dt>
<dd><p class="first">returns the number of tasks that have begun executing,
but have not yet finished.  Note that this number can exceed the
number of non-idle threads because there are cases in which a thread
is working on more than one task.  As one example, in fifo tasking,
when a parent task creates child tasks to execute the iterations of
a coforall construct, the thread the parent is running on may
temporarily suspend executing the parent task in order to help with
the child tasks, until the construct completes.  When this occurs
the count of running tasks can include both the parent task and a
child, although strictly speaking only the child is executing
instructions.</p>
<p class="last">As another example, any tasking implementation in which threads can
switch from running one task to running another, such as qthreads,
can have more tasks running than threads on which to run them.</p>
</dd>
<dt>blockedTasks()</dt>
<dd>returns the number of tasks that are blocked because
they are waiting on a sync or single variable.  In order to avoid
unnecessary overheads, in the implementations this method will not
generate meaningful information unless the program was run with the
<code class="docutils literal notranslate"><span class="pre">-b/--blockreport</span></code> flag.</dd>
<dt>totalThreads()</dt>
<dd>returns the number of threads that have been created
since the program started executing, regardless of whether they
are busy or idle.</dd>
<dt>idleThreads()</dt>
<dd>returns the number of threads are idle, i.e., not assigned to any task.</dd>
</dl>
</div></blockquote>
<p>In order to use these methods, you have to specify the locale you wish
to query, as in here.runningTasks(), where ‘here’ is the current
locale.</p>
<p>(Note that these methods are available for all tasking options, but
currently only runningTasks() returns meaningful values for all options.
The others only return meaningful values for <code class="docutils literal notranslate"><span class="pre">CHPL_TASKS=fifo</span></code>.)</p>
</div>
<div class="section" id="future-tasking-directions">
<h2><a class="toc-backref" href="#id25">Future Tasking Directions</a><a class="headerlink" href="#future-tasking-directions" title="Permalink to this headline">¶</a></h2>
<p>As Chapel’s task parallel implementation matures, we expect to have
multiple task-&gt;thread scheduling policies, from literally creating and
destroying new threads with each task (for programmers who want full
control over a thread’s lifetime) to automated work stealing and load
balancing at the other end of the spectrum (for programmers who would
prefer not to manage threads or whose programs cannot trivially be
load balanced manually).  Our hope is to leverage existing open source
threading and task management software and to collaborate with others
in these areas, so please contact us at <b>c<!-- DISGUISE -->h<!-- DISGUISE -->a<!-- DISGUISE -->p<!-- DISGUISE -->e<!-- DISGUISE -->l<!-- DISGUISE -->_<!-- DISGUISE -->i<!-- DISGUISE -->n<!-- DISGUISE -->f<!-- DISGUISE -->o<!-- DISGUISE -->@<!-- DISGUISE -->c<!-- DISGUISE -->r<!-- DISGUISE -->a<!-- DISGUISE -->y<!-- DISGUISE -->.<!-- DISGUISE -->c<!-- DISGUISE -->o<!-- DISGUISE -->m</b> if you’d
like to work with us in this area.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="debugging.html" class="btn btn-neutral float-right" title="Debugging Chapel Programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="launcher.html" class="btn btn-neutral float-left" title="Chapel Launchers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>