

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Domain Map Standard Interface &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Error Handling" href="errorHandling.html" />
    <link rel="prev" title="Runtime Support for Atomics" href="atomics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "technotes/dsi";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="allocators.html">Chapel’s Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Domain Map Standard Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#status-of-this-document">Status of this document</a></li>
<li class="toctree-l4"><a class="reference internal" href="#additional-resources">Additional Resources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-1-the-essentials">Phase 1: The Essentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-globaldistribution">class <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-globaldomain">class <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-globalarray">class <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#naming">Naming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#phase-2-additional-operations">Phase 2: Additional Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-3-privatization">Phase 3: Privatization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-privatization">What is privatization?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-does-privatization-work-with-dsi">How does privatization work with DSI?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-is-reprivatization">What is reprivatization?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dsi-privatization-requirements">DSI privatization requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-testing-privatization">Tip: testing privatization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-privatized-copies-should-reference-privatized-copies">Tip: privatized copies should reference privatized copies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation">Tip: “privatize” the domains and arrays used in the implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#phase-4-bulk-transfer-interface">Phase 4: Bulk-Transfer Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-the-bulk-transfer-interface">What is the bulk-transfer interface?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-does-the-bulk-transfer-interface-work-with-dsi">How does the bulk-transfer interface work with DSI?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#known-and-any-methods">Known and Any methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-does-a-bulk-transfer-occur">When Does a Bulk-Transfer Occur?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-any-methods">Implementing ‘Any’ Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfers-for-aliasing-domain-maps">Transfers for Aliasing Domain Maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfers-for-rank-changes">Transfers for Rank-changes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="errorHandling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="fortranInterop.html">Fortran Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="forwarding.html">Forwarding Methods Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="globalvars.html">Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="initTypeAlias.html">Invoking Initializers with a Generic Instantiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="initequals.html">The ‘init=’ Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lifetimeChecking.html">Lifetime Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="local.html">The ‘local’ keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_include.html">Including Sub-Modules from Separate Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="nilChecking.html">Checking for Nil Dereferences</a></li>
<li class="toctree-l2"><a class="reference internal" href="overloadSets.html">Checking Overload Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="partialInstantiations.html">Partial Instantiations</a></li>
<li class="toctree-l2"><a class="reference internal" href="reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Technical Notes</a> &raquo;</li>
        
      <li>Domain Map Standard Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/technotes/dsi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="domain-map-standard-interface">
<span id="readme-dsi"></span><h1><a class="toc-backref" href="#id1">Domain Map Standard Interface</a><a class="headerlink" href="#domain-map-standard-interface" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#domain-map-standard-interface" id="id1">Domain Map Standard Interface</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a><ul>
<li><a class="reference internal" href="#status-of-this-document" id="id3">Status of this document</a></li>
<li><a class="reference internal" href="#additional-resources" id="id4">Additional Resources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview" id="id5">Overview</a></li>
<li><a class="reference internal" href="#phase-1-the-essentials" id="id6">Phase 1: The Essentials</a><ul>
<li><a class="reference internal" href="#class-globaldistribution" id="id7">class <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code></a></li>
<li><a class="reference internal" href="#class-globaldomain" id="id8">class <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code></a><ul>
<li><a class="reference internal" href="#a-subdomain-description" id="id9">A. Subdomain Description</a></li>
<li><a class="reference internal" href="#b-follower-yield-order" id="id10">B. Follower Yield Order</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-globalarray" id="id11">class <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code></a></li>
<li><a class="reference internal" href="#naming" id="id12">Naming</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phase-2-additional-operations" id="id13">Phase 2: Additional Operations</a></li>
<li><a class="reference internal" href="#phase-3-privatization" id="id14">Phase 3: Privatization</a><ul>
<li><a class="reference internal" href="#what-is-privatization" id="id15">What is privatization?</a></li>
<li><a class="reference internal" href="#how-does-privatization-work-with-dsi" id="id16">How does privatization work with DSI?</a></li>
<li><a class="reference internal" href="#what-is-reprivatization" id="id17">What is reprivatization?</a></li>
<li><a class="reference internal" href="#dsi-privatization-requirements" id="id18">DSI privatization requirements</a></li>
<li><a class="reference internal" href="#tip-testing-privatization" id="id19">Tip: testing privatization</a></li>
<li><a class="reference internal" href="#tip-privatized-copies-should-reference-privatized-copies" id="id20">Tip: privatized copies should reference privatized copies</a></li>
<li><a class="reference internal" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" id="id21">Tip: “privatize” the domains and arrays used in the implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#phase-4-bulk-transfer-interface" id="id22">Phase 4: Bulk-Transfer Interface</a><ul>
<li><a class="reference internal" href="#what-is-the-bulk-transfer-interface" id="id23">What is the bulk-transfer interface?</a></li>
<li><a class="reference internal" href="#how-does-the-bulk-transfer-interface-work-with-dsi" id="id24">How does the bulk-transfer interface work with DSI?</a></li>
<li><a class="reference internal" href="#known-and-any-methods" id="id25">Known and Any methods</a></li>
<li><a class="reference internal" href="#when-does-a-bulk-transfer-occur" id="id26">When Does a Bulk-Transfer Occur?</a></li>
<li><a class="reference internal" href="#implementing-any-methods" id="id27">Implementing ‘Any’ Methods</a></li>
<li><a class="reference internal" href="#transfers-for-aliasing-domain-maps" id="id28">Transfers for Aliasing Domain Maps</a></li>
<li><a class="reference internal" href="#transfers-for-rank-changes" id="id29">Transfers for Rank-changes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document defines <strong>DSI</strong> – the Domain map Standard Interface.
It is the interface that a domain map must implement.
This interface is currently in place and is implemented by the standard
domain maps provided with this Chapel distribution.</p>
<p>The specification is split into “phases”. The intention is to suggest
an implementation order. The requirements of first phase are relied
upon by the more essential operations on domains and arrays. Later
phases support additional functionality and/or improved performance.
The phasing is approximate and is not required.</p>
<div class="section" id="status-of-this-document">
<h3><a class="toc-backref" href="#id3">Status of this document</a><a class="headerlink" href="#status-of-this-document" title="Permalink to this headline">¶</a></h3>
<p>This document, as well as the DSI interface itself, are work in progress.
We solicit feedback on both.</p>
<p>The following aspects are not documented yet:</p>
<ul class="simple">
<li>a summary of the six descriptor classes</li>
<li>the requirements for a domain map to support
associative or sparse domains;</li>
<li>the significance of dsiClone();</li>
<li>the “local descriptor” classes;</li>
<li>some required methods.</li>
</ul>
</div>
<div class="section" id="additional-resources">
<h3><a class="toc-backref" href="#id4">Additional Resources</a><a class="headerlink" href="#additional-resources" title="Permalink to this headline">¶</a></h3>
<p>Implementations of the standard domain maps may be consulted as
examples.  They are available in:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$CHPL_HOME/modules/dists
$CHPL_HOME/modules/layouts
</pre></div>
</div>
</div></blockquote>
<p>In addition, the following publication provide more background
information on domain maps in general.</p>
<ul>
<li><p class="first">“User-Defined Distributions and Layouts in Chapel: Philosophy and
Framework.” Bradford L. Chamberlain, Steven J. Deitz, David
Iten, Sung-Eun Choi. 2nd USENIX Workshop on Hot Topics in
Parallelism, June 2010.</p>
<blockquote>
<div><p>The high level motivation and overview of DSI.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/hotpar10-final.pdf">https://chapel-lang.org/publications/hotpar10-final.pdf</a></p>
</div></blockquote>
</li>
<li><p class="first">“Authoring User-Defined Domain Maps in Chapel.”  Bradford
L. Chamberlain, Sung-Eun Choi, Steven J. Deitz, David Iten, Vassily
Litvinov. CUG 2011, May 2011.</p>
<blockquote>
<div><p>A follow-on paper that outlines how to write a domain map.</p>
<p><a class="reference external" href="https://chapel-lang.org/publications/cug11-final.pdf">https://chapel-lang.org/publications/cug11-final.pdf</a></p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id5">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A domain map must provide three (or more) “global descriptor” classes.
Here they are called <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code>, <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>,
and <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code>.
Their required fields and methods, as well as suggested naming,
are specified below.</p>
<p>A domain map is allowed to contain/provide features, data structures
and functionality (internally to facilitate implementation and/or
externally for users’ benefit) beyond the DSI requirements.
For example, a distribution (i.e. a domain map that distributes data across
multiple locales) will typically define “local descriptor” classes as well.</p>
<p>A domain map author can provide additional functionality to users simply by
implementing methods on “global descriptor” classes. When user code contains a
method call on an array, domain, or distribution that is not handled by one of
the predefined methods, that call is forwarded to the corresponding global
descriptor.</p>
</div>
<div class="section" id="phase-1-the-essentials">
<h2><a class="toc-backref" href="#id6">Phase 1: The Essentials</a><a class="headerlink" href="#phase-1-the-essentials" title="Permalink to this headline">¶</a></h2>
<div class="section" id="class-globaldistribution">
<h3><a class="toc-backref" href="#id7">class <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code></a><a class="headerlink" href="#class-globaldistribution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This class is visible to the users of the domain map: the <code class="docutils literal notranslate"><span class="pre">dmap</span></code> wrapper
in Chapel’s <cite>dmapped</cite> clauses wraps instances of this class.
This class must be a subclass of <code class="docutils literal notranslate"><span class="pre">BaseDist</span></code>.</div></blockquote>
<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.GlobalDistribution() // or with arguments</code></dt>
<dd><p>Constructor(s)  These are not regulated by DSI - their specifics are
at the domain map implementor’s discretion.</p>
<p>We suggest providing constructor(s) that accept, as an argument,
an array of locales over which to distribute, with <code class="docutils literal notranslate"><span class="pre">Locales</span></code>
as the default value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiClone(): GlobalDistribution</code></dt>
<dd><p>Returns a duplicate of <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements displayRepresentation()
on the dmap wrapper.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiEqualDMaps(that: /*some other GlobalDistribution*/): bool</code></dt>
<dd><p>Return whether or not the two domain maps are “equal” (specify the
same distribution).  This is invoked when <code class="docutils literal notranslate"><span class="pre">==</span></code> is applied to two
domain maps.</p>
</dd></dl>

</div>
<div class="section" id="class-globaldomain">
<h3><a class="toc-backref" href="#id8">class <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code></a><a class="headerlink" href="#class-globaldomain" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code>-mapped
Chapel domain is created (e.g. when a domain variable is declared).
There is a one-to-one correspondence at run time between a
(conceptual) Chapel domain value and an instance of <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>.
For presentation simplicity, <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>’s properties refer to
the properties of the corresponding Chapel domain value, when
clear from the context.</p>
<p>Depending on the domain kind, this class is returned by the following
method on <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code>
and must be a subclass of the following class:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="42%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">domain kind</th>
<th class="head">creating method</th>
<th class="head">required superclass</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rectangular</td>
<td><code class="docutils literal notranslate"><span class="pre">dsiNewRectangularDom</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">BaseRectangularDom</span></code></td>
</tr>
<tr class="row-odd"><td>associative</td>
<td><code class="docutils literal notranslate"><span class="pre">dsiNewAssociativeDom</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">BaseAssociativeDom</span></code></td>
</tr>
<tr class="row-even"><td>sparse</td>
<td><code class="docutils literal notranslate"><span class="pre">dsiNewSparseDom</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">BaseSparseDom</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>It is legal for these methods to return instances of different classes
in different circumstances. (For example, due to the absence of multiple
inheritance, different domain kinds require different classes.)</p>
<p>The DSI requirements apply to each of those classes.
<code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> is used in this document to refer to each such class.</p>
<p>The DSI requirements depend on the domain kind that is supported.
The following requirements apply when supporting rectangular domains.</p>
</div></blockquote>
<dl class="class">
<dt id="GlobalDomain">
<em class="property">class </em><code class="descname">GlobalDomain</code><a class="headerlink" href="#GlobalDomain" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The fields <code class="docutils literal notranslate"><span class="pre">rank</span></code>, <code class="docutils literal notranslate"><span class="pre">idxType</span></code>, <code class="docutils literal notranslate"><span class="pre">stridable</span></code> are the attributes
of the corresponding Chapel domain. (They could be replaced with
parentheses-less functions of the same names and param/type intents.)</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">dist</span></code> must contain a reference
to the <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> object
that created this <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>. It is used when creating the (runtime)
type for this domain, which contains the domain’s domain map.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiMyDist() return dist;</code></dt>
<dd><p>Returns this domain’s domain map. This procedure should be provided as shown.
(Exception: see <code class="docutils literal notranslate"><span class="pre">dsiLinksDistribution()</span></code>.)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiNewRectangularDom(param rank: int, type idxType, param stridable: bool, inds) : GlobalDomain(rank, idxType, stridable)</code></dt>
<dd><p>This method is invoked when the Chapel program is creating a domain
value of the type domain(rank, idxType, stridable) mapped using the
domain map <cite>this</cite> with initial indices <cite>inds</cite>.</p>
<p>This method returns a new <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> instance that will correspond to
that Chapel domain value, i.e., be that value’s runtime representation.
The field <code class="docutils literal notranslate"><span class="pre">dist</span></code> of the returned <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiGetIndices(): rank * range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd><p>Returns a tuple of ranges describing the dimensions of this domain.</p>
<p><code class="docutils literal notranslate"><span class="pre">dsiDims()</span></code> and <code class="docutils literal notranslate"><span class="pre">dsiGetIndices()</span></code> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSetIndices(dom: domain(rank, idxType, stridable)): void</code></dt>
<dd><p>Updates the internal representation of <cite>this</cite>
to match the index set of <code class="docutils literal notranslate"><span class="pre">dom</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">dsiSetIndices</span></code> and <code class="docutils literal notranslate"><span class="pre">dsiGetIndices</span></code> are used to assign a domain value to
a domain variable (or any domain l-value).
Note: the arrays associated with this domain will be updated
outside these method.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSetIndices(ranges: rank * range(idxType)): void</code></dt>
<dd><p>The same as the other <code class="docutils literal notranslate"><span class="pre">dsiSetIndices</span></code>. Could be implemented like this:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="nx">dsiSetIndices</span><span class="p">([(</span><span class="o">..</span><span class="p">.</span><span class="nx">rangesArg</span><span class="p">)]);</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>It is used to initialize the index set of the object returned by
<code class="docutils literal notranslate"><span class="pre">dsiNewRectangularDom()</span></code> to the index set of the corresponding Chapel
domain value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiAssignDomain(rhs: domain, lhsPrivate:bool): void</code></dt>
<dd><p>Set one domain to another. The receiver is the domain being set.
The rhs could be any domain, but this function should raise a
compilation error if the types do not match sufficiently.</p>
<p>In some cases when this method is called, the LHS can’t be shared
or have any arrays declared over it. In that case, <code class="docutils literal notranslate"><span class="pre">lhsPrivate=true</span></code>
is passed.</p>
<p>Note that the method <code class="docutils literal notranslate"><span class="pre">chpl_assignDomainWithGetSetIndices</span></code> can be called
to use <code class="docutils literal notranslate"><span class="pre">dsiReallocate</span></code>/<code class="docutils literal notranslate"><span class="pre">getIndices</span></code>/<code class="docutils literal notranslate"><span class="pre">dsiSetIndices</span></code>/
<code class="docutils literal notranslate"><span class="pre">dsiPostReallocate</span></code> to accomplish the assignment.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these()</code></dt>
<dd><p>The serial iterator over the indices of this domain.
Yields values of the type <code class="docutils literal notranslate"><span class="pre">idxType</span></code> if <code class="docutils literal notranslate"><span class="pre">rank==1</span></code>,
otherwise <code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.leader</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag, followThis) where tag == iterKind.follower</code></dt>
<dd><p>The “leader” and “follower” iterators (defined below). They are
invoked implicitly to implement parallel (“forall”) loops over this domain.
Currently the serial iterator must also be defined for “forall” loops to work.</p>
<p>The presentation below is tailored to the use of leader/follower iterators
in domain maps. For a more general discussion, see:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$CHPL_HOME/examples/primers/parIters.chpl
</pre></div>
</div>
</div></blockquote>
<p>The job of the leader iterator is to:</p>
<blockquote>
<div><ul class="simple">
<li>subdivide the given domain into subdomains,</li>
<li>introduce parallelism between these subdomains, and</li>
<li>place computations for each subdomain on the desired locale,
as appropriate for this domain map.</li>
</ul>
</div></blockquote>
<p>The leader iterator must yield, for each subdomain it chooses,
a description of that subdomain, created as defined below.
Parallelism and placement are achieved, for example, by placing the
yield statements within parallel loops and <cite>on</cite> statements.
The leader is invoked (implicitly) once per parallel loop or expression
over the corresponding domain.</p>
<p>The job of the follower iterator is simply to iterate sequentially
over a subdomain whose description is yielded by the leader iterator,
yielding all indices in that subdomain.
Each time the leader yields a description, the follower is invoked
(implicitly) with that description passed to its <code class="docutils literal notranslate"><span class="pre">followThis</span></code> argument.
(The argument name must be exactly “followThis”.)</p>
<p>For a zippered loop, only the leader for the first of the zippered
items is invoked. Each time that leader yields a description,
all followers are invoked in a zippered manner, with that description
passed to their <code class="docutils literal notranslate"><span class="pre">followThis</span></code> arguments.</p>
<p>In general, it is up to the implementer of the leaders/followers
whether and how to support their interoperability in this situation.
That is, whether and how the description from the leader of one
zippered item is handled by the follower of another item.
For example, one could support zippering of similar items
and generate a compile-time or run-time error when the items
are not “similar”.</p>
<p>DSI requires interoperability between domain maps only
for <em>rectangular</em> domains, by prescribing:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>how the leader builds the description of a subdomain, and</li>
<li>in what order the follower yields the indices of that subdomain.</li>
</ol>
</div></blockquote>
</dd></dl>

<div class="section" id="a-subdomain-description">
<h4><a class="toc-backref" href="#id9">A. Subdomain Description</a><a class="headerlink" href="#a-subdomain-description" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Let <code class="docutils literal notranslate"><span class="pre">Dwhole</span></code> be the Chapel domain corresponding to this <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">Dsub</span></code> be a subdomain chosen by the leader iterator.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">DD</span></code> be the number of dimensions in Dwhole and Dsub.</p>
<p>The description of <code class="docutils literal notranslate"><span class="pre">Dsub</span></code> is its “densification” w.r.t. <code class="docutils literal notranslate"><span class="pre">Dwhole</span></code>:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">densification</span> <span class="n">of</span> <span class="n">a</span> <span class="n">domain</span> <span class="ow">is</span> <span class="n">a</span> <span class="nb">tuple</span> <span class="n">of</span> <span class="n">densifications</span>
<span class="o">//</span> <span class="n">of</span> <span class="n">ranges</span> <span class="k">for</span> <span class="n">each</span> <span class="n">dimension</span>
<span class="n">densify</span><span class="p">(</span><span class="n">Dsub</span><span class="p">,</span> <span class="n">Dwhole</span><span class="p">)</span> <span class="o">=</span>
  <span class="p">(</span> <span class="n">densify</span><span class="p">(</span><span class="n">Dsub</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Dwhole</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="n">densify</span><span class="p">(</span><span class="n">Dsub</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">DD</span><span class="p">),</span> <span class="n">Dwhole</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">DD</span><span class="p">))</span> <span class="p">)</span>

<span class="o">//</span> <span class="n">densification</span> <span class="n">of</span> <span class="n">a</span> <span class="nb">range</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">densifications</span>
<span class="o">//</span> <span class="n">of</span> <span class="n">its</span> <span class="n">elements</span><span class="p">,</span> <span class="n">preserving</span> <span class="n">their</span> <span class="n">order</span>
<span class="k">if</span> <span class="n">Rsub</span> <span class="n">describes</span> <span class="n">the</span> <span class="n">sequence</span>
  <span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_N</span>
<span class="n">then</span> <span class="n">densify</span><span class="p">(</span><span class="n">Rsub</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span> <span class="n">describes</span> <span class="n">the</span> <span class="n">sequence</span>
  <span class="n">densify</span><span class="p">(</span><span class="n">i_1</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="n">densify</span><span class="p">(</span><span class="n">i_N</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span>

<span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">densify</span><span class="p">(</span><span class="n">Rwhole</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.</span><span class="o">.</span> <span class="c1">#(Rwhole.length)</span>

<span class="o">//</span> <span class="n">densification</span> <span class="n">of</span> <span class="n">an</span> <span class="n">index</span> <span class="ow">is</span> <span class="n">its</span> <span class="n">indexOrder</span>
<span class="n">densify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rwhole</span><span class="o">.</span><span class="n">indexOrder</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The optional module DSIUtil provides the following implementations
of densifications and the reverse transformation:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">densify</span><span class="p">(</span><span class="n">Dsub</span><span class="p">,</span> <span class="n">Dwhole</span><span class="p">)</span>
<span class="n">densify</span><span class="p">(</span><span class="n">RSsub</span><span class="p">,</span> <span class="n">RSwhole</span><span class="p">)</span>  <span class="o">//</span> <span class="n">on</span> <span class="n">tuples</span> <span class="n">of</span> <span class="n">ranges</span>
<span class="n">densify</span><span class="p">(</span><span class="n">Rsub</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span>
<span class="n">unDensify</span><span class="p">(</span><span class="n">Dsub</span><span class="p">,</span> <span class="n">Dwhole</span><span class="p">)</span>
<span class="n">unDensify</span><span class="p">(</span><span class="n">RSsub</span><span class="p">,</span> <span class="n">RSwhole</span><span class="p">)</span>  <span class="o">//</span> <span class="n">on</span> <span class="n">tuples</span> <span class="n">of</span> <span class="n">ranges</span>
<span class="n">unDensify</span><span class="p">(</span><span class="n">Rsub</span><span class="p">,</span> <span class="n">Rwhole</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Hint: when developing a new domain map, skip densification and
de-densification, but ensure it is used in zippering only
with domains/arrays of the same domain map.</p>
</div></blockquote>
</div>
<div class="section" id="b-follower-yield-order">
<h4><a class="toc-backref" href="#id10">B. Follower Yield Order</a><a class="headerlink" href="#b-follower-yield-order" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The follower iterator must traverse the subdomain for which the above
description is created in the order given by the default domain map.
(That order can be observed, e.g., by assigning <code class="docutils literal notranslate"><span class="pre">Rsub</span></code> to a domain
variable whose type does not specify a domain map explicitly,
then invoking <code class="docutils literal notranslate"><span class="pre">write()</span></code> on that variable.)</p>
<p>(Interoperability of domain maps implies that the follower must
accept a densification of any subdomain of <code class="docutils literal notranslate"><span class="pre">Dwhole</span></code>, not just the
ones that can be generated by its leader.)</p>
</div></blockquote>
<dl class="method">
<dt>
<code class="descname">iter GlobalDomain.these(param tag) where tag == iterKind.standalone</code></dt>
<dd><p>A “standalone” parallel iterator. It is optional. If it is provided,
it is used in non-zippered “forall” loops
instead of a combination of leader+follower iterators.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiSerialWrite(f: Writer): void</code></dt>
<dd><p>Writes out the domain to the given Writer (e.g. a file or stdout) serially.
Is used to implement write() on the corresponding domain.</p>
<p>This method will typically invoke f.write() on <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>’s components
(e.g. bounds) and strings (e.g. “[” and “]”). Such invocations, whether
direct or indirect, must occur within the same task that <code class="docutils literal notranslate"><span class="pre">dsiSerialWrite()</span></code>
is invoked in, and not within any <cite>on</cite> statements, direct or indirect.
Otherwise a deadlock may occur.
(Invoking <code class="docutils literal notranslate"><span class="pre">write()</span></code> on <code class="docutils literal notranslate"><span class="pre">Writers</span></code> other than <code class="docutils literal notranslate"><span class="pre">f</span></code>
is not affected by this.)</p>
<p><code class="docutils literal notranslate"><span class="pre">dsiSerialWrite()</span></code> will always be invoked on <code class="docutils literal notranslate"><span class="pre">Locales(0)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements <code class="docutils literal notranslate"><span class="pre">displayRepresentation()</span></code>
on the corresponding Chapel domain value.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-globalarray">
<h3><a class="toc-backref" href="#id11">class <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code></a><a class="headerlink" href="#class-globalarray" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>An instance of this class is created whenever a Chapel array is created
over a domain represented by a <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>.
There is a one-to-one correspondence at run time between a
(conceptual) Chapel array value and an instance of <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code>.</p>
<p>This class is returned by <code class="docutils literal notranslate"><span class="pre">GlobalDomain.dsiBuildArray</span></code>.
It must be a subclass of <code class="docutils literal notranslate"><span class="pre">BaseArr</span></code>.</p>
<p>It is legal for <code class="docutils literal notranslate"><span class="pre">GlobalDomain.dsiBuildArray</span></code> to return instances of
different classes in different circumstances.
The DSI requirements apply to each of those classes.
Here <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> refers to each such class.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalArray</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field <code class="docutils literal notranslate"><span class="pre">eltType</span></code> gives the type of the array elements.</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">dom</span></code> must contain a reference to the <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> object
that created this <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code>. This is used when creating the (runtime)
type for this array, which contains the array’s domain.</p>
</div></blockquote>
<dl class="method">
<dt>
<code class="descname">proc GlobalArray.GlobalArray() // or with arguments</code></dt>
<dd><p>Constructor(s). These are not regulated by DSI – their specifics are
at the domain map implementor’s discretion.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiBuildArray(type eltType) : GlobalArray(eltType, this.type)</code></dt>
<dd><p>This method is invoked when the Chapel program is creating
an array value over the domain <cite>this</cite> with the element type <code class="docutils literal notranslate"><span class="pre">eltType</span></code>.
This method returns a new <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> instance that will correspond to
that Chapel array value, i.e., be that value’s runtime representation.
The field <code class="docutils literal notranslate"><span class="pre">dom</span></code> of the returned <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> must point to <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiGetBaseDom() return dom;</code></dt>
<dd><p>Returns this array’s <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>.
This procedure should be provided as shown.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiAccess(indexx) var: eltType</code></dt>
<dd><p>Given an index, returns the corresponding array element (as an l-value).</p>
<p>The domain map implementer is allowed to restrict the type of indexx
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiSerialWrite(f: Writer): void</code></dt>
<dd><p>Writes out the array to the given <code class="docutils literal notranslate"><span class="pre">Writer</span></code>
(e.g. a <code class="docutils literal notranslate"><span class="pre">file</span></code> or <code class="docutils literal notranslate"><span class="pre">stdout</span></code>) serially.
Is used to implement <code class="docutils literal notranslate"><span class="pre">write()</span></code> on the corresponding array.</p>
<p>The restrictions on this method are the same as on
<code class="docutils literal notranslate"><span class="pre">GlobalDomain.dsiSerialWrite()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these() var: eltType</code></dt>
<dd><p>The serial iterator over the elements of this array.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag) where tag == iterKind.leader</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag, followThis) var  where tag == iterKind.follower</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">iter GlobalArray.these(param tag) where tag == iterKind.standalone</code></dt>
<dd><p>The leader, follower, and standalone iterators.</p>
<p>These are defined in the same way as the leader and follower for
<code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>, except the follower must yield array locations.</p>
<p>Given a subdomain description passed to the <code class="docutils literal notranslate"><span class="pre">followThis</span></code> argument,
the <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> follower iterator must yield array locations
corresponding to the indices yielded by the <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> follower,
in the same order.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiReallocate(d: domain): void</code></dt>
<dd><p>When this array’s domain is assigned a new value, say <code class="docutils literal notranslate"><span class="pre">newDom</span></code>,
first <code class="docutils literal notranslate"><span class="pre">dsiReallocate(newDom)</span></code> is invoked on this array.
Then, <code class="docutils literal notranslate"><span class="pre">dsiSetIndices(newDom)</span></code> is invoked on this array’s <code class="docutils literal notranslate"><span class="pre">dom</span></code>.</p>
<p>Correspondingly, <code class="docutils literal notranslate"><span class="pre">dsiReallocate</span></code> needs to adjust everything
that won’t be taken care of in <code class="docutils literal notranslate"><span class="pre">dsiSetIndices</span></code>.</p>
<p>NOTE: the formal’s name must be exactly <code class="docutils literal notranslate"><span class="pre">d</span></code>
at present (due to compiler specifics).</p>
<p>NOTE: this method can/should be a no-op if:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> stores its array elements in Chapel array(s), and</li>
<li>the domain(s) of those array(s) are updated by <code class="docutils literal notranslate"><span class="pre">dsiSetIndices</span></code>,</li>
</ul>
</div></blockquote>
<p>as in the following simplified example:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="p">:</span> <span class="nx">BaseRectangularDom</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">param</span> <span class="nx">rank</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">idxType</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">stridable</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="c1">// for example, store indices as a single Chapel domain</span>
  <span class="kd">var</span> <span class="nx">myIndices</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span> <span class="nx">idxType</span><span class="p">,</span> <span class="nx">stridable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain.dsiSetIndices</span><span class="p">(</span><span class="nx">dom</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="nx">rank</span><span class="p">,</span><span class="nx">idxType</span><span class="p">,</span><span class="nx">stridable</span><span class="p">)):</span> <span class="nx">void</span>
<span class="p">{</span> <span class="nx">myIndices</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">GlobalArray</span> <span class="p">:</span> <span class="nx">BaseArr</span> <span class="p">{</span>
  <span class="c1">// required</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dom</span><span class="p">;</span>
  <span class="c1">// for example, store elements as a single Chapel array</span>
  <span class="kd">var</span> <span class="nx">myElements</span><span class="p">:</span> <span class="p">[</span><span class="nx">dom</span><span class="p">.</span><span class="nx">myIndices</span><span class="p">]</span> <span class="nx">eltType</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Given one instance of each class, say <code class="docutils literal notranslate"><span class="pre">gd</span></code> and <code class="docutils literal notranslate"><span class="pre">ga</span></code>,
where <code class="docutils literal notranslate"><span class="pre">ga.dom</span> <span class="pre">==</span> <span class="pre">gd</span></code>
the domain of <code class="docutils literal notranslate"><span class="pre">ga.myElements</span></code> is <code class="docutils literal notranslate"><span class="pre">gd.myIndices</span></code>.
A call <code class="docutils literal notranslate"><span class="pre">gd.dsiSetIndices(newDom)</span></code> updates <code class="docutils literal notranslate"><span class="pre">gd.myIndices</span></code>, which, in turn,
resizes <code class="docutils literal notranslate"><span class="pre">ga.myElements</span></code>, according to Chapel’s array semantics.
Nothing remains to do in <code class="docutils literal notranslate"><span class="pre">dsiReallocate()</span></code>.</p>
<p>(Behind the scene, resizing of <code class="docutils literal notranslate"><span class="pre">ga.myElements</span></code> is implemented by
<code class="docutils literal notranslate"><span class="pre">dsiReallocate</span></code> of the default domain map. That’s the domain map
that <code class="docutils literal notranslate"><span class="pre">myIndices</span></code> is distributed with, since <code class="docutils literal notranslate"><span class="pre">myIndices</span></code>’s type
provides no explicit domain map.)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.dsiDisplayRepresentation(): void</code></dt>
<dd><p>A debugging method. It implements <code class="docutils literal notranslate"><span class="pre">displayRepresentation()</span></code>
on the corresponding Chapel array value.</p>
</dd></dl>

</div>
<div class="section" id="naming">
<h3><a class="toc-backref" href="#id12">Naming</a><a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h3>
<p>Once you have chosen the name for your domain map, say, MyMap,
we suggest naming the descriptor classes as follows:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">in this document</th>
<th class="head">in your code</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">MyMapDist</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">MyMapDom</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">MyMapArr</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">LocalDistribution</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">LocMyMapDist</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">LocalDomain</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">LocMyMapDom</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">LocalArray</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">LocMyMapArr</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Some domain maps in this Chapel distribution use just the domain map
name for their <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> classes, e.g. Block and Cyclic.</p>
</div>
</div>
<div class="section" id="phase-2-additional-operations">
<h2><a class="toc-backref" href="#id13">Phase 2: Additional Operations</a><a class="headerlink" href="#phase-2-additional-operations" title="Permalink to this headline">¶</a></h2>
<p>The operations in this phase are required by DSI.
However, if a domain map is in use by a limited set of applications,
these operations do not need to be implemented up front. Instead,
each of them could be implemented later, when the need arises.
The “unresolved call” compilation errors could be used
as an indication of what procedure(s) need to be defined.</p>
<dl class="method">
<dt>
<code class="descname">proc GlobalDistribution.dsiIndexToLocale(indexx): locale</code></dt>
<dd><p>Given an index <code class="docutils literal notranslate"><span class="pre">indexx</span></code>, returns the locale that “owns” that index,
i.e. on which the corresponding data is located.
This is used to implement <code class="docutils literal notranslate"><span class="pre">idxToLocale()</span></code> on the <code class="docutils literal notranslate"><span class="pre">dmap</span></code> wrapper.</p>
<p>The domain map implementer is allowed to restrict the type of <code class="docutils literal notranslate"><span class="pre">indexx</span></code>
that this method accepts.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDim(dim: int): range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiDims(): rank * range(idxType, BoundedRangeType.bounded, stridable)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiLow</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiHigh</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiStride</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiNumIndices</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiMember(indexx)</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiIndexOrder(indexx)</code></dt>
<dd><p>These methods implement the corresponding queries
(<code class="docutils literal notranslate"><span class="pre">dim</span></code>, <code class="docutils literal notranslate"><span class="pre">dims</span></code>, <code class="docutils literal notranslate"><span class="pre">low</span></code>, etc.)
of the domain value for which this <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> instance was created.
For example, <code class="docutils literal notranslate"><span class="pre">dsiDim(d)</span></code> returns the range describing the domain’s
<code class="docutils literal notranslate"><span class="pre">d</span></code>-th dimension.</p>
<p><code class="docutils literal notranslate"><span class="pre">dsiDims()</span></code> and <code class="docutils literal notranslate"><span class="pre">dsiGetIndices()</span></code> have the same specification
and so may be implemented in terms of one another.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.linksDistribution() param</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalDomain.dsiLinksDistribution()</code></dt>
<dd><p>Typically these should not be defined.</p>
<p>If the domains mapped using <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> do NOT need to be tracked
and the <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> itself does NOT need to be reference counted,
these two methods should be defined to return <cite>false</cite>;
Also in this case <code class="docutils literal notranslate"><span class="pre">dsiMyDist()</span></code> does not need to be defined.</p>
</dd></dl>

</div>
<div class="section" id="phase-3-privatization">
<h2><a class="toc-backref" href="#id14">Phase 3: Privatization</a><a class="headerlink" href="#phase-3-privatization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-privatization">
<h3><a class="toc-backref" href="#id15">What is privatization?</a><a class="headerlink" href="#what-is-privatization" title="Permalink to this headline">¶</a></h3>
<p>Privatization of an object <code class="docutils literal notranslate"><span class="pre">X</span></code> means providing a local copy of <code class="docutils literal notranslate"><span class="pre">X</span></code> on
each locale. Such a copy is called the “privatized copy”.
On <code class="docutils literal notranslate"><span class="pre">X.locale</span></code>, <code class="docutils literal notranslate"><span class="pre">X</span></code> itself serves as the privatized copy.
We refer to <code class="docutils literal notranslate"><span class="pre">X</span></code> as the “original object”.</p>
<p>Privatization aims at reducing communication between locales.
When <code class="docutils literal notranslate"><span class="pre">X</span></code> needs to be accessed (by reading its fields or invoking
its methods) from another locale, its privatized copy
on the current locale is used instead.
Therefore, communication to <code class="docutils literal notranslate"><span class="pre">X.locale</span></code> is eliminated.</p>
</div>
<div class="section" id="how-does-privatization-work-with-dsi">
<h3><a class="toc-backref" href="#id16">How does privatization work with DSI?</a><a class="headerlink" href="#how-does-privatization-work-with-dsi" title="Permalink to this headline">¶</a></h3>
<p>Privatization is optional in DSI. Each of the global descriptor classes
can support privatization independently of the others. A class indicates
to the Chapel implementation whether it supports privatization via
its method <code class="docutils literal notranslate"><span class="pre">dsiSupportsPrivatization()</span></code> (see below).</p>
<p>Layouts (i.e. the domain maps that do not distribute domains across locales)
can potentially benefit from privatization. However, the standard
layouts do not support it.</p>
<p>The remainder of DSI privatization requirements must be implemented
by each global descriptor class that chooses to support privatization.</p>
<p>The domain map implementation must provide methods to:</p>
<ul class="simple">
<li>create a privatized copy given the original object, and</li>
<li>update a privatized copy when some other privatized copy changes
(see “reprivatization” below).</li>
</ul>
<p>The Chapel implementation:</p>
<ul class="simple">
<li>invokes DSI privatization methods to create or update privatized copies, and</li>
<li>redirects original object accesses to its privatized copies.</li>
</ul>
<p>The Chapel implementation creates privatized copies (over <em>all</em> locales)
greedily as follows (if that class supports privatization):</p>
<ul class="simple">
<li>of a <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> - when it is wrapped in <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">dmap()</span></code>
and when that wrapper is copied;</li>
<li>of a <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> or <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> - when the corresponding
Chapel domain or array is created.</li>
</ul>
</div>
<div class="section" id="what-is-reprivatization">
<h3><a class="toc-backref" href="#id17">What is reprivatization?</a><a class="headerlink" href="#what-is-reprivatization" title="Permalink to this headline">¶</a></h3>
<p>Should any privatized copy be modified, the changes need to be
propagated to all the other privatized copies.
This propagation is called reprivatization.</p>
<p>The domain map implementation provides methods to update a privatized copy.
The Chapel implementation invokes these methods when necessary.</p>
</div>
<div class="section" id="dsi-privatization-requirements">
<h3><a class="toc-backref" href="#id18">DSI privatization requirements</a><a class="headerlink" href="#dsi-privatization-requirements" title="Permalink to this headline">¶</a></h3>
<p>The following requirements apply individually to each global descriptor
class that chooses to support privatization.
<code class="docutils literal notranslate"><span class="pre">Global</span></code> denotes such a class.</p>
<dl class="method">
<dt>
<code class="descname">proc Global.dsiSupportsPrivatization() param return true;</code></dt>
<dd><p>Returns <cite>true</cite> to indicate that privatization is supported.
NOTE: do not specify the return type (due to a bug in the compiler).</p>
</dd></dl>

<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Global</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
  <span class="kd">var</span> <span class="nx">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field <code class="docutils literal notranslate"><span class="pre">pid</span></code> should be provided as shown.
It should not be accessed by the DSI implementation except
in conjunction with <code class="docutils literal notranslate"><span class="pre">chpl_getPrivatizedCopy()</span></code> as discussed later.</p>
<dl class="method">
<dt>
<code class="descname">proc Global.dsiGetPrivatizeData()</code></dt>
<dd><p>Returns the data to be used as the argument to <code class="docutils literal notranslate"><span class="pre">dsiPrivatize()</span></code>.
It can be a tuple of values or any other type, at the implementor’s
discretion. See <code class="docutils literal notranslate"><span class="pre">dsiPrivatize()</span></code> for explanation.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiPrivatize(privatizeData): Global</code></dt>
<dd><p>Returns a privatized copy of <cite>this</cite>. The Chapel implementation
invokes this method as follows:</p>
<ul class="simple">
<li>on the locale where the privatized copy is to be located,</li>
<li><cite>this</cite> is either the original object or its privatized copy
created by <code class="docutils literal notranslate"><span class="pre">dsiPrivatize</span></code> on some other locale,</li>
<li><code class="docutils literal notranslate"><span class="pre">privatizeData</span></code> is the result of invoking dsiGetPrivatizeData()
on the original object.</li>
</ul>
<p>Typically <code class="docutils literal notranslate"><span class="pre">dsiPrivatize()</span></code> will need to copy and/or privatize
some information from the original object into the privatized copy
being created. This information could be obtained by querying <cite>this</cite>
directly. Alternatively, it could be passed from the original object
via <code class="docutils literal notranslate"><span class="pre">privatizeData</span></code>. This approach could allow the needed information
to be bundled into the original active message, rather than requiring
additional communications when accessing <cite>this</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiGetReprivatizeData()</code></dt>
<dd><p>Similar do <code class="docutils literal notranslate"><span class="pre">dsiGetPrivatizeData()</span></code>, except the result is used
as the argument to <code class="docutils literal notranslate"><span class="pre">dsiReprivatize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc Global.dsiReprivatize(other: Global, reprivatizeData): void</code></dt>
<dd><p>Updates a privatized copy.</p>
<p><cite>this</cite> is the object to be updated as part of reprivatization.</p>
<p><code class="docutils literal notranslate"><span class="pre">other</span></code> is either the object whose modification originally
necessitated reprivatization or one of the privatized copies
that have already been updated for that modification
by <code class="docutils literal notranslate"><span class="pre">dsiReprivatize()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">reprivatizeData</span></code> is the result of invoking dsiGetReprivatizeData()
on the originally-modified object.</p>
<p>Q: What modifications must <code class="docutils literal notranslate"><span class="pre">dsiReprivatize()</span></code> reflect?</p>
<p>A: Any changes that the domain map implementation may perform on
an instance of <code class="docutils literal notranslate"><span class="pre">Global</span></code> (or its privatized copy) after that instance
has been created and privatized.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">GlobalDomain.dsiReprivatize()</span></code> must reflect any changes
that <code class="docutils literal notranslate"><span class="pre">GlobalDomain.dsiSetIndices()</span></code> may perform.</p>
</dd></dl>

</div>
<div class="section" id="tip-testing-privatization">
<h3><a class="toc-backref" href="#id19">Tip: testing privatization</a><a class="headerlink" href="#tip-testing-privatization" title="Permalink to this headline">¶</a></h3>
<p>In addition to the usual correctness testing, it may be useful to check
whether array access is purely local, i.e., results in no communication.
This can be done using <cite>local</cite> statements.</p>
<p>(A <cite>local</cite> statement performs runtime checks that report an error
whenever any communication occurs within the its body.)</p>
<p>Here is a simple example:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// declare an array that uses the domain map to be tested</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="o">..</span><span class="p">.;</span>

<span class="c1">// initialize it</span>
<span class="nx">A</span> <span class="o">=</span> <span class="nx">value1</span><span class="p">;</span>

<span class="k">forall</span> <span class="nx">loc</span> <span class="kd">in</span> <span class="p">(</span><span class="nx">locales</span> <span class="nx">that</span> <span class="nx">A</span> <span class="nx">is</span> <span class="nx">distributed</span> <span class="nx">over</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1">// run the check on each locale</span>
  <span class="k">on</span> <span class="nx">loc</span> <span class="p">{</span>
    <span class="c1">// value2 to be different from value1</span>
    <span class="kd">var</span> <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">value2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">idxTemp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">an</span> <span class="k">index</span> <span class="p">(</span><span class="nx">tuple</span><span class="p">)</span> <span class="nx">that</span> <span class="nx">is</span> <span class="nx">mapped</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">locale</span> <span class="s">&#39;loc&#39;</span><span class="p">);</span>
    <span class="k">local</span> <span class="p">{</span>
      <span class="c1">// Access the array.</span>
      <span class="c1">// This statement succeeds if there is no communication.</span>
      <span class="nx">valTemp</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">idxTemp</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// reference the read value</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">valTemp</span> <span class="o">==</span> <span class="nx">value1</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatized-copies-should-reference-privatized-copies">
<h3><a class="toc-backref" href="#id20">Tip: privatized copies should reference privatized copies</a><a class="headerlink" href="#tip-privatized-copies-should-reference-privatized-copies" title="Permalink to this headline">¶</a></h3>
<p>The global descriptor classes are required to reference each other
(e.g. <code class="docutils literal notranslate"><span class="pre">GlobalArray.dom</span></code> references <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>; <code class="docutils literal notranslate"><span class="pre">GlobalDomain.dist</span></code>
references <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code>). Therefore, if it is desired to
eliminate communication completely upon array references,
all the three global descriptor classes may have to be privatized.
When one descriptor object references another, a privatized copy of
the former needs to reference a privatized copy of the latter.</p>
<p>To obtain a privatized copy of an object, e.g. for use within
<code class="docutils literal notranslate"><span class="pre">dsiPrivatize()</span></code>, use the following procedure:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">objectType</span><span class="p">,</span> <span class="nx">objectPid</span><span class="p">:</span><span class="kt">int</span><span class="p">):</span> <span class="nx">objectType</span>
</pre></div>
</div>
</div></blockquote>
<p>Notes:</p>
<ul class="simple">
<li>The first argument is type of the object being privatized.</li>
<li>The second argument is the original object’s <code class="docutils literal notranslate"><span class="pre">pid</span></code> field.</li>
<li>The procedure returns a privatized copy of the original object.</li>
<li>The procedure can be applied only to objects that have already
been privatized.<ul>
<li>A <code class="docutils literal notranslate"><span class="pre">GlobalArray</span></code> is privatized after its <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>, which is
privatized after its <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code>.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> field is set to a different value than <code class="docutils literal notranslate"><span class="pre">-1</span></code>
when an object is privatized.</li>
</ul>
</li>
</ul>
<p>Here is an example of using it for privatizing <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>,
assuming that <code class="docutils literal notranslate"><span class="pre">GlobalDistribution</span></code> also supports privatization:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">GlobalDomain.dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// include the desired &#39;pid&#39;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">data</span> <span class="k">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain.dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// extract the &#39;pid&#39; provided above</span>
  <span class="kd">const</span> <span class="nx">distPid</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// obtain the privatized copy of the GlobalDistribution object</span>
  <span class="kd">const</span> <span class="nx">privatizedDMap</span> <span class="o">=</span> <span class="nx">chpl_getPrivatizedCopy</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="kd">type</span><span class="p">,</span> <span class="nx">distPid</span><span class="p">);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="nx">dist</span> <span class="o">=</span> <span class="nx">privatizedDMap</span><span class="p">,</span>
                          <span class="o">..</span><span class="p">.</span> <span class="nx">other</span> <span class="nx">fields</span> <span class="k">as</span> <span class="nx">needed</span> <span class="o">..</span><span class="p">.)</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tip-privatize-the-domains-and-arrays-used-in-the-implementation">
<h3><a class="toc-backref" href="#id21">Tip: “privatize” the domains and arrays used in the implementation</a><a class="headerlink" href="#tip-privatize-the-domains-and-arrays-used-in-the-implementation" title="Permalink to this headline">¶</a></h3>
<p>If a global descriptor class to be privatized uses domains and arrays,
those need to be “privatized”, too, to reduce communication. In the
case of domains and arrays mapped using the default layout,
their “privatization” is achieved by copying.</p>
<p>Careful consideration is needed to eliminate all communication.
For example:</p>
<ul class="simple">
<li>Copying an array preserves the source’s domain - unless
the destination’s domain is declared explicitly.</li>
<li>Copying a domain preserves the source’s domain map - unless
the destination’s type is declared explicitly.</li>
<li>If an array’s domain or a domain’s domain map is declared explicitly,
ensure that privatized copies of those are used.</li>
<li>There is no need to privatize the default layout.
Specifically, copying a domain declared without an explicit domain map
is sufficient to privatize that domain.</li>
<li>The same considerations are valid for reprivatization.</li>
</ul>
<p>Here is an example of “privatizing” domains/arrays within <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code>.
The key insight here is that <code class="docutils literal notranslate"><span class="pre">auxArrayG</span></code>’s domain needs to be “privatized”.
Cf. the domains of <code class="docutils literal notranslate"><span class="pre">auxArrayED1</span></code> and <code class="docutils literal notranslate"><span class="pre">auxArrayED2</span></code> are created
implicitly for each <code class="docutils literal notranslate"><span class="pre">GlobalDomain</span></code> object and so will be local in any case.</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GlobalDomain</span> <span class="o">..</span><span class="p">.</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>

  <span class="c1">// this field is generic</span>
  <span class="kd">var</span> <span class="nx">auxArrayG</span><span class="p">;</span>

  <span class="c1">// domain is specified explicitly</span>
  <span class="kd">var</span> <span class="nx">auxArrayED1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// similar</span>
  <span class="kd">var</span> <span class="nx">auxDomain</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">auxArrayED2</span><span class="p">:</span> <span class="p">[</span><span class="nx">auxDomain</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain.dsiGetPrivatizeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">dist</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="nx">auxArrayG</span><span class="p">,</span>
          <span class="nx">auxArrayED1</span><span class="p">,</span> <span class="nx">auxDomain</span><span class="p">,</span> <span class="nx">auxArrayED2</span><span class="p">,</span> <span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">GlobalDomain.dsiPrivatize</span><span class="p">(</span><span class="nx">privatizeData</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// To privatize auxArrayG, we must &quot;privatize&quot; its domain first.</span>
  <span class="c1">// No need to declare privDom&#39;s type if auxArrayG uses the default layout.</span>
  <span class="kd">var</span> <span class="nx">privDom</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="k">domain</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">privArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">privDom</span><span class="p">]</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">eltType</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="c1">// If the following were used, privArr.domain would be the same</span>
  <span class="c1">// as privatizeData(2).domain, i.e., it would not be privatized.</span>
  <span class="c1">//var privArr = privatizeData(2);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nx">GlobalDomain</span><span class="p">(</span><span class="o">..</span><span class="p">.,</span> <span class="nx">auxArrayG</span> <span class="o">=</span> <span class="nx">privArr</span><span class="p">,</span>
    <span class="c1">// the other fields can be simply copied</span>
    <span class="nx">auxArrayED1</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
    <span class="nx">auxDomain</span>   <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
    <span class="nx">auxArrayED2</span> <span class="o">=</span> <span class="nx">privatizeData</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>

<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="phase-4-bulk-transfer-interface">
<h2><a class="toc-backref" href="#id22">Phase 4: Bulk-Transfer Interface</a><a class="headerlink" href="#phase-4-bulk-transfer-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-the-bulk-transfer-interface">
<h3><a class="toc-backref" href="#id23">What is the bulk-transfer interface?</a><a class="headerlink" href="#what-is-the-bulk-transfer-interface" title="Permalink to this headline">¶</a></h3>
<p>While the Chapel language does not require a specific implementation for array
assignment, in practice the values are assigned individually:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">[</span><span class="nx">all</span><span class="p">]</span> <span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="nx">dest</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">d</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>When assignment occurs between arrays on different locales, this can result in
significant communication overhead. The bulk-transfer interface aims at
reducing communication between locales by enabling domain maps to handle
certain kinds of assignments themselves.</p>
</div>
<div class="section" id="how-does-the-bulk-transfer-interface-work-with-dsi">
<h3><a class="toc-backref" href="#id24">How does the bulk-transfer interface work with DSI?</a><a class="headerlink" href="#how-does-the-bulk-transfer-interface-work-with-dsi" title="Permalink to this headline">¶</a></h3>
<p>The bulk-transfer interface is an optional interface supported only on array
descriptors. The following methods are prefixed with <code class="docutils literal notranslate"><span class="pre">doi</span></code> for “Domain map
Optional Interface.” An array descriptor can implement one or more of these
methods to opt-in to support for bulk-transfers:</p>
<dl class="method">
<dt>
<code class="descname">proc GlobalArray.doiBulkTransferToKnown(myDom:domain, otherClass, otherDom:domain) : bool</code></dt>
<dd><p>Perform an array assignment from <code class="docutils literal notranslate"><span class="pre">this</span></code> to <code class="docutils literal notranslate"><span class="pre">otherClass</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.doiBulkTransferFromKnown(myDom:domain, otherClass, otherDom:domain) : bool</code></dt>
<dd><p>Perform an array assignment from <code class="docutils literal notranslate"><span class="pre">otherClass</span></code> to <code class="docutils literal notranslate"><span class="pre">this</span></code></p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.doiBulkTransferToAny(myDom:domain, otherClass, otherDom:domain) : bool</code></dt>
<dd><p>Perform an array assignment from <code class="docutils literal notranslate"><span class="pre">this</span></code> to <code class="docutils literal notranslate"><span class="pre">otherClass</span></code>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">proc GlobalArray.doiBulkTransferFromAny(myDom:domain, otherClass, otherDom:domain) : bool</code></dt>
<dd><p>Perform an array assignment from <code class="docutils literal notranslate"><span class="pre">otherClass</span></code> to <code class="docutils literal notranslate"><span class="pre">this</span></code></p>
</dd></dl>

<p>Each method shares these arguments:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">myDom:domain</span></code> - the indices to be transferred to/from <code class="docutils literal notranslate"><span class="pre">this</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">otherClass</span></code> - a class inheriting from <code class="docutils literal notranslate"><span class="pre">BaseArr</span></code> that represents the
other array in the assignment</li>
<li><code class="docutils literal notranslate"><span class="pre">otherDom:domain</span></code> - the indices to be transferred to/from <code class="docutils literal notranslate"><span class="pre">otherClass</span></code></li>
</ul>
<p>Callers of these methods must satisfy the following guarantees for these
arguments:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">this.rank</span> <span class="pre">==</span> <span class="pre">myDom.rank</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">otherClass.rank</span> <span class="pre">==</span> <span class="pre">otherDom.rank</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">myDom.size</span> <span class="pre">==</span> <span class="pre">otherDom.size</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">myDom</span></code> and <code class="docutils literal notranslate"><span class="pre">otherDom</span></code> are not required to be distributed, even if the
corresponding arrays are distributed. They simply represent the indices
involved in the transfer.</p>
</div>
<p>Each method returns a <code class="docutils literal notranslate"><span class="pre">bool</span></code> indicating whether the assignment occurred. This
allows domain maps to resort to the Chapel implementation of array assignment
if they are incapable or unwilling to perform the assignment themselves.</p>
</div>
<div class="section" id="known-and-any-methods">
<h3><a class="toc-backref" href="#id25">Known and Any methods</a><a class="headerlink" href="#known-and-any-methods" title="Permalink to this headline">¶</a></h3>
<p>There are two kinds of transfers accounted for in this interface.</p>
<p>The first kind of transfer is a <code class="docutils literal notranslate"><span class="pre">Known</span></code> transfer. These are transfers that
the implementer believes to be optimal. Typically this means that the
implementer knows the type and internals of the other domain map involved in
the transfer.</p>
<p>The second kind of transfer is an <code class="docutils literal notranslate"><span class="pre">Any</span></code> transfer. These are transfers to/from
domain maps whose type and internals are <strong>not</strong> known. These transfers
typically rely on attempting to have the unknown domain map transfer to/from
the internal data of the domain map on which the method is implemented. See
<a class="reference internal" href="#implementing-any-methods">Implementing ‘Any’ Methods</a> for more detail.</p>
<p>This interface recognizes these kinds of transfers because otherwise it is
difficult to determine which distribution implements the best transfer.</p>
<p>For example, the author of <code class="docutils literal notranslate"><span class="pre">PopularDist</span></code> could implement <code class="docutils literal notranslate"><span class="pre">Any</span></code> methods for
better performance with unknown third-party domain maps. The author of
<code class="docutils literal notranslate"><span class="pre">NewDist</span></code> could implement <code class="docutils literal notranslate"><span class="pre">Known</span></code> methods to <code class="docutils literal notranslate"><span class="pre">PopularDist</span></code> due to its
popularity. By doing so the author of <code class="docutils literal notranslate"><span class="pre">NewDist</span></code> has informed Chapel that it
knows better than <code class="docutils literal notranslate"><span class="pre">PopularDist</span></code> and a more optimal transfer occurs.</p>
<p>Chapel will call <code class="docutils literal notranslate"><span class="pre">Known</span></code> methods before <code class="docutils literal notranslate"><span class="pre">Any</span></code> methods if they can be
resolved. A recommended convention is to implement <code class="docutils literal notranslate"><span class="pre">Known</span></code> methods with a
where-clause that constrains the type of the <code class="docutils literal notranslate"><span class="pre">otherClass</span></code> argument. This
prevents the <code class="docutils literal notranslate"><span class="pre">Known</span></code> method from being called with unknown types.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is no defined preference for <code class="docutils literal notranslate"><span class="pre">To</span></code> and <code class="docutils literal notranslate"><span class="pre">From</span></code> methods. Domain map
authors should not currently rely on a particular direction being attempted
first.</p>
</div>
</div>
<div class="section" id="when-does-a-bulk-transfer-occur">
<h3><a class="toc-backref" href="#id26">When Does a Bulk-Transfer Occur?</a><a class="headerlink" href="#when-does-a-bulk-transfer-occur" title="Permalink to this headline">¶</a></h3>
<p>There are a number of conditions that need to be true for a bulk-transfer to
occur:</p>
<ul>
<li><p class="first">The config param <code class="docutils literal notranslate"><span class="pre">useBulkTransfer</span></code> must be true</p>
</li>
<li><p class="first">The element types of the arrays must be identical</p>
</li>
<li><p class="first">The element type must be one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">integral</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">real</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">complex</span></code></li>
<li>records or tuples that are “Plain Old Data”</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>The element type is restricted in order to preserve copy semantics of each
element. For example, <code class="docutils literal notranslate"><span class="pre">integral</span></code> types can be bit-copied and so have no
side-effects. A record with a copy-initializer may have side effects that
should not be eliminated by the bulk-transfer optimization. In order to avoid
eliminating these side-effects, only records or tuples that are “Plain Old
Data” are considered valid for bulk-transfers. The (currently undocumented)
function <code class="docutils literal notranslate"><span class="pre">isPODType(t)</span></code> returns a param boolean indicating whether the given
type is “Plain Old Data”.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">useBulkTransfer</span></code> config param is <code class="docutils literal notranslate"><span class="pre">true</span></code> by default but can be disabled
at compilation time. For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>chpl myProgram.chpl -suseBulkTransfer<span class="o">=</span><span class="nb">false</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-any-methods">
<h3><a class="toc-backref" href="#id27">Implementing ‘Any’ Methods</a><a class="headerlink" href="#implementing-any-methods" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#known-and-any-methods">Any</a> methods are generally implemented by
transferring data of an internal type of <code class="docutils literal notranslate"><span class="pre">this</span></code> to/from a subset of indices
in <code class="docutils literal notranslate"><span class="pre">otherClass</span></code>. For example, a distribution can be implemented in terms of
Chapel’s default rectangular arrays. An <code class="docutils literal notranslate"><span class="pre">Any</span></code> method on that distribution
could be implemented by attempting to transfer data to/from <code class="docutils literal notranslate"><span class="pre">otherClass</span></code> to
a default rectangular array, like so (in pseudo-chapel):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// For a single locale&#39;s data
var localDom = localData.domain[myDom]; // local subset of indices for ``this``
var locOther = &lt;translate localDom to otherDom&#39;s coordinates&gt;;
otherClass.doiBulkTransfer[To|From][Any|Known](locOther, localData, localDom);
</pre></div>
</div>
<p>Implementers who call these <code class="docutils literal notranslate"><span class="pre">doiBulkTransfer</span></code> methods should note that they
can return <code class="docutils literal notranslate"><span class="pre">false</span></code>, meaning the caller needs to complete the transfer.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Beware of implementing bulk-transfers by manually calling other
<code class="docutils literal notranslate"><span class="pre">doiBulkTransfer</span></code> methods. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">GlobalArray.doiBulkTransferFromAny</span><span class="p">(</span><span class="nx">myDom</span><span class="p">:</span><span class="k">domain</span><span class="p">,</span> <span class="nx">otherClass</span><span class="p">,</span> <span class="nx">otherDom</span><span class="p">:</span><span class="k">domain</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">otherClass</span><span class="p">.</span><span class="nx">doiBulkTransferToAny</span><span class="p">(</span><span class="nx">otherDom</span><span class="p">,</span> <span class="nx">this</span><span class="p">,</span> <span class="nx">myDom</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">This pattern can lead to potential recursion depending on the implementation
of the other domain map’s bulk-transfer method. Instead of implementing the
example method above, the author could have not implemented it at all and
let the Chapel internals invoke the <code class="docutils literal notranslate"><span class="pre">doiBulkTransferToAny</span></code> directly.</p>
</div>
</div>
<div class="section" id="transfers-for-aliasing-domain-maps">
<h3><a class="toc-backref" href="#id28">Transfers for Aliasing Domain Maps</a><a class="headerlink" href="#transfers-for-aliasing-domain-maps" title="Permalink to this headline">¶</a></h3>
<p>It is valid to write a domain map that aliases another domain map’s data. For
example, a user could write their own variant of a Chapel array slice in terms
of the Domain Map Standard Interface.</p>
<p>When aliasing other domain maps it is recommended to only implement <a class="reference internal" href="#known-and-any-methods">Known</a>
transfers that forward to the underlying domain map’s bulk-transfer methods.
By implementing <a class="reference internal" href="#known-and-any-methods">Known</a> transfers the underlying domain map will have a
chance to perform a more optimal transfer before the <a class="reference internal" href="#known-and-any-methods">Any</a> transfers are
attempted.</p>
</div>
<div class="section" id="transfers-for-rank-changes">
<h3><a class="toc-backref" href="#id29">Transfers for Rank-changes</a><a class="headerlink" href="#transfers-for-rank-changes" title="Permalink to this headline">¶</a></h3>
<p>Implementing a bulk-transfer when rank-changed can be tricky. In the interest
of simplicity, Chapel by default will not attempt to call bulk-transfer methods
on arrays that have been rank-changed.</p>
<p>Domain map authors can opt-in to handling rank changes by implementing the
following method:</p>
<dl class="method">
<dt>
<code class="descname">proc GlobalArray.doiCanBulkTransferRankChange() param : bool</code></dt>
<dd></dd></dl>

<p>If this method is resolvable and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> then Chapel will attempt
to call bulk-transfer methods on the array.</p>
<p>Domain map authors should note that this means that <code class="docutils literal notranslate"><span class="pre">this.rank</span></code> may not be
equal to <code class="docutils literal notranslate"><span class="pre">otherClass.rank</span></code> when rank-changes are involved. They should also
note that while <code class="docutils literal notranslate"><span class="pre">myDom</span></code> and <code class="docutils literal notranslate"><span class="pre">otherDom</span></code> are of the same size, their
dimensions may not match in size. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">B</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">A</span><span class="p">[</span><span class="o">..</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">..</span><span class="p">];</span>
</pre></div>
</div>
<p>The call to a bulk-transfer method could look like:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">classA</span><span class="p">.</span><span class="nx">doiBulkTransferFromKnown</span><span class="p">({</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">1</span><span class="p">},</span> <span class="nx">classB</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">});</span>
</pre></div>
</div>
<p>The implementer of this method is left with the task of determining which
dimensions were rank-changed.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="errorHandling.html" class="btn btn-neutral float-right" title="Error Handling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="atomics.html" class="btn btn-neutral float-left" title="Runtime Support for Atomics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>