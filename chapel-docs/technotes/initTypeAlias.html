

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Invoking Initializers with a Generic Instantiation &mdash; Chapel Documentation 1.23</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The ‘init=’ Method" href="initequals.html" />
    <link rel="prev" title="Global Variables" href="globalvars.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.23
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.23";
$pagename = "technotes/initTypeAlias";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="allocators.html">Chapel’s Use of Allocators</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Runtime Support for Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsi.html">Domain Map Standard Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="errorHandling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="extern.html">C Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="firstClassFns.html">First-class Functions in Chapel</a></li>
<li class="toctree-l2"><a class="reference internal" href="fortranInterop.html">Fortran Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="forwarding.html">Forwarding Methods Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="globalvars.html">Global Variables</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Invoking Initializers with a Generic Instantiation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-experimental-solution-using-named-expressions">An Experimental Solution: Using Named Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-initialization-for-instantiated-generic-types">Default Initialization for Instantiated Generic Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations-and-future-work">Limitations and Future Work</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="initequals.html">The ‘init=’ Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="libraries.html">Exporting Chapel as a Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lifetimeChecking.html">Lifetime Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="llvm.html">LLVM Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="local.html">The ‘local’ keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="localeModels.html">Locale Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="main.html">Support for main() Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_include.html">Including Sub-Modules from Separate Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_search.html">Module Search Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="nilChecking.html">Checking for Nil Dereferences</a></li>
<li class="toctree-l2"><a class="reference internal" href="overloadSets.html">Checking Overload Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="partialInstantiations.html">Partial Instantiations</a></li>
<li class="toctree-l2"><a class="reference internal" href="reduceIntents.html">Reduce Intents</a></li>
<li class="toctree-l2"><a class="reference internal" href="sets.html">Associative Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="subquery.html">Querying a Local Subdomain</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Technical Notes</a> &raquo;</li>
        
      <li>Invoking Initializers with a Generic Instantiation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/technotes/initTypeAlias.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="invoking-initializers-with-a-generic-instantiation">
<span id="readme-inittypealias"></span><h1>Invoking Initializers with a Generic Instantiation<a class="headerlink" href="#invoking-initializers-with-a-generic-instantiation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Initializing a variable with a generic type has historically required users to
pass each <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">param</span></code> value to the initializer as arguments. This
can be a tedious and repetitive process if the user is initializing many
variables of the exact same type. One might wish to use type aliases to reduce
the repetitive nature of initializing the same type many times. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Map</span> <span class="p">{</span> <span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">;</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="o">..</span><span class="p">.);</span>

<span class="c1">// vs.</span>

<span class="kd">type</span> <span class="nx">StringMap</span> <span class="o">=</span> <span class="nx">Map</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StringMap</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
</pre></div>
</div>
<p>This document describes an experimental solution to this problem that unifies
the invocation of default-initialization and these kinds of new-expressions.</p>
</div>
<div class="section" id="an-experimental-solution-using-named-expressions">
<h2>An Experimental Solution: Using Named Expressions<a class="headerlink" href="#an-experimental-solution-using-named-expressions" title="Permalink to this headline">¶</a></h2>
<p>A solution to this problem is for the compiler to generate named-expression
arguments for each instantiated field in the type alias. This means that if the
author of a type wishes to support this pattern, they need to implement an
initializer with arguments that have the same name as the generic fields of the
type. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// must be named &#39;T&#39;</span>
<span class="k">proc</span> <span class="nf">R.init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">RI</span> <span class="o">=</span> <span class="nx">R</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RI</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// becomes...</span>
<span class="c1">//   var x = new R(T=int, 5);</span>
</pre></div>
</div>
<p>The use of named-expressions is a trade-off between flexibility of argument
names and flexibility of argument ordering. Consider the following record with
<code class="docutils literal notranslate"><span class="pre">type</span></code> fields that are declared adjacent to the fields they constrain:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">U</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">U</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// mimics compiler-generated signature</span>
<span class="c1">// proc R.init(type T, x : T, type U, y : U) { ... }</span>
</pre></div>
</div>
<p>Without named-expressions, the instantiation information would need to be
passed as the first arguments of the initializer. This would prevent usage
of the compiler-generated initializer for types like <code class="docutils literal notranslate"><span class="pre">R</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">RIS</span> <span class="o">=</span> <span class="nx">R</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RIS</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="c1">// without named-expressions, compiler  cannot match</span>
<span class="c1">// (type, type, value, value) to (type, value, type, value)</span>
<span class="c1">//   var x = new R(int, string, 5, &quot;hello&quot;);</span>
</pre></div>
</div>
<p>By prioritizing flexibility of argument ordering, type authors may order their
fields as they wish and can still take advantage of the compiler-generated
initializer when using type aliases:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">RIS</span> <span class="o">=</span> <span class="nx">R</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RIS</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="c1">// becomes...</span>
<span class="c1">//   var y = new R(T=int, U=string, 5, &quot;hello&quot;);</span>
</pre></div>
</div>
</div>
<div class="section" id="default-initialization-for-instantiated-generic-types">
<h2>Default Initialization for Instantiated Generic Types<a class="headerlink" href="#default-initialization-for-instantiated-generic-types" title="Permalink to this headline">¶</a></h2>
<p>When a variable with a record type is declared without an initialization
expression, the compiler “default-initializes” the variable. For non-generic
types, this is as simple as invoking an initializer without arguments.</p>
<p>Historically the situation for generic types has been more complicated. When
the compiler knew it was invoking a compiler-generated initializer it would use
named-expressions to pass generic instantiation information. When invoking a
user-defined initializer it would simply pass the instantiation arguments
in-order. This allowed user-defined initializers to use arbitrary names for
their arguments, but enforced a specific ordering of those arguments. For
example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// In Chapel 1.18 ...</span>

<span class="k">record</span> <span class="nc">CompilerGenerated</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">U</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">U</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">record</span> <span class="nc">UserDefined</span> <span class="p">{</span>
  <span class="c1">// fields identical to CompilerGenerated</span>

  <span class="c1">// arguments can have any name, but the &#39;type&#39; arguments need to be first</span>
  <span class="k">proc</span> <span class="nf">UserDefined.init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">FirstType</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">SecondType</span><span class="p">,</span> <span class="o">..</span><span class="p">.)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">CompilerGenerated</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span> <span class="c1">// x.init(T=int, U=string);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">UserDefined</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span> <span class="c1">// y.init(int, string);</span>
</pre></div>
</div>
<p>In the Chapel 1.19 release default-initializing a variable with a generic type
will always invoke the initializer with named-expressions. This has the benefit
of allowing the same initializer to be used for default-initialization and for
new-expressions with a type alias. This is also a simpler rule for users to
remember. Our previous example now requires the user-defined initializer to use
specific names for its arguments:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// fields are now allowed to be in any order, but need specific names</span>
<span class="k">proc</span> <span class="nf">UserDefined.init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">U</span><span class="p">,</span> <span class="o">..</span><span class="p">.)</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="nx">CompilerGenerated</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span> <span class="c1">// x.init(T=int, U=string);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="nx">UserDefined</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span> <span class="c1">// y.init(T=int, U=string);</span>
</pre></div>
</div>
<p>Some pre-existing user-defined initializers will require updating, trading
flexibility in argument naming for flexibility in argument ordering.</p>
</div>
<div class="section" id="limitations-and-future-work">
<h2>Limitations and Future Work<a class="headerlink" href="#limitations-and-future-work" title="Permalink to this headline">¶</a></h2>
<p>Fully-generic fields, like <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x;</span></code>, present a design challenge when using
a type alias in a new-expression. The compiler-generated initializer, and most
user-defined initializers, expect a value - not a <code class="docutils literal notranslate"><span class="pre">type</span></code>. It remains an
open question as to how the compiler should invoke such initializers.</p>
<p>In the Chapel 1.19 release this design challenge was not solved and so types
with fully-generic fields may not be used as type aliases in new-expressions.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="initequals.html" class="btn btn-neutral float-right" title="The ‘init=’ Method" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="globalvars.html" class="btn btn-neutral float-left" title="Global Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>