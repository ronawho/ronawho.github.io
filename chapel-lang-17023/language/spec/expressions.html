

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Expressions &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Statements" href="statements.html" />
    <link rel="prev" title="Conversions" href="conversions.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/expressions";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#literal-expressions">Literal Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-expressions">Variable Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enumeration-constant-expression">Enumeration Constant Expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parenthesized-expressions">Parenthesized Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call-expressions">Call Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indexing-expressions">Indexing Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#member-access-expressions">Member Access Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-query-expression">The Query Expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casts">Casts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lvalue-expressions">LValue Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#precedence-and-associativity">Precedence and Associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-expressions">Operator Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-operators">Arithmetic Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unary-plus-operators">Unary Plus Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unary-minus-operators">Unary Minus Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addition-operators">Addition Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subtraction-operators">Subtraction Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiplication-operators">Multiplication Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#division-operators">Division Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modulus-operators">Modulus Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exponentiation-operators">Exponentiation Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bitwise-operators">Bitwise Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bitwise-complement-operators">Bitwise Complement Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitwise-and-operators">Bitwise And Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitwise-or-operators">Bitwise Or Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitwise-xor-operators">Bitwise Xor Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shift-operators">Shift Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-operators">Logical Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-logical-negation-operator">The Logical Negation Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-logical-and-operator">The Logical And Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-logical-or-operator">The Logical Or Operator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#relational-operators">Relational Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ordered-comparison-operators">Ordered Comparison Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality-comparison-operators">Equality Comparison Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#class-operators">Class Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-operators">Miscellaneous Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-string-concatenation-operator">The String Concatenation Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-by-operator">The By Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-align-operator">The Align Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-range-count-operator">The Range Count Operator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#let-expressions">Let Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conditional-expressions">Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#for-expressions">For Expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#filtering-predicates-in-for-expressions">Filtering Predicates in For Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Expressions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/expressions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="expressions">
<span id="chapter-expressions"></span><h1>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h1>
<p>Chapel provides the following expressions:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>expression:
  literal-expression
  variable-expression
  enum-constant-expression
  call-expression
  type-expression
  iteratable-call-expression
  member-access-expression
  new-expression
  query-expression
  cast-expression
  lvalue-expression
  parenthesized-expression
  unary-expression
  binary-expression
  let-expression
  if-expression
  for-expression
  forall-expression
  reduce-expression
  scan-expression
  module-access-expression
  tuple-expression
  tuple-expand-expression
  locale-query-expression
  type-query-expression
  mapped-domain-expression
</pre></div>
</div>
<p>Individual expressions are defined in the remainder of this chapter and
additionally as follows:</p>
<ul class="simple">
<li><p>forall, reduce, and scan
<a class="reference internal" href="data-parallelism.html#chapter-data-parallelism"><span class="std std-ref">Data Parallelism</span></a></p></li>
<li><p>module access <a class="reference internal" href="modules.html#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a></p></li>
<li><p>tuple and tuple expand <a class="reference internal" href="tuples.html#chapter-tuples"><span class="std std-ref">Tuples</span></a></p></li>
<li><p>locale query with <code class="docutils literal notranslate"><span class="pre">.locale</span></code> <a class="reference internal" href="locales.html#querying-the-locale-of-an-expression"><span class="std std-ref">Querying the Locale of an Expression</span></a></p></li>
<li><p>type query with <code class="docutils literal notranslate"><span class="pre">.type</span></code> <a class="reference internal" href="types.html#querying-the-type-of-an-expression"><span class="std std-ref">Querying the Type of an Expression</span></a></p></li>
<li><p>mapped domain <a class="reference internal" href="domain-maps.html#chapter-domain-maps"><span class="std std-ref">Domain Maps</span></a></p></li>
<li><p>initializer calls <a class="reference internal" href="classes.html#class-new"><span class="std std-ref">Class New</span></a></p></li>
</ul>
<div class="section" id="literal-expressions">
<span id="id1"></span><h2>Literal Expressions<a class="headerlink" href="#literal-expressions" title="Permalink to this headline">¶</a></h2>
<p>A literal value for any of the predefined types is a literal expression.</p>
<p>Literal expressions are given by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>literal-expression:
  bool-literal
  integer-literal
  real-literal
  imaginary-literal
  string-literal
  bytes-literal
  range-literal
  domain-literal
  array-literal
</pre></div>
</div>
<p>Literal values for primitive types are described in
<a class="reference internal" href="lexical-structure.html#literals"><span class="std std-ref">Literals</span></a>. Literal
range values are described in <a class="reference internal" href="ranges.html#range-literals"><span class="std std-ref">Range Literals</span></a>. Literal
tuple values are described in <a class="reference internal" href="tuples.html#tuple-values"><span class="std std-ref">Tuple Values</span></a>. Literal
values for domains are described in
<a class="reference internal" href="domains.html#rectangular-domain-values"><span class="std std-ref">Rectangular Domain Values</span></a> and
<a class="reference internal" href="domains.html#associative-domain-values"><span class="std std-ref">Associative Domain Values</span></a>. Literal values for arrays
are described in <a class="reference internal" href="arrays.html#rectangular-array-literals"><span class="std std-ref">Rectangular Array Literals</span></a> and
<a class="reference internal" href="arrays.html#associative-array-literals"><span class="std std-ref">Associative Array Literals</span></a>.</p>
</div>
<div class="section" id="variable-expressions">
<span id="id2"></span><h2>Variable Expressions<a class="headerlink" href="#variable-expressions" title="Permalink to this headline">¶</a></h2>
<p>A use of a variable, constant, parameter, or formal argument, is itself
an expression. The syntax of a variable expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>variable-expression:
  identifier
</pre></div>
</div>
</div>
<div class="section" id="enumeration-constant-expression">
<span id="id3"></span><h2>Enumeration Constant Expression<a class="headerlink" href="#enumeration-constant-expression" title="Permalink to this headline">¶</a></h2>
<p>A use of an enumeration constant is itself an expression. Such a
constant must be preceded by the enumeration type name. The syntax of an
enumeration constant expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>enum-constant-expression:
  enum-type . identifier
</pre></div>
</div>
<p>For an example of using enumeration constants,
see <a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>.</p>
</div>
<div class="section" id="parenthesized-expressions">
<span id="id4"></span><h2>Parenthesized Expressions<a class="headerlink" href="#parenthesized-expressions" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">parenthesized-expression</span></code> is an expression that is delimited by
parentheses as given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>parenthesized-expression:
  ( expression )
</pre></div>
</div>
<p>Such an expression evaluates to the expression. The parentheses are
ignored and have only a syntactical effect.</p>
</div>
<div class="section" id="call-expressions">
<span id="id5"></span><h2>Call Expressions<a class="headerlink" href="#call-expressions" title="Permalink to this headline">¶</a></h2>
<p>Functions and function calls are defined
in <a class="reference internal" href="procedures.html#chapter-procedures"><span class="std std-ref">Procedures</span></a>.</p>
</div>
<div class="section" id="indexing-expressions">
<span id="id6"></span><h2>Indexing Expressions<a class="headerlink" href="#indexing-expressions" title="Permalink to this headline">¶</a></h2>
<p>Indexing, for example into arrays, tuples, and domains, has the same
syntax as a call expression.</p>
<p>Indexing is performed by an implicit invocation of the <code class="docutils literal notranslate"><span class="pre">this</span></code> method
on the value being indexed, passing the indices as the actual arguments.</p>
</div>
<div class="section" id="member-access-expressions">
<span id="id7"></span><h2>Member Access Expressions<a class="headerlink" href="#member-access-expressions" title="Permalink to this headline">¶</a></h2>
<p>Member access expressions provide access to a field or invoke a method
of an instance of a class, record, or union. They are defined in
<a class="reference internal" href="classes.html#class-field-accesses"><span class="std std-ref">Field Accesses</span></a> and
<a class="reference internal" href="classes.html#class-method-calls"><span class="std std-ref">Class Method Calls</span></a>, respectively.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>member-access-expression:
  field-access-expression
  method-call-expression
</pre></div>
</div>
</div>
<div class="section" id="the-query-expression">
<span id="id8"></span><h2>The Query Expression<a class="headerlink" href="#the-query-expression" title="Permalink to this headline">¶</a></h2>
<p>A query expression is used to query a type or value within a formal
argument type expression. The syntax of a query expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>query-expression:
  ? identifier[OPT]
</pre></div>
</div>
<p>Querying is restricted to querying the type of a formal argument, the
element type of a formal argument that is an array, the domain of a
formal argument that is an array, the size of a primitive type, or a
type or parameter field of a formal argument type.</p>
<p>The identifier can be omitted. This is useful for ensuring the
genericity of a generic type that defines default values for all of its
generic fields when specifying a formal argument as discussed
in <a class="reference internal" href="generics.html#formal-arguments-of-generic-type"><span class="std std-ref">Formal Arguments of Generic Type</span></a>.</p>
<blockquote>
<div><p><em>Example (query.chpl)</em>.</p>
<p>The following code defines a generic function where the type of the
first argument is queried and stored in the type alias <code class="docutils literal notranslate"><span class="pre">t</span></code> and the
domain of the second argument is queried and stored in the variable
<code class="docutils literal notranslate"><span class="pre">D</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="p">[?</span><span class="nx">D</span><span class="p">]</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">D</span> <span class="k">do</span>
    <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This allows a generic specification of assigning a particular value
to all elements of an array. The value and the elements of the array
are constrained to be the same type. This function can be rewritten
without query expression as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="p">[]</span> <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">y</span><span class="p">.</span><span class="k">domain</span> <span class="k">do</span>
    <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>There is an expectation that query expressions will be allowed in more
places in the future.</p>
</div>
<div class="section" id="casts">
<span id="id9"></span><h2>Casts<a class="headerlink" href="#casts" title="Permalink to this headline">¶</a></h2>
<p>A cast is specified with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>cast-expression:
  expression : type-expression
</pre></div>
</div>
<p>The expression is converted to the specified type. A cast expression
invokes the corresponding explicit
conversion (<a class="reference internal" href="conversions.html#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>). A resolution error
occurs if no such conversion exists.</p>
</div>
<div class="section" id="lvalue-expressions">
<span id="id10"></span><h2>LValue Expressions<a class="headerlink" href="#lvalue-expressions" title="Permalink to this headline">¶</a></h2>
<p>An <em>lvalue</em> is an expression that can be used on the left-hand side of
an assignment statement or on either side of a swap statement, that can
be passed to a formal argument of a function that has <code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">inout</span></code>
or <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent, or that can be returned by a function with a <code class="docutils literal notranslate"><span class="pre">ref</span></code>
return intent (<a class="reference internal" href="procedures.html#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>). Valid lvalue
expressions include the following:</p>
<ul class="simple">
<li><p>Variable expressions.</p></li>
<li><p>Member access expressions.</p></li>
<li><p>Call expressions of functions with a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent.</p></li>
<li><p>Indexing expressions.</p></li>
</ul>
<p>LValue expressions are given by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>lvalue-expression:
  variable-expression
  member-access-expression
  call-expression
  parenthesized-expression
</pre></div>
</div>
<p>The syntax is less restrictive than the definition above. For example,
not all <code class="docutils literal notranslate"><span class="pre">call-expression</span></code>s are lvalues.</p>
</div>
<div class="section" id="precedence-and-associativity">
<span id="operator-precedence-and-associativity"></span><h2>Precedence and Associativity<a class="headerlink" href="#precedence-and-associativity" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 22%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Associativity</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">.</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">[]</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">member access</div>
<div class="line">function call or access</div>
<div class="line">function call or access</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">new</span></code></p></td>
<td><p>right</p></td>
<td><p>initializer call</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">owned</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">shared</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">borrowed</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">unmanaged</span></code></div>
</div>
</td>
<td><p>right</p></td>
<td><p>apply management strategy to a class</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">postfix <code class="docutils literal notranslate"><span class="pre">?</span></code></div>
<div class="line">postfix <code class="docutils literal notranslate"><span class="pre">!</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">compute a nilable class type</div>
<div class="line">assert non-nilable and borrow</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">:</span></code></p></td>
<td><p>left</p></td>
<td><p>cast</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>right</p></td>
<td><p>exponentiation</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">reduce</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">scan</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">dmapped</span></code></div>
</div>
</td>
<td><p>left
scan</p></td>
<td><div class="line-block">
<div class="line">reduction</div>
<div class="line">scan</div>
<div class="line">domain map application</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">prefix <code class="docutils literal notranslate"><span class="pre">!</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">~</span></code></div>
</div>
</td>
<td><p>right</p></td>
<td><div class="line-block">
<div class="line">logical negation</div>
<div class="line">bitwise negation</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">*</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">/</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">%</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">multiplication</div>
<div class="line">division</div>
<div class="line">modulus</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">unary <code class="docutils literal notranslate"><span class="pre">+</span></code></div>
<div class="line">unary <code class="docutils literal notranslate"><span class="pre">-</span></code></div>
</div>
</td>
<td><p>right</p></td>
<td><div class="line-block">
<div class="line">positive identity</div>
<div class="line">negation</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">left shift</div>
<div class="line">right shift</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>left</p></td>
<td><p>bitwise/logical and</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>left</p></td>
<td><p>bitwise/logical xor</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>left</p></td>
<td><p>bitwise/logical or</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">+</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">-</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">addition</div>
<div class="line">subtraction</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">..</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">..&lt;</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line">left</div>
<div class="line">left</div>
</div>
</td>
<td><div class="line-block">
<div class="line">range initialization</div>
<div class="line">open-interval range initialization</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">less-than-or-equal-to comparison</div>
<div class="line">greater-than-or-equal-to comparison</div>
<div class="line">less-than comparison</div>
<div class="line">greater-than comparison</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code>
<code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p>left</p></td>
<td><p>equal-to comparison
not-equal-to comparison</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code></p></td>
<td><p>left</p></td>
<td><p>short-circuiting logical and</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">||</span></code></p></td>
<td><p>left</p></td>
<td><p>short-circuiting logical or</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">by</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">#</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">align</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">range/domain stride application</div>
<div class="line">range count application</div>
<div class="line">range alignment</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">in</span></code></p></td>
<td><p>left</p></td>
<td><p>forall expression</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">then</span> <span class="pre">else</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">do</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">do</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">sync</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">single</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">atomic</span></code></div>
</div>
</td>
<td><p>left</p></td>
<td><div class="line-block">
<div class="line">conditional expression</div>
<div class="line">forall expression</div>
<div class="line">forall expression</div>
<div class="line">for expression</div>
<div class="line">sync type modifier</div>
<div class="line">single type modifier</div>
<div class="line">atomic type modifier</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">,</span></code></p></td>
<td><p>left</p></td>
<td><p>comma separated expressions</p></td>
</tr>
</tbody>
</table>
<p>The above table summarizes operator and expression precedence and
associativity. Operators and expressions listed earlier have higher
precedence than those listed later.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>In general, our operator precedence is based on that of the C family
of languages including C++, Java, Perl, and C#. We comment on a few
of the differences and unique factors here.</p>
<p>We find that there is tension between the relative precedence of
exponentiation, unary minus/plus, and casts. The following three
expressions show our intuition for how these expressions should be
parenthesized.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 11%" />
<col style="width: 49%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-2**4</span></code></p></td>
<td><p>wants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-(2**4)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-2:uint</span></code></p></td>
<td><p>wants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(-2):uint</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">2:uint**4:uint</span></code></p></td>
<td><p>wants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(2:uint)**(4:uint)</span></code></p></td>
</tr>
</tbody>
</table>
<p>Trying to support all three of these cases results in a
circularity—exponentiation wants precedence over unary minus, unary
minus wants precedence over casts, and casts want precedence over
exponentiation. We chose to break the circularity by making unary
minus have a lower precedence. This means that for the second case
above:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 25%" />
<col style="width: 41%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-2:uint</span></code></p></td>
<td><p>requires</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(-2):uint</span></code></p></td>
</tr>
</tbody>
</table>
<p>We also chose to depart from the C family of languages by making
unary plus/minus have lower precedence than binary multiplication,
division, and modulus as in Fortran. We have found very few cases
that distinguish between these cases. An interesting one is:</p>
<dl class="simple">
<dt>::</dt><dd><p>const minint = min(int(32));``
…-minint/2…``</p>
</dd>
</dl>
<p>Intuitively, this should result in a positive value, yet C’s
precedence rules results in a negative value due to asymmetry in
modern integer representations. If we learn of cases that argue in
favor of the C approach, we would likely reverse this decision in
order to more closely match C.</p>
<p>We were tempted to diverge from the C precedence rules for the binary
bitwise operators to make them bind less tightly than comparisons.
This would allow us to interpret:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 6%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td><p>as</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">|</span> <span class="pre">b)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
</tr>
</tbody>
</table>
<p>However, given that no other popular modern language has made this
change, we felt it unwise to stray from the pack. The typical
rationale for the C ordering is to allow these operators to be used
as non-short-circuiting logical operations.</p>
<p>In contrast to C, we give bitwise operations a higher precedence than
binary addition/subtraction and comparison operators. This enables
using the shift operators as shorthand for multiplication/division by
powers of 2, and also makes it easier to extract and test a bitmapped
field:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 4%" />
<col style="width: 46%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">&amp;</span> <span class="pre">MASK)</span> <span class="pre">==</span> <span class="pre">MASK</span></code></p></td>
<td><p>as</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">MASK</span> <span class="pre">==</span> <span class="pre">MASK</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">pow(2,y)</span></code></p></td>
<td><p>as</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code></p></td>
</tr>
</tbody>
</table>
<p>One final area of note is the precedence of reductions. Two common
cases tend to argue for making reductions very low or very high in
the precedence table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 7%" />
<col style="width: 49%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">reduce</span> <span class="pre">A</span> <span class="pre">-</span> <span class="pre">min</span> <span class="pre">reduce</span> <span class="pre">A</span></code></p></td>
<td><p>wants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(max</span> <span class="pre">reduce</span> <span class="pre">A)</span> <span class="pre">-</span> <span class="pre">(min</span> <span class="pre">reduce</span> <span class="pre">A)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">reduce</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></code></p></td>
<td><p>wants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">reduce</span> <span class="pre">(A</span> <span class="pre">*</span> <span class="pre">B)</span></code></p></td>
</tr>
</tbody>
</table>
<p>The first statement would require reductions to have a higher
precedence than the arithmetic operators while the second would
require them to be lower. We opted to make reductions have high
precedence due to the argument that they tend to resemble unary
operators. Thus, to support our intuition:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 16%" />
<col style="width: 44%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">reduce</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></code></p></td>
<td><p>requires</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">reduce</span> <span class="pre">(A</span> <span class="pre">*</span> <span class="pre">B)</span></code></p></td>
</tr>
</tbody>
</table>
<p>This choice also has the (arguably positive) effect of making the
unparenthesized version of this statement result in an aggregate
value if A and B are both aggregates—the reduction of A results in a
scalar which promotes when being multiplied by B, resulting in an
aggregate. Our intuition is that users who forget the parentheses
will learn of their error at compilation time because the resulting
expression is not a scalar as expected.</p>
</div></blockquote>
</div>
<div class="section" id="operator-expressions">
<span id="binary-expressions"></span><span id="unary-expressions"></span><h2>Operator Expressions<a class="headerlink" href="#operator-expressions" title="Permalink to this headline">¶</a></h2>
<p>The application of operators to expressions is itself an expression. The
syntax of a unary expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>unary-expression:
  unary-operator expression

unary-operator: one of
  + - ~ !
</pre></div>
</div>
<p>The syntax of a binary expression is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>binary-expression:
  expression binary-operator expression

binary-operator: one of
  + - * / % ** &amp; | ^ &lt;&lt; &gt;&gt; &amp;&amp; || == != &lt;= &gt;= &lt; &gt; &#39;by&#39; #
</pre></div>
</div>
<p>The operators are defined in subsequent sections.</p>
</div>
<div class="section" id="arithmetic-operators">
<span id="id11"></span><h2>Arithmetic Operators<a class="headerlink" href="#arithmetic-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes the predefined arithmetic operators. These
operators can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<p>For each operator, implicit conversions are applied to the operands of
an operator such that they are compatible with one of the function forms
listed, those listed earlier in the list being given preference. If no
compatible implicit conversions exist, then a compile-time error occurs.
In these cases, an explicit cast is required.</p>
<div class="section" id="unary-plus-operators">
<span id="id12"></span><h3>Unary Plus Operators<a class="headerlink" href="#unary-plus-operators" title="Permalink to this headline">¶</a></h3>
<p>The unary plus operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions, the result is the value of the operand.</p>
</div>
<div class="section" id="unary-minus-operators">
<span id="id13"></span><h3>Unary Minus Operators<a class="headerlink" href="#unary-minus-operators" title="Permalink to this headline">¶</a></h3>
<p>The unary minus operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
negation of the value of the operand. For integral types, this
corresponds to subtracting the value from zero. For real and imaginary
types, this corresponds to inverting the sign. For complex types, this
corresponds to inverting the signs of both the real and imaginary parts.</p>
<p>It is an error to try to negate a value of type <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code>. Note that
negating a value of type <code class="docutils literal notranslate"><span class="pre">uint(32)</span></code> first converts the type to
<code class="docutils literal notranslate"><span class="pre">int(64)</span></code> using an implicit conversion.</p>
</div>
<div class="section" id="addition-operators">
<span id="id14"></span><h3>Addition Operators<a class="headerlink" href="#addition-operators" title="Permalink to this headline">¶</a></h3>
<p>The addition operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the sum
of the two operands.</p>
<p>It is a compile-time error to add a value of type <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> and a
value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>.</p>
<p>Addition over a value of real type and a value of imaginary type
produces a value of complex type. Addition of values of complex type and
either real or imaginary types also produces a value of complex type.</p>
</div>
<div class="section" id="subtraction-operators">
<span id="id15"></span><h3>Subtraction Operators<a class="headerlink" href="#subtraction-operators" title="Permalink to this headline">¶</a></h3>
<p>The subtraction operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">-</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
value obtained by subtracting the second operand from the first operand.</p>
<p>It is a compile-time error to subtract a value of type <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> from
a value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>, and vice versa.</p>
<p>Subtraction of a value of real type from a value of imaginary type, and
vice versa, produces a value of complex type. Subtraction of values of
complex type from either real or imaginary types, and vice versa, also
produces a value of complex type.</p>
</div>
<div class="section" id="multiplication-operators">
<span id="id16"></span><h3>Multiplication Operators<a class="headerlink" href="#multiplication-operators" title="Permalink to this headline">¶</a></h3>
<p>The multiplication operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">*</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
product of the two operands.</p>
<p>It is a compile-time error to multiply a value of type <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> and
a value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>.</p>
<p>Multiplication of values of imaginary type produces a value of real
type. Multiplication over a value of real type and a value of imaginary
type produces a value of imaginary type. Multiplication of values of
complex type and either real or imaginary types produces a value of
complex type.</p>
</div>
<div class="section" id="division-operators">
<span id="id17"></span><h3>Division Operators<a class="headerlink" href="#division-operators" title="Permalink to this headline">¶</a></h3>
<p>The division operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">/</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
quotient of the two operands.</p>
<p>It is a compile-time error to divide a value of type <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> by a
value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>, and vice versa.</p>
<p>Division of values of imaginary type produces a value of real type.
Division over a value of real type and a value of imaginary type
produces a value of imaginary type. Division of values of complex type
and either real or imaginary types produces a value of complex type.</p>
<p>When the operands are integers, the result (quotient) is also an
integer. If <code class="docutils literal notranslate"><span class="pre">b</span></code> does not divide <code class="docutils literal notranslate"><span class="pre">a</span></code> exactly, then there are two
candidate quotients <span class="math notranslate nohighlight">\(q1\)</span> and <span class="math notranslate nohighlight">\(q2\)</span> such that <span class="math notranslate nohighlight">\(b * q1\)</span>
and <span class="math notranslate nohighlight">\(b * q2\)</span> are the two multiples of <code class="docutils literal notranslate"><span class="pre">b</span></code> closest to <code class="docutils literal notranslate"><span class="pre">a</span></code>. The
integer result <span class="math notranslate nohighlight">\(q\)</span> is the candidate quotient which lies closest to
zero.</p>
</div>
<div class="section" id="modulus-operators">
<span id="id18"></span><h3>Modulus Operators<a class="headerlink" href="#modulus-operators" title="Permalink to this headline">¶</a></h3>
<p>The modulus operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">%</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
remainder when the first operand is divided by the second operand.</p>
<p>The sign of the result is the same as the sign of the dividend <code class="docutils literal notranslate"><span class="pre">a</span></code>,
and the magnitude of the result is always smaller than that of the
divisor <code class="docutils literal notranslate"><span class="pre">b</span></code>. For integer operands, the <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> operators are
related by the following identity:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">q</span> <span class="o">*</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">r</span> <span class="o">==</span> <span class="nx">a</span><span class="p">);</span>    <span class="c1">// true</span>
</pre></div>
</div>
<p>It is a compile-time error to take the remainder of a value of type
<code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> and a value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>, and vice versa.</p>
<p>There is an expectation that the predefined modulus operators will be
extended to handle real, imaginary, and complex types in the future.</p>
</div>
<div class="section" id="exponentiation-operators">
<span id="id19"></span><h3>Exponentiation Operators<a class="headerlink" href="#exponentiation-operators" title="Permalink to this headline">¶</a></h3>
<p>The exponentiation operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">**</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions that return a value, the result is the
value of the first operand raised to the power of the second operand.</p>
<p>It is a compile-time error to take the exponent of a value of type
<code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> by a value of type <code class="docutils literal notranslate"><span class="pre">int(64)</span></code>, and vice versa.</p>
<p>There is an expectation that the predefined exponentiation operators
will be extended to handle imaginary and complex types in the future.</p>
</div>
</div>
<div class="section" id="bitwise-operators">
<span id="id20"></span><h2>Bitwise Operators<a class="headerlink" href="#bitwise-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes the predefined bitwise operators. These operators
can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<div class="section" id="bitwise-complement-operators">
<span id="id21"></span><h3>Bitwise Complement Operators<a class="headerlink" href="#bitwise-complement-operators" title="Permalink to this headline">¶</a></h3>
<p>The bitwise complement operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">~</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions, the result is the bitwise complement of
the operand.</p>
</div>
<div class="section" id="bitwise-and-operators">
<span id="id22"></span><h3>Bitwise And Operators<a class="headerlink" href="#bitwise-and-operators" title="Permalink to this headline">¶</a></h3>
<p>The bitwise and operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&amp;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">bool</span><span class="p">):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&amp;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&amp;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">&amp;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&amp;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions, the result is computed by applying the
logical and operation to the bits of the operands.</p>
<p>Chapel allows mixing signed and unsigned integers of the same size when
passing them as arguments to bitwise and. In the mixed case the result
is of the same size as the arguments and is unsigned. No run-time error
is issued, even if the apparent sign changes as the required conversions
are performed.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The mathematical meaning of integer arguments is discarded when they
are passed to bitwise operators. Instead the arguments are treated
simply as bit vectors. The bit-vector meaning is preserved when
converting between signed and unsigned of the same size. The choice
of unsigned over signed as the result type in the mixed case reflects
the semantics of standard C.</p>
</div></blockquote>
</div>
<div class="section" id="bitwise-or-operators">
<span id="id23"></span><h3>Bitwise Or Operators<a class="headerlink" href="#bitwise-or-operators" title="Permalink to this headline">¶</a></h3>
<p>The bitwise or operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">|</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">bool</span><span class="p">):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">|</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">|</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">|</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">|</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions, the result is computed by applying the
logical or operation to the bits of the operands. Chapel allows mixing
signed and unsigned integers of the same size when passing them as
arguments to bitwise or. No run-time error is issued, even if the
apparent sign changes as the required conversions are performed.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The same as for bitwise and (<a class="reference internal" href="#bitwise-and-operators"><span class="std std-ref">Bitwise And Operators</span></a>).</p>
</div></blockquote>
</div>
<div class="section" id="bitwise-xor-operators">
<span id="id24"></span><h3>Bitwise Xor Operators<a class="headerlink" href="#bitwise-xor-operators" title="Permalink to this headline">¶</a></h3>
<p>The bitwise xor operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">^</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">bool</span><span class="p">):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">^</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">^</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">^</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">^</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</pre></div>
</div>
<p>For each of these definitions, the result is computed by applying the
XOR operation to the bits of the operands. Chapel allows mixing signed
and unsigned integers of the same size when passing them as arguments to
bitwise xor. No run-time error is issued, even if the apparent sign
changes as the required conversions are performed.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The same as for bitwise and (<a class="reference internal" href="#bitwise-and-operators"><span class="std std-ref">Bitwise And Operators</span></a>).</p>
</div></blockquote>
</div>
</div>
<div class="section" id="shift-operators">
<span id="id25"></span><h2>Shift Operators<a class="headerlink" href="#shift-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes the predefined shift operators. These operators
can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<p>The shift operators are predefined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="k">proc</span> <span class="nf">&gt;&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">):</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>The type of the second actual argument must be any integral type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator shifts the bits of <code class="docutils literal notranslate"><span class="pre">a</span></code> left by the integer <code class="docutils literal notranslate"><span class="pre">b</span></code>.
The new low-order bits are set to zero.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> operator shifts the bits of <code class="docutils literal notranslate"><span class="pre">a</span></code> right by the integer <code class="docutils literal notranslate"><span class="pre">b</span></code>.
When <code class="docutils literal notranslate"><span class="pre">a</span></code> is negative, the new high-order bits are set to one;
otherwise the new high-order bits are set to zero.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">b</span></code> must be non-negative.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">b</span></code> must be less than the number of bits in <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</div>
<div class="section" id="logical-operators">
<span id="id26"></span><h2>Logical Operators<a class="headerlink" href="#logical-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes the predefined logical operators. These operators
can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<div class="section" id="the-logical-negation-operator">
<span id="logical-negation-operators"></span><h3>The Logical Negation Operator<a class="headerlink" href="#the-logical-negation-operator" title="Permalink to this headline">¶</a></h3>
<p>The logical negation operator is predefined for booleans and integers as
follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">!</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">bool</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(?</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(?</span><span class="nx">w</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>For the boolean form, the result is the logical negation of the operand.
For the integer forms, the result is true if the operand is zero and
false otherwise.</p>
</div>
<div class="section" id="the-logical-and-operator">
<span id="logical-and-operators"></span><h3>The Logical And Operator<a class="headerlink" href="#the-logical-and-operator" title="Permalink to this headline">¶</a></h3>
<p>The logical and operator is predefined over bool type. It returns true
if both operands evaluate to true; otherwise it returns false. If the
first operand evaluates to false, the second operand is not evaluated
and the result is false.</p>
<p>The logical and operator over expressions <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> given by</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span>
</pre></div>
</div>
<p>is evaluated as the expression</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">isTrue</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="k">then</span> <span class="nx">isTrue</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="k">else</span> <span class="kc">false</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">isTrue</span></code> is predefined over bool type as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">isTrue</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span><span class="kt">bool</span><span class="p">)</span> <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
</pre></div>
</div>
<p>Overloading the logical and operator over other types is accomplished by
overloading the <code class="docutils literal notranslate"><span class="pre">isTrue</span></code> function over other types.</p>
</div>
<div class="section" id="the-logical-or-operator">
<span id="logical-or-operators"></span><h3>The Logical Or Operator<a class="headerlink" href="#the-logical-or-operator" title="Permalink to this headline">¶</a></h3>
<p>The logical or operator is predefined over bool type. It returns true if
either operand evaluate to true; otherwise it returns false. If the
first operand evaluates to true, the second operand is not evaluated and
the result is true.</p>
<p>The logical or operator over expressions <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> given by</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">||</span> <span class="nx">b</span>
</pre></div>
</div>
<p>is evaluated as the expression</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">isTrue</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="k">then</span> <span class="kc">true</span> <span class="k">else</span> <span class="nx">isTrue</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">isTrue</span></code> is predefined over bool type as described
in <a class="reference internal" href="#logical-and-operators"><span class="std std-ref">The Logical And Operator</span></a>. Overloading the logical or
operator over other types is accomplished by overloading the <code class="docutils literal notranslate"><span class="pre">isTrue</span></code>
function over other types.</p>
</div>
</div>
<div class="section" id="relational-operators">
<span id="id27"></span><h2>Relational Operators<a class="headerlink" href="#relational-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes the predefined relational operators. These
operators can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<div class="section" id="ordered-comparison-operators">
<span id="id28"></span><h3>Ordered Comparison Operators<a class="headerlink" href="#ordered-comparison-operators" title="Permalink to this headline">¶</a></h3>
<p>The “less than” comparison operators are predefined over numeric types
as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is less than <code class="docutils literal notranslate"><span class="pre">b</span></code>; otherwise
the result is false.</p>
<p>The “greater than” comparison operators are predefined over numeric
types as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>;
otherwise the result is false.</p>
<p>The “less than or equal to” comparison operators are predefined over
numeric types as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is less than or equal to
<code class="docutils literal notranslate"><span class="pre">b</span></code>; otherwise the result is false.</p>
<p>The “greater than or equal to” comparison operators are predefined over
numeric types as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is greater than or equal to
<code class="docutils literal notranslate"><span class="pre">b</span></code>; otherwise the result is false.</p>
<p>The ordered comparison operators are predefined over strings as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">&lt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&lt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">&gt;=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>Comparisons between strings are defined based on the ordering of the
character set used to represent the string, which is applied elementwise
to the string’s characters in order.</p>
</div>
<div class="section" id="equality-comparison-operators">
<span id="id29"></span><h3>Equality Comparison Operators<a class="headerlink" href="#equality-comparison-operators" title="Permalink to this headline">¶</a></h3>
<p>The equality comparison operators <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> are predefined
over bool and the numeric types as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">16</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">uint</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">32</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">imag</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>

<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">64</span><span class="p">)):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">complex</span><span class="p">(</span><span class="mi">128</span><span class="p">)):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> contain the same
value; otherwise the result is false. The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">!(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>.</p>
<p>The equality comparison operators are predefined over classes as
follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">object</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">object</span><span class="p">):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> is true if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> reference the same
storage location; otherwise the result is false. The result of
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">!(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>.</p>
<p>Default equality comparison operators are generated for records if the
user does not define them. These operators are described
in <a class="reference internal" href="records.html#record-comparison-operators"><span class="std std-ref">Default Comparison Operators</span></a>.</p>
<p>The equality comparison operators are predefined over strings as
follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">==</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
<span class="k">proc</span> <span class="nf">!=</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">bool</span>
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> is true if the sequence of characters in <code class="docutils literal notranslate"><span class="pre">a</span></code>
matches exactly the sequence of characters in <code class="docutils literal notranslate"><span class="pre">b</span></code>; otherwise the
result is false. The result of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">!(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>.</p>
</div>
</div>
<div class="section" id="class-operators">
<span id="id30"></span><h2>Class Operators<a class="headerlink" href="#class-operators" title="Permalink to this headline">¶</a></h2>
<p>The keywords <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> act
as a prefix unary operator when specifying the management strategy for a
class type. See <a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>.</p>
<p>The unary postfix operator <code class="docutils literal notranslate"><span class="pre">?</span></code> results in the nilable variant of a
class type. See <a class="reference internal" href="classes.html#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>.</p>
<p>The unary postfix operator <code class="docutils literal notranslate"><span class="pre">!</span></code> asserts that the receiver is not
storing <code class="docutils literal notranslate"><span class="pre">nil</span></code> and borrows from it.
See <a class="reference internal" href="classes.html#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>.</p>
</div>
<div class="section" id="miscellaneous-operators">
<span id="id31"></span><h2>Miscellaneous Operators<a class="headerlink" href="#miscellaneous-operators" title="Permalink to this headline">¶</a></h2>
<p>This section describes several miscellaneous operators. These operators
can be redefined over different types using operator
overloading (<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>).</p>
<div class="section" id="the-string-concatenation-operator">
<span id="id32"></span><h3>The String Concatenation Operator<a class="headerlink" href="#the-string-concatenation-operator" title="Permalink to this headline">¶</a></h3>
<p>The string concatenation operator <code class="docutils literal notranslate"><span class="pre">+</span></code> is predefined for string
arguments and returns a new string that is the concatenation of its
arguments:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">+</span><span class="p">(</span><span class="nx">s0</span><span class="p">:</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">s1</span><span class="p">:</span> <span class="kt">string</span><span class="p">):</span> <span class="kt">string</span>
</pre></div>
</div>
<blockquote>
<div><p><em>Example (string-concat.chpl)</em>.</p>
<p>The code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;hi&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot; there&quot;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</pre></div>
</div>
<p>will cause <code class="docutils literal notranslate"><span class="pre">z</span></code> to be a new string containing the value
<code class="docutils literal notranslate"><span class="pre">&quot;hi</span> <span class="pre">there&quot;</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="the-by-operator">
<span id="id33"></span><h3>The By Operator<a class="headerlink" href="#the-by-operator" title="Permalink to this headline">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">by</span></code> is predefined on ranges and rectangular domains. It
is described in <a class="reference internal" href="ranges.html#by-operator-for-ranges"><span class="std std-ref">By Operator</span></a> for ranges
and <a class="reference internal" href="domains.html#domain-striding"><span class="std std-ref">Domain Striding</span></a> for domains.</p>
</div>
<div class="section" id="the-align-operator">
<span id="id34"></span><h3>The Align Operator<a class="headerlink" href="#the-align-operator" title="Permalink to this headline">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">align</span></code> is predefined on ranges and rectangular domains.
It is described in <a class="reference internal" href="ranges.html#align-operator-for-ranges"><span class="std std-ref">Align Operator</span></a> for ranges
and <a class="reference internal" href="domains.html#domain-alignment"><span class="std std-ref">Domain Alignment</span></a> for domains.</p>
</div>
<div class="section" id="the-range-count-operator">
<span id="id35"></span><h3>The Range Count Operator<a class="headerlink" href="#the-range-count-operator" title="Permalink to this headline">¶</a></h3>
<p>The operator <code class="docutils literal notranslate"><span class="pre">#</span></code> is predefined on ranges. It is described in
 <a class="reference internal" href="ranges.html#count-operator"><span class="std std-ref">Count Operator</span></a>.</p>
</div>
</div>
<div class="section" id="let-expressions">
<span id="id36"></span><h2>Let Expressions<a class="headerlink" href="#let-expressions" title="Permalink to this headline">¶</a></h2>
<p>A let expression allows variables to be declared at the expression level
and used within that expression. The syntax of a let expression is given
by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>let-expression:
  &#39;let&#39; variable-declaration-list &#39;in&#39; expression
</pre></div>
</div>
<p>The scope of the variables is the let-expression.</p>
<blockquote>
<div><p><em>Example (let.chpl)</em>.</p>
<p>Let expressions are useful for defining variables in the context of
an expression. In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="nx">b</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">/</span><span class="nx">y</span>
</pre></div>
</div>
<p>the value determined by <code class="docutils literal notranslate"><span class="pre">a*b</span></code> is computed and converted to type
real if it is not already a real. The square of the real is then
stored in <code class="docutils literal notranslate"><span class="pre">y</span></code> and the result of the expression is the reciprocal of
that value.</p>
</div></blockquote>
</div>
<div class="section" id="conditional-expressions">
<span id="id37"></span><h2>Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this headline">¶</a></h2>
<p>A conditional expression is given by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>if-expression:
  &#39;if&#39; expression &#39;then&#39; expression &#39;else&#39; expression
  &#39;if&#39; expression &#39;then&#39; expression
</pre></div>
</div>
<p>The conditional expression is evaluated in two steps. First, the
expression following the <code class="docutils literal notranslate"><span class="pre">if</span></code> keyword is evaluated. Then, if the
expression evaluated to true, the expression following the <code class="docutils literal notranslate"><span class="pre">then</span></code>
keyword is evaluated and taken to be the value of this expression.
Otherwise, the expression following the <code class="docutils literal notranslate"><span class="pre">else</span></code> keyword is evaluated
and taken to be the value of this expression. In both cases, the
unselected expression is not evaluated.</p>
<p>The ‘else’ clause can be omitted only when the conditional expression is
nested immediately inside a for or forall expression. Such an expression
is used to filter predicates as described
in <a class="reference internal" href="#filtering-predicates-for"><span class="std std-ref">Filtering Predicates in For Expressions</span></a>
and <a class="reference internal" href="data-parallelism.html#filtering-predicates-forall"><span class="std std-ref">Filtering Predicates in Forall Expressions</span></a>, respectively.</p>
<blockquote>
<div><p><em>Example (condexp.chpl)</em>.</p>
<p>This example shows how if-then-else can be used in a context in which
an expression is expected. The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writehalf</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nx">writehalf</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
<span class="nx">writehalf</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

<span class="k">proc</span> <span class="nf">writehalf</span><span class="p">(</span><span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">half</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">then</span> <span class="nx">i</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span><span class="mi">1</span> <span class="k">else</span> <span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Half of &quot;</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="s">&quot; is &quot;</span><span class="p">,</span><span class="nx">half</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Half of 8 is 4
Half of 21 is 11
Half of 1000 is 500
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="for-expressions">
<span id="id38"></span><h2>For Expressions<a class="headerlink" href="#for-expressions" title="Permalink to this headline">¶</a></h2>
<p>A for expression is given by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>for-expression:
  &#39;for&#39; index-var-declaration &#39;in&#39; iteratable-expression &#39;do&#39; expression
  &#39;for&#39; iteratable-expression &#39;do&#39; expression
</pre></div>
</div>
<p>A for expression is an iterator that executes a for loop
(<a class="reference internal" href="statements.html#the-for-loop"><span class="std std-ref">The For Loop</span></a>), evaluates the body expression on each
iteration of the loop, and yields each resulting value.</p>
<p>When a for expression is used to initialize a variable, such as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">X</span> <span class="o">=</span> <span class="k">for</span> <span class="nx">iterableExpression</span><span class="p">()</span> <span class="k">do</span> <span class="nx">computeValue</span><span class="p">();</span>
</pre></div>
</div>
<p>the variable will be inferred to have an array type. The array’s domain
is defined by the <code class="docutils literal notranslate"><span class="pre">iterable-expression</span></code> following the same rules as
for promotion, both in the regular case <a class="reference internal" href="data-parallelism.html#promotion"><span class="std std-ref">Promotion</span></a> and in
the zipper case <a class="reference internal" href="data-parallelism.html#zipper-promotion"><span class="std std-ref">Zipper Promotion</span></a>.</p>
<div class="section" id="filtering-predicates-in-for-expressions">
<span id="filtering-predicates-for"></span><h3>Filtering Predicates in For Expressions<a class="headerlink" href="#filtering-predicates-in-for-expressions" title="Permalink to this headline">¶</a></h3>
<p>A conditional expression that is immediately enclosed in a for
expression and does not require an else clause filters the iterations of
the for expression. The iterations for which the condition does not hold
are not reflected in the result of the for expression.</p>
<p>When a for expression with a filtering predicate is captured into a
variable, the resulting array has a 0-based one-dimensional domain.</p>
<blockquote>
<div><p><em>Example (yieldPredicates.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="k">do</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nx">i</span><span class="p">;</span>
</pre></div>
</div>
<p>declares an array A that is initialized to the integers between 1 and
10 that are not divisible by 3.</p>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="statements.html" class="btn btn-neutral float-right" title="Statements" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="conversions.html" class="btn btn-neutral float-left" title="Conversions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>