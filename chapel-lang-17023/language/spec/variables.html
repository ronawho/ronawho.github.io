

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Variables &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Conversions" href="conversions.html" />
    <link rel="prev" title="Types" href="types.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/variables";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-declarations">Variable Declarations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#split-initialization">Split Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-initialization">Default Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-type-inference">Local Type Inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-variable-declarations">Multiple Variable Declarations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-level-variables">Module Level Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-variables">Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compile-time-constants">Compile-Time Constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-constants">Runtime Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-variables">Configuration Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ref-variables">Ref Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-conflicts">Variable Conflicts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-lifetimes">Variable Lifetimes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#deinit-points">Deinit Points</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copy-and-move-initialization">Copy and Move Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copy-elision">Copy Elision</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Variables</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/variables.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="variables">
<span id="chapter-variables"></span><h1>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h1>
<p>A variable is a symbol that represents memory. Chapel is a
statically-typed, type-safe language so every variable has a type that
is known at compile-time and the compiler enforces that values assigned
to the variable can be stored in that variable as specified by its type.</p>
<div class="section" id="variable-declarations">
<span id="id1"></span><h2>Variable Declarations<a class="headerlink" href="#variable-declarations" title="Permalink to this headline">¶</a></h2>
<p>Variables are declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>variable-declaration-statement:
  privacy-specifier[OPT] config-extern-or-export[OPT] variable-kind variable-declaration-list ;

config-extern-or-export: one of
  &#39;config&#39; &#39;extern&#39; &#39;export&#39;

variable-kind:
  &#39;param&#39;
  &#39;const&#39;
  &#39;var&#39;
  &#39;ref&#39;
  &#39;const ref&#39;

variable-declaration-list:
  variable-declaration
  variable-declaration , variable-declaration-list

variable-declaration:
  identifier-list type-part[OPT] initialization-part[OPT]

type-part:
  : type-expression

initialization-part:
  = expression

identifier-list:
  identifier
  identifier , identifier-list
  tuple-grouped-identifier-list
  tuple-grouped-identifier-list , identifier-list

tuple-grouped-identifier-list:
  ( identifier-list )
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">variable-declaration-statement</span></code> is used to define one or more
variables. If the statement is a top-level module statement, the
variables are module level; otherwise they are local. Module level
variables are discussed in <a class="reference internal" href="#module-level-variables"><span class="std std-ref">Module Level Variables</span></a>. Local
variables are discussed in <a class="reference internal" href="#local-variables"><span class="std std-ref">Local Variables</span></a>.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> keywords indicate the visibility of
module level variables to outside modules. By default, variables are
publicly visible. More details on visibility can be found in
 <a class="reference internal" href="modules.html#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>.</p>
<p>The optional keyword <code class="docutils literal notranslate"><span class="pre">config</span></code> specifies that the variables are
configuration variables, described in
Section <a class="reference internal" href="#configuration-variables"><span class="std std-ref">Configuration Variables</span></a>. The optional keyword
<code class="docutils literal notranslate"><span class="pre">extern</span></code> indicates that the variable is externally defined. Its name
and type are used within the Chapel program for resolution, but no space
is allocated for it and no initialization code emitted. See
<a class="reference internal" href="interoperability.html#shared-data"><span class="std std-ref">Shared Data</span></a> for further details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">variable-kind</span></code> specifies whether the variables are parameters
(<code class="docutils literal notranslate"><span class="pre">param</span></code>), constants (<code class="docutils literal notranslate"><span class="pre">const</span></code>), ref variables (<code class="docutils literal notranslate"><span class="pre">ref</span></code>), or regular
variables (<code class="docutils literal notranslate"><span class="pre">var</span></code>). Parameters are compile-time constants whereas
constants are runtime constants. Both levels of constants are discussed
in <a class="reference internal" href="#constants"><span class="std std-ref">Constants</span></a>. Ref variables are discussed in
<a class="reference internal" href="#ref-variables"><span class="std std-ref">Ref Variables</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">type-part</span></code> of a variable declaration specifies the type of the
variable. It is optional.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code> of a variable declaration specifies an
initialization expression for the variable. It is optional. When present,
the initialization expression will be stored into the variable as its
initial value.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code> is omitted, the compiler will consider if
split initialization can be applied to this variable as described in
<a class="reference internal" href="#split-initialization"><span class="std std-ref">Split Initialization</span></a>. If split initialization can be applied, the
compiler will identify one or more later assignment statements and the
right-hand-side of such statements will form the initialization
expression. If the <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code> is omitted and split
initialization cannot be applied, then the variable will need to be
initialized to a default value. Only <cite>var</cite> and <cite>const</cite> variable
declarations can be initialized to a default value. Not all types have a
default value. Default values are described in
<a class="reference internal" href="#default-values-for-types"><span class="std std-ref">Default Initialization</span></a>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">type-part</span></code> is omitted or refers to a generic type, an
initialization expression as described above is required. Note that such
initialization expressions can be in later statements if
<a class="reference internal" href="#split-initialization"><span class="std std-ref">Split Initialization</span></a> us used. When the <code class="docutils literal notranslate"><span class="pre">type-part</span></code> is omitted or
generic, the type of the variable is inferred from the initialization
expression using local type inference described
in <a class="reference internal" href="#local-type-inference"><span class="std std-ref">Local Type Inference</span></a>. If the <code class="docutils literal notranslate"><span class="pre">type-part</span></code> is present, the
initialization expression must be coercible to the specified type or, if
<code class="docutils literal notranslate"><span class="pre">type-part</span></code> is generic, to its instantiation.</p>
<p>Multiple variables can be defined in the same
<code class="docutils literal notranslate"><span class="pre">variable-declaration-list</span></code>. The semantics of declaring multiple
variables that share an <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code> and/or <code class="docutils literal notranslate"><span class="pre">type-part</span></code> is
defined in <a class="reference internal" href="#multiple-variable-declarations"><span class="std std-ref">Multiple Variable Declarations</span></a>.</p>
<p>Multiple variables can be grouped together using a tuple notation as
described in <a class="reference internal" href="tuples.html#variable-declarations-in-a-tuple"><span class="std std-ref">Splitting a Tuple in a Declaration</span></a>.</p>
<div class="section" id="split-initialization">
<span id="id2"></span><h3>Split Initialization<a class="headerlink" href="#split-initialization" title="Permalink to this headline">¶</a></h3>
<p>Split initialization is a feature that allows an initialization
expression for a variable to be in a statement after the variable
declaration statement.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code> of a local variable declaration is
omitted, the compiler will search forward in the function for the
earliest assignment statement(s) setting that variable that occur before
the variable is otherwise mentioned. It will consider the variable passed
to an <code class="docutils literal notranslate"><span class="pre">out</span></code> intent argument as an assignment statement for this
purpose.  It will search only within block declarations <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code>, <code class="docutils literal notranslate"><span class="pre">try</span></code>
blocks, <code class="docutils literal notranslate"><span class="pre">try!</span></code> blocks, and conditionals.  These assignment statements
and calls to functions with <code class="docutils literal notranslate"><span class="pre">out</span></code> intent are called applicable
assignment statements.  They perform initialization, not assignment, of
that variable.</p>
<blockquote>
<div><p><em>Example (simple-split-init.chpl)</em></p>
<p>The combination of statements <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">x;</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5;</span></code> in the below
example are equivalent to the declaration <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">5;</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span><span class="p">;</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Example (no-split-init.chpl)</em></p>
<p>In the following code, the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is used before it is
assigned to, and so split initialization cannot apply to that
variable.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Example (split-cond-blocks-init.chpl)</em></p>
<p>Split initialization can find the applicable assignment statement
within a nested block or conditional. When conditionals are involved,
there might be multiple applicable assignment statements representing
different branches.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">option</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="nx">option</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="nx">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A function call passing a variable to an <code class="docutils literal notranslate"><span class="pre">out</span></code> intent serves as an
applicable assignment statement, provided that the variable was
declared with a type. For example:</p>
<p><em>Example (split-init-out.chpl)</em></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">setArgToFive</span><span class="p">(</span><span class="kd">out</span> <span class="nx">arg</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">arg</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="nx">setArgToFive</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// initializes x</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Split initialization does not apply:</p>
<blockquote>
<div><ul class="simple">
<li><p>when the variable is a field, config variable, or <code class="docutils literal notranslate"><span class="pre">extern</span></code> variable.</p></li>
<li><p>when an applicable assignment statement setting the variable could not
be identified</p></li>
<li><p>when an applicable assignment statement is in one branch of a
conditional but not in the other, and when the other branch
does not always return or throw. This rule prevents
split-initialization when the applicable assignment statement is
in a conditional that has no <code class="docutils literal notranslate"><span class="pre">else</span></code> branch.</p></li>
<li><p>when an applicable assignment statement is in a <code class="docutils literal notranslate"><span class="pre">try</span></code> or <code class="docutils literal notranslate"><span class="pre">try!</span></code>
block which has <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses that mention the variable
or which has <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses that do not always throw or return.</p></li>
</ul>
</div></blockquote>
<p>In the case that the variable is declared without a <code class="docutils literal notranslate"><span class="pre">type-part</span></code> and
where multiple applicable assignment statements are identified, all of
the assignment statements need to contain an initialization expression of
the same type.</p>
<p>Any variables declared in a particular scope that are initialized with
split init in both the <code class="docutils literal notranslate"><span class="pre">then</span></code> and <code class="docutils literal notranslate"><span class="pre">else</span></code> branches of a conditional
must be initialized in the same order in the <code class="docutils literal notranslate"><span class="pre">then</span></code> and <code class="docutils literal notranslate"><span class="pre">else</span></code>
branches.</p>
</div>
<div class="section" id="default-initialization">
<span id="default-values-for-types"></span><h3>Default Initialization<a class="headerlink" href="#default-initialization" title="Permalink to this headline">¶</a></h3>
<p>If a variable declaration has no initialization expression, a variable
is initialized to the default value of its type. The default values are
as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Default Value</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool(*)</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>int(*)</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>uint(*)</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>real(*)</p></td>
<td><p>0.0</p></td>
</tr>
<tr class="row-even"><td><p>imag(*)</p></td>
<td><p>0.0i</p></td>
</tr>
<tr class="row-odd"><td><p>complex(*)</p></td>
<td><p>0.0 + 0.0i</p></td>
</tr>
<tr class="row-even"><td><p>string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-odd"><td><p>bytes</p></td>
<td><p>b””</p></td>
</tr>
<tr class="row-even"><td><p>enums</p></td>
<td><p>first enum constant</p></td>
</tr>
<tr class="row-odd"><td><p>classes</p></td>
<td><p>nil</p></td>
</tr>
<tr class="row-even"><td><p>records</p></td>
<td><p>default constructed record</p></td>
</tr>
<tr class="row-odd"><td><p>ranges</p></td>
<td><p>1..0 :math:`` :math:`` (empty sequence)</p></td>
</tr>
<tr class="row-even"><td><p>arrays</p></td>
<td><p>elements are default values</p></td>
</tr>
<tr class="row-odd"><td><p>tuples</p></td>
<td><p>components are default values</p></td>
</tr>
<tr class="row-even"><td><p>sync/single</p></td>
<td><p>base default value and <em>empty</em> status</p></td>
</tr>
<tr class="row-odd"><td><p>atomic</p></td>
<td><p>base default value</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="local-type-inference">
<span id="id3"></span><h3>Local Type Inference<a class="headerlink" href="#local-type-inference" title="Permalink to this headline">¶</a></h3>
<p>If the type is omitted from a variable declaration, the type of the
variable is defined to be the type of the initialization expression.
With the exception of sync and single expressions, the declaration</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="kd">type</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
<p>for an arbitrary expression <code class="docutils literal notranslate"><span class="pre">e</span></code>. If <code class="docutils literal notranslate"><span class="pre">e</span></code> is of sync or single type,
the type of <code class="docutils literal notranslate"><span class="pre">v</span></code> is the base type of <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</div>
<div class="section" id="multiple-variable-declarations">
<span id="id4"></span><h3>Multiple Variable Declarations<a class="headerlink" href="#multiple-variable-declarations" title="Permalink to this headline">¶</a></h3>
<p>All variables defined in the same <code class="docutils literal notranslate"><span class="pre">identifier-list</span></code> are defined such
that they have the same type and value, and so that the type and
initialization expression are evaluated only once.</p>
<blockquote>
<div><p><em>Example (multiple.chpl)</em>.</p>
<p>In the declaration</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;side effect&quot;</span><span class="p">);</span> <span class="k">return</span> <span class="s">&quot;a string&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
</pre></div>
</div>
<p>variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are of type <code class="docutils literal notranslate"><span class="pre">real</span></code> with value <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.
Variables <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> are of type <code class="docutils literal notranslate"><span class="pre">int</span></code> and are initialized to
the default value of <code class="docutils literal notranslate"><span class="pre">0</span></code>. Variables <code class="docutils literal notranslate"><span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code> are of type
<code class="docutils literal notranslate"><span class="pre">string</span></code> with value <code class="docutils literal notranslate"><span class="pre">&quot;a</span> <span class="pre">string&quot;</span></code>. The string <code class="docutils literal notranslate"><span class="pre">&quot;side</span> <span class="pre">effect&quot;</span></code>
has been written to the display once. It is not evaluated twice.</p>
</div></blockquote>
<p>The exact way that multiple variables are declared is defined as
follows:</p>
<ul>
<li><p>If the variables in the <code class="docutils literal notranslate"><span class="pre">identifier-list</span></code> are declared with a type,
but without an initialization expression as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span>
</pre></div>
</div>
<p>for an arbitrary type expression <code class="docutils literal notranslate"><span class="pre">t</span></code>, then the declarations are
rewritten so that the first variable is declared to be of type <code class="docutils literal notranslate"><span class="pre">t</span></code>
and each later variable is declared to be of the type of the first
variable as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">v2</span><span class="p">:</span> <span class="nx">v1</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">v3</span><span class="p">:</span> <span class="nx">v1</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>If the variables in the <code class="docutils literal notranslate"><span class="pre">identifier-list</span></code> are declared without a
type, but with an initialization expression as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
<p>for an arbitrary expression <code class="docutils literal notranslate"><span class="pre">e</span></code>, then the declarations are
rewritten so that the first variable is initialized by expression
<code class="docutils literal notranslate"><span class="pre">e</span></code> and each later variable is initialized by the first variable as
in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">v3</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>If the variables in the <code class="docutils literal notranslate"><span class="pre">identifier-list</span></code> are declared with both a
type and an initialization expression as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">:</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
</pre></div>
</div>
<p>for an arbitrary type expression <code class="docutils literal notranslate"><span class="pre">t</span></code> and an arbitrary expression
<code class="docutils literal notranslate"><span class="pre">e</span></code>, then the declarations are rewritten so that the first variable
is declared to be of type <code class="docutils literal notranslate"><span class="pre">t</span></code> and initialized by expression <code class="docutils literal notranslate"><span class="pre">e</span></code>,
and each later variable is declared to be of the type of the first
variable and initialized by the result of calling the function
<code class="docutils literal notranslate"><span class="pre">readXX</span></code> on the first variable as in</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v1</span><span class="p">:</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">v2</span><span class="p">:</span> <span class="nx">v1</span><span class="p">.</span><span class="kd">type</span> <span class="o">=</span> <span class="nx">readXX</span><span class="p">(</span><span class="nx">v1</span><span class="p">);</span> <span class="kd">var</span> <span class="nx">v3</span><span class="p">:</span> <span class="nx">v1</span><span class="p">.</span><span class="kd">type</span> <span class="o">=</span> <span class="nx">readXX</span><span class="p">(</span><span class="nx">v1</span><span class="p">);</span>
</pre></div>
</div>
<p>where the function <code class="docutils literal notranslate"><span class="pre">readXX</span></code> is defined as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">readXX</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="k">sync</span><span class="p">)</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">readXX</span><span class="p">();</span>
<span class="k">proc</span> <span class="nf">readXX</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="k">single</span><span class="p">)</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">readXX</span><span class="p">();</span>
<span class="k">proc</span> <span class="nf">readXX</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the use of the helper function <code class="docutils literal notranslate"><span class="pre">readXX()</span></code> in this code
fragment is solely for the purposes of illustration. It is not
actually a part of Chapel’s semantics or implementation.</p>
</li>
</ul>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>This algorithm is complicated by the existence of <em>sync</em> and <em>single</em>
variables. If these did not exist, we could rewrite any
multi-variable declaration such that later variables were simply
initialized by the first variable and the first variable was defined
as if it appeared alone in the <code class="docutils literal notranslate"><span class="pre">identifier-list</span></code>. However, both
<em>sync</em> and <em>single</em> variables require careful handling to avoid
unintentional changes to their <em>full</em>/<em>empty</em> state.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="module-level-variables">
<span id="id5"></span><h2>Module Level Variables<a class="headerlink" href="#module-level-variables" title="Permalink to this headline">¶</a></h2>
<p>Variables declared in statements that are in a module but not in a
function or block within that module are module level variables. Module
level variables can be accessed anywhere within that module after the
initialization of that variable. If they are public, they can also be
accessed in other modules that use that module.</p>
</div>
<div class="section" id="local-variables">
<span id="id6"></span><h2>Local Variables<a class="headerlink" href="#local-variables" title="Permalink to this headline">¶</a></h2>
<p>Local variables are declared within block statements. They can only be
accessed within the scope of that block statement (including all inner
nested block statements and functions).</p>
<p>A local variable only exists during its lifetime. The lifetime of a local
variable will end when its deinitialization point, or deinit point, is
reached. At that time, the local variable and the storage representing it
is removed. See <a class="reference internal" href="#deinit-points"><span class="std std-ref">Deinit Points</span></a> for more details.</p>
<p>Note that unlike most types, variables of <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> class type do not
automatically reclaim the storage that they refer to. Such storage can be
reclaimed as described in <a class="reference internal" href="classes.html#class-delete"><span class="std std-ref">Deleting Unmanaged Class Instances</span></a>.</p>
</div>
<div class="section" id="constants">
<span id="id7"></span><h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h2>
<p>Constants are divided into two categories: parameters, specified with
the keyword <code class="docutils literal notranslate"><span class="pre">param</span></code>, are compile-time constants and constants,
specified with the keyword <code class="docutils literal notranslate"><span class="pre">const</span></code>, are runtime constants.</p>
<div class="section" id="compile-time-constants">
<span id="id8"></span><h3>Compile-Time Constants<a class="headerlink" href="#compile-time-constants" title="Permalink to this headline">¶</a></h3>
<p>A compile-time constant, or “parameter”, must have a single value that
is known statically by the compiler. Parameters are restricted to
primitive and enumerated types.</p>
<p>Parameters can be assigned expressions that are parameter expressions.
Parameter expressions are restricted to the following constructs:</p>
<ul class="simple">
<li><p>Literals of primitive or enumerated type.</p></li>
<li><p>Parenthesized parameter expressions.</p></li>
<li><p>Casts of parameter expressions to primitive or enumerated types.</p></li>
<li><p>Applications of the unary operators <code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">``-</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> on operands
that are bool or integral parameter expressions.</p></li>
<li><p>Applications of the unary operators <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> on operands that are
real, imaginary or complex parameter expressions.</p></li>
<li><p>Applications of the binary operators <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>,
<code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> on operands that are
bool or integral parameter expressions.</p></li>
<li><p>Applications of the binary operators <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>,
<code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> on operands
that are real, imaginary or complex parameter expressions.</p></li>
<li><p>Applications of the string concatenation operator <code class="docutils literal notranslate"><span class="pre">+</span></code>, string
comparison operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and
the string length and byte methods on parameter string expressions.</p></li>
<li><p>The conditional expression where the condition is a parameter and the
then- and else-expressions are parameters.</p></li>
<li><p>Call expressions of parameter functions.
See <a class="reference internal" href="procedures.html#param-return-intent"><span class="std std-ref">The Param Return Intent</span></a>.</p></li>
</ul>
</div>
<div class="section" id="runtime-constants">
<span id="id9"></span><h3>Runtime Constants<a class="headerlink" href="#runtime-constants" title="Permalink to this headline">¶</a></h3>
<p>Runtime constants, or simply “constants”, do not have the restrictions
that are associated with parameters. Constants can be of any type.
Whether initialized explicitly or via its type’s default value, a
constant stores the same value throughout its lifetime.</p>
<p>A variable of a class type that is a constant is a constant reference.
That is, the variable always points to the object that it was
initialized to reference. However, the fields of that object are allowed
to be modified.</p>
</div>
</div>
<div class="section" id="configuration-variables">
<span id="id10"></span><h2>Configuration Variables<a class="headerlink" href="#configuration-variables" title="Permalink to this headline">¶</a></h2>
<p>If the keyword <code class="docutils literal notranslate"><span class="pre">config</span></code> precedes the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span></code>, or
<code class="docutils literal notranslate"><span class="pre">param</span></code>, the variable, constant, or parameter is called a
configuration variable, configuration constant, or configuration
parameter respectively. Such variables, constants, and parameters must
be declared at the module level.</p>
<p>The default initialization of such variables can be overridden via
implementation-dependent means, such as command-line switches or
configuration files.  When overridden in this manner, the initialization
expression in the program is ignored.</p>
<p>Configuration parameters are set at compilation time via compilation
flags or other implementation-defined means. The value passed via these
means can be an arbitrary Chapel expression as long as the expression
can be evaluated at compile-time. If present, the value thus supplied
overrides the default value appearing in the Chapel code.</p>
<blockquote>
<div><p><em>Example (config-param.chpl)</em>.</p>
<p>For example,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">param</span> <span class="nx">rank</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>sets an integer parameter <code class="docutils literal notranslate"><span class="pre">rank</span></code> to <code class="docutils literal notranslate"><span class="pre">2</span></code>. At compile-time, this
default value of <code class="docutils literal notranslate"><span class="pre">rank</span></code> can be overridden with another parameter
expression, such as <code class="docutils literal notranslate"><span class="pre">3</span></code> or <code class="docutils literal notranslate"><span class="pre">2*n</span></code>, provided <code class="docutils literal notranslate"><span class="pre">n</span></code> itself is a
parameter. The <code class="docutils literal notranslate"><span class="pre">rank</span></code> configuration variable can be used to write
rank-independent code.</p>
</div></blockquote>
</div>
<div class="section" id="ref-variables">
<span id="id11"></span><h2>Ref Variables<a class="headerlink" href="#ref-variables" title="Permalink to this headline">¶</a></h2>
<p>A <em>ref</em> variable is a variable declared using the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword. A ref
variable serves as an alias to another variable, field or array element.
The declaration of a ref variable must contain <code class="docutils literal notranslate"><span class="pre">initialization-part</span></code>,
which specifies what is to be aliased and can be a variable or any
lvalue expression.</p>
<p>Access or update to a ref variable is equivalent to access or update to
the variable being aliased. For example, an update to a ref variable is
visible via the original variable, and visa versa.</p>
<p>If the expression being aliased is a runtime constant variable, a formal
argument with a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> concrete intent
(<a class="reference internal" href="procedures.html#concrete-intents"><span class="std std-ref">Concrete Intents</span></a>), or a call to a function with a
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent (<a class="reference internal" href="procedures.html#const-ref-return-intent"><span class="std std-ref">The Const Ref Return Intent</span></a>),
the corresponding ref variable must be declared as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>.
Parameter constants and expressions cannot be aliased.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>The behavior of a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> alias to a non-<code class="docutils literal notranslate"><span class="pre">const</span></code> variable
is an open issue. The options include disallowing such an alias,
disallowing changes to the variable while it can be accessed via a
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> alias, making changes visible through the alias, and
making the behavior undefined.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (refVariables.chpl)</em>.</p>
<p>For example, the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">myInt</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span>
<span class="kd">ref</span> <span class="nx">refInt</span> <span class="o">=</span> <span class="nx">myInt</span><span class="p">;</span>                   <span class="c1">// alias of the previous variable</span>
<span class="nx">myInt</span> <span class="o">=</span> <span class="mi">62</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;refInt = &quot;</span><span class="p">,</span> <span class="nx">refInt</span><span class="p">);</span>
<span class="nx">refInt</span> <span class="o">=</span> <span class="mi">73</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;myInt = &quot;</span><span class="p">,</span> <span class="nx">myInt</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">myArr</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">arrayElement</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="kd">ref</span>  <span class="k">return</span> <span class="nx">myArr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="kd">ref</span> <span class="nx">refToExpr</span> <span class="o">=</span> <span class="nx">arrayElement</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>      <span class="c1">// alias to lvalue returned by a function</span>
<span class="nx">myArr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">62</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;refToExpr = &quot;</span><span class="p">,</span> <span class="nx">refToExpr</span><span class="p">);</span>
<span class="nx">refToExpr</span> <span class="o">=</span> <span class="mi">73</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;myArr[3] = &quot;</span><span class="p">,</span> <span class="nx">myArr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

<span class="kd">const</span> <span class="nx">constArr</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">51</span><span class="o">..</span><span class="mi">53</span><span class="p">;</span>
<span class="kd">const</span> <span class="kd">ref</span> <span class="nx">myConstRef</span> <span class="o">=</span> <span class="nx">constArr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// would be an error without &#39;const&#39;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;myConstRef = &quot;</span><span class="p">,</span> <span class="nx">myConstRef</span><span class="p">);</span>
</pre></div>
</div>
<p>prints out:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>refInt = 62
myInt = 73
refToExpr = 62
myArr[3] = 73
myConstRef = 52
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="variable-conflicts">
<span id="id12"></span><h2>Variable Conflicts<a class="headerlink" href="#variable-conflicts" title="Permalink to this headline">¶</a></h2>
<p>If multiple variables defined in the same scope share a name, then a compilation
error will occur when that name is used.</p>
<p>An error will not occur if the would-be conflicting symbols are defined within
different scopes contained by the same outer scope.  For example, the following
code will not encounter a conflict when writing the symbol x:</p>
<blockquote>
<div><p><em>Example (conflict1.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Does not conflict with the earlier `x`</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>A variable will also conflict with other symbols defined in the same scope that
share a name with it.  While functions may share the same name (see
<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>), a function sharing a name with a variable in the
same scope will lead to conflicts.</p>
</div>
<div class="section" id="variable-lifetimes">
<span id="id13"></span><h2>Variable Lifetimes<a class="headerlink" href="#variable-lifetimes" title="Permalink to this headline">¶</a></h2>
<p>A variable only exists during its lifetime. The lifetime of a variable
begins when the variable is initialized.</p>
<p>A variable’s lifetime ends:</p>
<blockquote>
<div><ul class="simple">
<li><p>after copy elision if it occurred (after the last mention is
used to copy-initialize a variable or in intent argument) – see
<a class="reference internal" href="#copy-elision"><span class="std std-ref">Copy Elision</span></a>.</p></li>
<li><p>otherwise, at the variable’s deinit point (see <a class="reference internal" href="#deinit-points"><span class="std std-ref">Deinit Points</span></a>)</p></li>
</ul>
</div></blockquote>
<div class="section" id="deinit-points">
<span id="id14"></span><h3>Deinit Points<a class="headerlink" href="#deinit-points" title="Permalink to this headline">¶</a></h3>
<p>The compiler will add a deinitialization for each variable that is not
the source of copy elision. The deinitialization point is particularly
relevant for records and managed classes. For a record, the compiler will
call the record <code class="docutils literal notranslate"><span class="pre">deinit</span></code> method at the deinitialization point. See
<a class="reference internal" href="records.html#record-deinitializer"><span class="std std-ref">Record Deinitializer</span></a> for more details on this method.</p>
<p>Module-scope variables are destroyed at program tear-down as described in
<a class="reference internal" href="modules.html#module-deinitialization"><span class="std std-ref">Module Deinitialization</span></a>.</p>
<p>Fields are deinitialized when the containing class instance or record is
deinitialized.</p>
<p>Regular local variables are destroyed at the end of the containing block.
Temporary local variables have a different rule as described below.</p>
<p>The compiler adds temporary local variables to contain the result of
nested call expressions. <code class="docutils literal notranslate"><span class="pre">g()</span></code> in the statement <code class="docutils literal notranslate"><span class="pre">f(g());</span></code> is an
example of a nested call expression. If the containing statement is an
initialization expression for some variable, such as <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f(g());</span></code>,
then the temporary local variables for that statement are deinitialized at
the end of the containing block. Otherwise, the temporary local variables
are deinitialized at the end of the containing statement.</p>
<blockquote>
<div><p><em>Example (temporary-deinit-point.chpl)</em></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">makeRecord</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">R</span><span class="p">();</span> <span class="c1">// creates a new R record</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="kd">const</span> <span class="kd">ref</span> <span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">R</span><span class="p">();</span> <span class="c1">// ignores argument, returns new record</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">temporaryInDeclaration</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">makeRecord</span><span class="p">());</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
  <span class="c1">// &#39;x&#39; and the temporary result of &#39;makeRecord()&#39; are deinited here</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">temporaryInConstRefDeclaration</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="kd">ref</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">makeRecord</span><span class="p">());</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
  <span class="c1">// &#39;x&#39; and the temporary result of &#39;makeRecord()&#39; are deinited here</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">temporaryInStatement</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">makeRecord</span><span class="p">());</span>
  <span class="c1">// temporary result of &#39;f()&#39; and &#39;makeRecord()&#39; are deinited here</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="copy-and-move-initialization">
<span id="id15"></span><h3>Copy and Move Initialization<a class="headerlink" href="#copy-and-move-initialization" title="Permalink to this headline">¶</a></h3>
<p>This section uses the terminology <em>copy</em> and <em>move</em>. These terms
describe how a Chapel program initializes a variable based upon an
existing variable. Both <em>copy</em> and <em>move</em> create a new variable
from an initial variable.</p>
<p>Since records can use <code class="docutils literal notranslate"><span class="pre">init=</span></code> and <code class="docutils literal notranslate"><span class="pre">deinit</span></code> methods to adjust the
behavior of copy initialization, this section is particularly relevant
for records. In is also relevant for non-nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code> class types
since copies of those types will not be allowed by the compiler.</p>
<p>After a <em>copy</em>, both the new variable and the initial variable exist
separately. Generally speaking, they can both be modified.  However, they
should generally refer to different storage. In particular, changing a
field in the new record variable should not change the corresponding
field in the initial record variable.</p>
<p>A <em>move</em> is when a variable changes storage location. It is similar to a
<em>copy initialization</em> but it represents a transfer rather than
duplication. In particular, the initial record is no longer available
after the <em>move</em>.  A <em>move</em> can be thought of as an optimized form a
<em>copy</em> followed by destruction of the initial record.  After a <em>move</em>,
there is only one record variable - where after a <em>copy</em> there are two.</p>
<p>When a record is copied, it will run its <em>copy initializer</em> otherwise known
as <code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">init=</span></code>.</p>
<p>The compiler will choose whether to add <em>copy</em> or <em>move</em> initialization based
upon the pattern of variable mentions.</p>
<p>Here is an example of when <em>copy initialization</em> occurs:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="nx">R</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span><span class="nx">R</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>    <span class="c1">// copy initialization occurs here</span>
<span class="o">..</span><span class="p">.</span> <span class="nx">uses</span> <span class="nx">of</span> <span class="nx">both</span> <span class="nx">x</span> <span class="nx">and</span> <span class="nx">y</span> <span class="o">..</span><span class="p">.;</span>
</pre></div>
</div>
<p>Here is an example of when the compiler uses <em>move initialization</em>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">makeR</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">R</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">makeR</span><span class="p">();</span>    <span class="c1">// move initialization occurs here</span>
</pre></div>
</div>
<p>The remainder of this section describes situations in which a <em>copy</em>
or a <em>move</em> is added by the compiler to implement some kind of initialization.</p>
<p id="copy-move-table">When one variable is initialized from another variable or from a call
expression, the compiler must choose whether to perform <em>copy
initialization</em> or <em>move initialization</em>.</p>
<p>The following table shows in which situations a <em>copy</em> or <em>move
initialization</em> is added. Each row in this table corresponds to a
particular use of an expression <cite>&lt;expr&gt;</cite>. Each column indicates the kind
the expression <cite>&lt;expr&gt;</cite>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 15%" />
<col style="width: 18%" />
<col style="width: 15%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>operation</p></th>
<th class="head"><p>value call</p></th>
<th class="head"><p>local var
last mention</p></th>
<th class="head"><p>local var
mentioned
again</p></th>
<th class="head"><p>outer/ref</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>variable initialization</p></td>
<td><p>move</p></td>
<td><p>move</p></td>
<td><p>copy</p></td>
<td><p>copy</p></td>
</tr>
<tr class="row-odd"><td><p>value return</p></td>
<td><p>move</p></td>
<td><p>move</p></td>
<td><p>impossible</p></td>
<td><p>copy</p></td>
</tr>
</tbody>
</table>
<p>Here are definitions of the rows and columns:</p>
<dl class="simple">
<dt>variable initialization</dt><dd><p>means when a new variable is initialized in a variable declaration, in
a field initialization, or by the in argument intent.</p>
</dd>
<dt>value return</dt><dd><p>means that an expression is returned from a function by value</p>
</dd>
<dt>value call</dt><dd><p>means a function call that does not return with <code class="docutils literal notranslate"><span class="pre">ref</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>
return intent</p>
</dd>
<dt>local var last mention</dt><dd><p>means a use of a function-local variable which is not mentioned
again - see <a class="reference internal" href="#copy-elision"><span class="std std-ref">Copy Elision</span></a> for further details</p>
</dd>
<dt>local var mentioned again</dt><dd><p>means a use of a function-local variable which is mentioned again</p>
</dd>
<dt>outer/ref</dt><dd><p>means a use of a module-scope variable, an outer scope variable, or a
reference variable or argument</p>
</dd>
</dl>
</div>
<div class="section" id="copy-elision">
<span id="id16"></span><h3>Copy Elision<a class="headerlink" href="#copy-elision" title="Permalink to this headline">¶</a></h3>
<p>The compiler elides a <em>copy initialization</em> from a local <code class="docutils literal notranslate"><span class="pre">var</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span></code> variable when the source variable is not mentioned again. When
a <em>copy</em> is elided, the <em>copy initialization</em> is changed into <em>move
initialization</em> and the source variable is considered dead. Compile-time
analysis provides compilation errors when a variable is used after it is
dead in common cases.</p>
<p>Like split initialization, copy elision looks forward from variable
declaration points and considers mentions of variables to determine
whether or not a copy can be elided. After a copy, if the source variable
is not mentioned again, the copy will be elided.  Since a <code class="docutils literal notranslate"><span class="pre">return</span></code> or
<code class="docutils literal notranslate"><span class="pre">throw</span></code> exits a function, a copy can be elided if it is followed
immediately by a <code class="docutils literal notranslate"><span class="pre">return</span></code> or <code class="docutils literal notranslate"><span class="pre">throw</span></code>. When searching forward from
variable declarations, copy elision considers eliding copies only within
block declarations <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code>, <code class="docutils literal notranslate"><span class="pre">try</span></code> blocks, <code class="docutils literal notranslate"><span class="pre">try!</span></code> blocks, and
conditionals.</p>
<blockquote>
<div><p><em>Example (copy-elision.chpl)</em></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">const</span> <span class="nx">option</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">makeRecord</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">R</span><span class="p">();</span> <span class="c1">// creates a new R record</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">elideCopy</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">makeRecord</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// copy elided because &#39;x&#39; is not used again</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">elideCopy</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">noElideCopy</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">makeRecord</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>  <span class="c1">// copy is not elided because &#39;x&#39; is used again</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// &#39;x&#39; used here</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">noElideCopy</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">elideCopyInReturningConditional</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">makeRecord</span><span class="p">();</span>
  <span class="k">if</span> <span class="nx">option</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// copy elided because &#39;x&#39; is not used again</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;returning&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>    <span class="c1">// because this branch of conditional returns</span>
  <span class="p">}</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// mention of &#39;x&#39; here not relevant</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">elideCopyInReturningConditional</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">elideCopyBothConditional</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">makeRecord</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// split initialization below</span>
  <span class="k">if</span> <span class="nx">option</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// copy is elided because &#39;x&#39; is not used after the copy</span>
  <span class="c1">// (in either branch of the conditional or after it)</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;block ending&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">elideCopyBothConditional</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
<p>Copy elision does not apply:</p>
<blockquote>
<div><ul class="simple">
<li><p>when the source variable is a reference, field, or module-level
variable</p></li>
<li><p>when the copy statement is in one branch of a conditional but not in
the other, or when the other branch does not always <code class="docutils literal notranslate"><span class="pre">return</span></code> or
<code class="docutils literal notranslate"><span class="pre">throw</span></code>.</p></li>
<li><p>when the copy statement is in a <code class="docutils literal notranslate"><span class="pre">try</span></code> or <code class="docutils literal notranslate"><span class="pre">try!</span></code> block which has
<code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses that mention the variable or which has <code class="docutils literal notranslate"><span class="pre">catch</span></code>
clauses that do not always <code class="docutils literal notranslate"><span class="pre">throw</span></code> or <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="conversions.html" class="btn btn-neutral float-right" title="Conversions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="types.html" class="btn btn-neutral float-left" title="Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>