

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Modules &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Procedures" href="procedures.html" />
    <link rel="prev" title="Statements" href="statements.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/modules";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-definitions">Module Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prototype-modules">Prototype Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#files-and-implicit-modules">Files and Implicit Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nested-modules">Nested Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-of-module-contents">Access of Module Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#visibility-of-a-module">Visibility Of A Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visibility-of-a-modules-symbols">Visibility Of A Module’s Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-modules">Using Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#importing-modules">Importing Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qualified-naming-of-module-symbols">Qualified Naming of Module Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disabling-qualified-access">Disabling Qualified Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#re-exporting">Re-exporting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-initialization">Module Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-deinitialization">Module Deinitialization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#program-execution">Program Execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-main-function">The <em>main</em> Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-initialization-order">Module Initialization Order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-deinitialization-order">Module Deinitialization Order</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/modules.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="modules">
<span id="chapter-modules"></span><h1>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<p>Chapel supports modules to manage namespaces. A program consists of one
or more modules. Every symbol, including variables, functions, and
types, is associated with some module.</p>
<p>Module definitions are described in <a class="reference internal" href="#module-definitions"><span class="std std-ref">Module Definitions</span></a>.
The relation between files and modules is described
in <a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>. Nested modules are described
in <a class="reference internal" href="#nested-modules"><span class="std std-ref">Nested Modules</span></a>. The visibility of a module’s symbols
by users of the module is described
in <a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>. The execution of a program
and module initialization/deinitialization are described
in <a class="reference internal" href="#program-execution"><span class="std std-ref">Program Execution</span></a>.</p>
<div class="section" id="module-definitions">
<span id="id1"></span><h2>Module Definitions<a class="headerlink" href="#module-definitions" title="Permalink to this headline">¶</a></h2>
<p>A module is declared with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>module-declaration-statement:
  privacy-specifier[OPT] prototype-specifier[OPT] &#39;module&#39; module-identifier block-statement

privacy-specifier:
  &#39;private&#39;
  &#39;public&#39;

prototype-specifier:
  &#39;prototype&#39;

module-identifier:
  identifier
</pre></div>
</div>
<p>A module’s name is specified after the <code class="docutils literal notranslate"><span class="pre">module</span></code> keyword. The
<code class="docutils literal notranslate"><span class="pre">block-statement</span></code> opens the module’s scope. Symbols defined in this
block statement are defined in the module’s scope and are called
<em>module-scope symbols</em>. The visibility of a module is defined by its
<code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code>  (<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>).</p>
<p>Module declaration statements are only legal as file-scope or
module-scope statements. For example, module declaration statements may
not occur within block statements, functions, classes, or records.</p>
<p>Any module declaration that is not contained within another module
creates a <em>top-level module</em>. Module declarations within other modules
create nested modules (<a class="reference internal" href="#nested-modules"><span class="std std-ref">Nested Modules</span></a>).</p>
</div>
<div class="section" id="prototype-modules">
<span id="id2"></span><h2>Prototype Modules<a class="headerlink" href="#prototype-modules" title="Permalink to this headline">¶</a></h2>
<p>Modules that are declared with the <code class="docutils literal notranslate"><span class="pre">prototype</span></code> keyword use relaxed
rules for error handling. These relaxed rules are
appropriate for programs in the early stages of development but are not
appropriate for libraries. In particular, within a <code class="docutils literal notranslate"><span class="pre">prototype</span></code> module
errors that are not handled will terminate the program
(see <a class="reference internal" href="error-handling.html#errors-prototype-mode"><span class="std std-ref">Prototype Mode</span></a>).</p>
<p>Implicit modules (<a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>) are implicitly considered
<code class="docutils literal notranslate"><span class="pre">prototype</span></code> modules as well.</p>
</div>
<div class="section" id="files-and-implicit-modules">
<span id="implicit-modules"></span><h2>Files and Implicit Modules<a class="headerlink" href="#files-and-implicit-modules" title="Permalink to this headline">¶</a></h2>
<p>Multiple modules can be defined within the same file and need not bear
any relation to the file in terms of their names.</p>
<blockquote>
<div><p><em>Example (two-modules.chpl)</em>.</p>
<p>The following file contains two explicitly named modules, MX and MY.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">MX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Module MX&quot;</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">MY</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Module MY&quot;</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Module MX defines module-scope symbols x and printX, while MY defines
module-scope symbols y and printY.</p>
</div></blockquote>
<p>For any file that contains file-scope statements other than module
declarations, the file itself is treated as a module declaration. In
this case, the module is implicit. Implicit modules are always
<code class="docutils literal notranslate"><span class="pre">prototype</span></code> modules (<a class="reference internal" href="#prototype-modules"><span class="std std-ref">Prototype Modules</span></a>).
An implicit module takes its name from the base
filename. In particular, the module name is defined as the remaining
string after removing the <code class="docutils literal notranslate"><span class="pre">.chpl</span></code> suffix and any path specification
from the specified filename. If the resulting name is not a legal Chapel
identifier, it cannot be referenced in a use statement.</p>
<blockquote>
<div><p><em>Example (implicit.chpl)</em>.</p>
<p>The following file, named implicit.chpl, defines an implicitly named
module called implicit.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Module implicit defines the module-scope symbols x, y, printX, and
printY.</p>
</div></blockquote>
</div>
<div class="section" id="nested-modules">
<span id="id3"></span><h2>Nested Modules<a class="headerlink" href="#nested-modules" title="Permalink to this headline">¶</a></h2>
<p>A <em>nested module</em> (or <em>sub-module</em>) is a module that is defined within
another module, known as the outer, or parent, module.  An outer
module can refer to the names of its sub-modules directly without a
<code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statement.  However, a sub-module must <code class="docutils literal notranslate"><span class="pre">use</span></code>
or <code class="docutils literal notranslate"><span class="pre">import</span></code> its parent module in order to refer to its name or
symbols.</p>
<p>An inner module’s symbols can be referenced without accessing those of
its parent module by naming the inner module in a qualified manner
within the <code class="docutils literal notranslate"><span class="pre">use</span></code> statement.</p>
<blockquote>
<div><p><em>Example (nested-use.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span>  <span class="k">use</span> <span class="nx">libsci</span><span class="p">.</span><span class="nx">blas</span><span class="p">;</span>

<span class="o">..</span> <span class="nx">BLOCK</span><span class="o">-</span><span class="nx">test</span><span class="o">-</span><span class="nx">chapelpost</span>

  <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>uses a module named <code class="docutils literal notranslate"><span class="pre">blas</span></code> that is nested within a module named
<code class="docutils literal notranslate"><span class="pre">libsci</span></code>.</p>
</div></blockquote>
<p>Files with both module declarations and file-scope statements result in
nested modules.</p>
<blockquote>
<div><p><em>Example (nested.chpl)</em>.</p>
<p>The following file, named nested.chpl, defines an implicitly named
module called nested, with nested modules MX and MY.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">MX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">MY</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nx">MX</span><span class="p">,</span> <span class="nx">MY</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="access-of-module-contents">
<span id="id4"></span><h2>Access of Module Contents<a class="headerlink" href="#access-of-module-contents" title="Permalink to this headline">¶</a></h2>
<p>A module’s contents can be accessed by code outside of that module depending on
the visibility of the module itself (<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>) and the
visibility of each individual symbol (<a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>). This can be
done via the use statement (<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>), the import
statement (<a class="reference internal" href="#importing-modules"><span class="std std-ref">Importing Modules</span></a>) or qualified
naming (<a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a>).</p>
<div class="section" id="visibility-of-a-module">
<span id="id5"></span><h3>Visibility Of A Module<a class="headerlink" href="#visibility-of-a-module" title="Permalink to this headline">¶</a></h3>
<p>A top-level module is available for use (<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>) or import
(<a class="reference internal" href="#importing-modules"><span class="std std-ref">Importing Modules</span></a>) anywhere.  A module name is not accessible in other
statements or expressions unless an <code class="docutils literal notranslate"><span class="pre">import</span></code> or <code class="docutils literal notranslate"><span class="pre">use</span></code> statement has brought
the name into scope.</p>
<p>Additionally, <code class="docutils literal notranslate"><span class="pre">use</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span></code> can both name a module with a relative
path; for example, <code class="docutils literal notranslate"><span class="pre">this.Submodule</span></code> or <code class="docutils literal notranslate"><span class="pre">super.Siblingmodule</span></code>.  <code class="docutils literal notranslate"><span class="pre">use</span></code> and
<code class="docutils literal notranslate"><span class="pre">import</span></code> differ in their behavior towards a named module when two conditions
are both true: when the named module is not a top-level module and when a
relative path is not provided.</p>
<p>For the purpose of <code class="docutils literal notranslate"><span class="pre">use</span></code>, the visibility of a nested module is subject to the
rules of <a class="reference internal" href="#visibility-of-symbols"><span class="std std-ref">Visibility Of A Module’s Symbols</span></a>, where the nested module is considered a
“module-scope symbol” of its outer module.  If the module is currently in scope,
then it may be used with just its name.  The module may alternatively be
accessed explicitly with all the outer modules surrounding it to the top level,
or relatively from the current scope with <code class="docutils literal notranslate"><span class="pre">this</span></code> or <code class="docutils literal notranslate"><span class="pre">super</span></code> components as
has already been mentioned.</p>
<p>Now, let’s consider how <code class="docutils literal notranslate"><span class="pre">import</span></code> interacts with a nested module.  In order to
<code class="docutils literal notranslate"><span class="pre">import</span></code> it, either all the outer modules surrounding it to the top level must
be provided as part of the path to the module, or a <code class="docutils literal notranslate"><span class="pre">super</span></code> or <code class="docutils literal notranslate"><span class="pre">this</span></code> prefix
may be provided as has already been mentioned.  The nested module cannot be
imported with just its name, even from the scope in which the module is defined,
unless it has already been brought into scope by another <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement.</p>
</div>
<div class="section" id="visibility-of-a-modules-symbols">
<span id="visibility-of-symbols"></span><h3>Visibility Of A Module’s Symbols<a class="headerlink" href="#visibility-of-a-modules-symbols" title="Permalink to this headline">¶</a></h3>
<p>A symbol defined at module scope is <em>visible</em> from outside the module when the
<code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code> of its definition is <code class="docutils literal notranslate"><span class="pre">public</span></code> or is omitted (i.e. by
default). When a module-scope symbol is declared <code class="docutils literal notranslate"><span class="pre">private</span></code>, it is not visible
outside of that module. A symbol’s visibility inside its module is controlled by
normal lexical scoping and is not affected by its <code class="docutils literal notranslate"><span class="pre">privacy-specifier</span></code>. When a
module’s symbol is visible (<a class="reference internal" href="#visibility-of-a-module"><span class="std std-ref">Visibility Of A Module</span></a>), the visible symbols
it contains are accessible via the use statement (<a class="reference internal" href="#using-modules"><span class="std std-ref">Using Modules</span></a>), import
statement (<a class="reference internal" href="#importing-modules"><span class="std std-ref">Importing Modules</span></a>), or qualified
naming (<a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a>).</p>
<div class="section" id="using-and-importing">
<span id="id6"></span><h4>Using and Importing<a class="headerlink" href="#using-and-importing" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">use</span></code> statement and the <code class="docutils literal notranslate"><span class="pre">import</span></code> statement are the two primary ways to
access a module’s symbols from outside of the module.  For top-level modules, a
<code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statement is required before referring to the module’s
name or the symbols it contains within a given lexical scope.</p>
<p>The names that are made visible by a <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statement are
inserted in to a new scope that immediately encloses the scope within which the
statement appears.  This implies that the position of the <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement within a scope has no effect on its behavior.  If a scope includes
multiple <code class="docutils literal notranslate"><span class="pre">use</span></code> statements, multiple <code class="docutils literal notranslate"><span class="pre">import</span></code> statements, or a combination of
<code class="docutils literal notranslate"><span class="pre">import</span></code> and <code class="docutils literal notranslate"><span class="pre">use</span></code> statements, then the newly-visible names are inserted
into a common enclosing scope.</p>
</div>
<div class="section" id="conflicts">
<span id="use-and-import-conflicts"></span><h4>Conflicts<a class="headerlink" href="#conflicts" title="Permalink to this headline">¶</a></h4>
<p>The implicit scope added by <code class="docutils literal notranslate"><span class="pre">use</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span></code> described in the previous
section follows the same rules about conflicting variables as other scopes (see
<a class="reference internal" href="variables.html#variable-conflicts"><span class="std std-ref">Variable Conflicts</span></a>).  Thus an error will be signaled if multiple
variables with the same name would be inserted into this enclosing scope and
that name is accessed.  Remember that this does not apply to functions unless
they are also indistinguishable in other ways, see <a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>.</p>
<p>Because symbols brought into scope by a <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statement are
placed at a scope enclosing where the statement appears, such symbols will be
shadowed by other symbols with the same name defined in the scope with the
statement.  The symbols that are shadowed will only be accessible via
<a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a>.</p>
<p>Symbols defined by public <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code> statements can impact the scope
they are inserted into in different ways (see <a class="reference internal" href="#public-use"><span class="std std-ref">Public and Private Use Statements</span></a> and
<a class="reference internal" href="#reexporting"><span class="std std-ref">Re-exporting</span></a> for more information on the <code class="docutils literal notranslate"><span class="pre">public</span></code> keyword).  Symbols
that are brought in by a <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">use</span></code> for unqualified access are treated as
at successive distances relative to how many <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">use</span></code> statements were
necessary to obtain them.  For instance,</p>
<blockquote>
<div><p><em>Example (conflict1.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">use</span> <span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">MainMod</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code demonstrates a module (MainMod) using two modules, B and C.  Module
C defines a symbol named x, while module B publicly uses another module, A,
which also defines a symbol named x.  The program as written will compile and
will print out the value of <code class="docutils literal notranslate"><span class="pre">C.x</span></code>, which is <code class="docutils literal notranslate"><span class="pre">false</span></code>, because A’s x is
considered further away (it is made available to MainMod through <cite>two</cite> use
statements instead of just one).  Thus, it will generate the following
output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>false
</pre></div>
</div>
<p>If, however, C had been publicly used by another module D and that was used
by MainMod instead, then the compiler cannot determine which of <code class="docutils literal notranslate"><span class="pre">C.x</span></code> and
<code class="docutils literal notranslate"><span class="pre">A.x</span></code> was intended for <code class="docutils literal notranslate"><span class="pre">writeln(x);</span></code>.  The program must use qualified
access to indicate which x to access.</p>
</div></blockquote>
<p>Symbols brought in directly by a <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">import</span></code> are treated as though defined
<em>at</em> the scope with the <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">import</span></code> for the purpose of determining
conflicts (see <a class="reference internal" href="#reexporting"><span class="std std-ref">Re-exporting</span></a>).  This means that if the <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">use</span></code> in
module B of the previous example was instead replaced with a <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">import</span>
<span class="pre">A.x</span></code>, A’s x would conflict with <code class="docutils literal notranslate"><span class="pre">C.x</span></code> when resolving the main function’s
body.</p>
</div>
</div>
<div class="section" id="using-modules">
<span id="id7"></span><h3>Using Modules<a class="headerlink" href="#using-modules" title="Permalink to this headline">¶</a></h3>
<p>By default, use statements make both a module’s name and its public symbols
available for access within a given scope.</p>
<p>The syntax of the use statement is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>use-statement:
  privacy-specifier[OPT] &#39;use&#39; module-or-enum-name-list ;

module-or-enum-name-list:
  module-or-enum-name limitation-clause[OPT]
  module-or-enum-name , module-or-enum-name-list

module-or-enum-name:
  rename-base
  identifier . module-or-enum-name

limitation-clause:
  &#39;except&#39; exclude-list
  &#39;only&#39; rename-list[OPT]

exclude-list:
  identifier-list
  $ * $

rename-list:
  rename-base
  rename-base , rename-list

rename-base:
  identifier &#39;as&#39; identifier
  identifier &#39;as&#39; _
  identifier
</pre></div>
</div>
<p>For example, the program</p>
<blockquote>
<div><p><em>Example (use1.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s foo.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s main.&quot;</span><span class="p">);</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M2&#39;s main.
In M1&#39;s foo.
</pre></div>
</div>
</div></blockquote>
<p>This program is equivalent to:</p>
<blockquote>
<div><p><em>Example (use2.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s foo.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>

    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s main.&quot;</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which also prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M2&#39;s main.
In M1&#39;s foo.
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">module-or-enum-name</span></code> in a <code class="docutils literal notranslate"><span class="pre">use</span></code> statement must begin with one of
the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>a top-level module name</p></li>
<li><p>a submodule of the current module</p></li>
<li><p>a module name currently in scope due to another <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement</p></li>
<li><p>any number of <code class="docutils literal notranslate"><span class="pre">super</span></code> components to indicate a number of parents of
the current module (e.g. <code class="docutils literal notranslate"><span class="pre">super.super.SomeModule</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> to indicate the requested module is a submodule of the
current module</p></li>
</ul>
</div></blockquote>
<p>A module or enum being used may optionally be given a new name using the <code class="docutils literal notranslate"><span class="pre">as</span></code>
keyword.  This new name will be usable from the scope of the use in place of the
old name.  This new name does not affect uses or imports of that module from
other contexts.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword can also be used to disable accesses to the module name while
still allowing accesses to the symbols within the module.  See the
<a class="reference internal" href="#disabling-qualified"><span class="std std-ref">Disabling Qualified Access</span></a> section for more information.</p>
<div class="section" id="public-and-private-use-statements">
<span id="public-use"></span><h4>Public and Private Use Statements<a class="headerlink" href="#public-and-private-use-statements" title="Permalink to this headline">¶</a></h4>
<p>Use statements may be explicitly declared <code class="docutils literal notranslate"><span class="pre">public</span></code> or <code class="docutils literal notranslate"><span class="pre">private</span></code>.
By default, uses are <code class="docutils literal notranslate"><span class="pre">private</span></code>.  Making a use <code class="docutils literal notranslate"><span class="pre">public</span></code> causes its
symbols to be transitively visible: if module A uses module B, and
module B contains a public use of a module or enumerated type C, then
C’s public symbols will also be visible to A unless they are shadowed
by symbols of the same name in B.  Conversely, if B’s use of C is
<code class="docutils literal notranslate"><span class="pre">private</span></code> then A will not be able to see C’s symbols due to that
<code class="docutils literal notranslate"><span class="pre">use</span></code>.</p>
<p>This notion of transitivity extends to the case in which a scope
imports symbols from multiple modules or constants from multiple
enumeration types. For example if a module A uses modules B1, B2, B3
and modules B1, B2, B3 publicly use modules C1, C2, C3 respectively,
then all of the public symbols in B1, B2, B3 have the potential to
shadow the public symbols of C1, C2, and C3. However an error is
signaled if C1, C2, C3 have conflicting public module-level
definitions of the same symbol.</p>
<p>Making a use <code class="docutils literal notranslate"><span class="pre">public</span></code> additionally causes its symbols to be visible as though
they were defined in the scope with the use.  This strategy is called
<cite>re-exporting</cite>.  More information about re-exporting can be found in the
relevant section (<a class="reference internal" href="#reexporting"><span class="std std-ref">Re-exporting</span></a>).</p>
</div>
<div class="section" id="except-and-only-lists">
<span id="limitation-clauses"></span><h4>Except and Only Lists<a class="headerlink" href="#except-and-only-lists" title="Permalink to this headline">¶</a></h4>
<p>An optional <code class="docutils literal notranslate"><span class="pre">limitation-clause</span></code> may be provided to limit the symbols made
available by a given use statement. If an <code class="docutils literal notranslate"><span class="pre">except</span></code> list is provided, then all
the visible but unlisted symbols in the module or enumerated type will be made
available without prefix. If an <code class="docutils literal notranslate"><span class="pre">only</span></code> list is provided, then just the listed
visible symbols in the module or enumerated type will be made available without
prefix. All visible symbols not provided via these limited use statements are
still accessible by prefixing the access with the name of the module or
enumerated type (unless the module has been renamed to <code class="docutils literal notranslate"><span class="pre">_</span></code>, as described
earlier). It is an error to provide a name in a <code class="docutils literal notranslate"><span class="pre">limitation-clause</span></code> that does
not exist or is not visible in the respective module or enumerated type.</p>
<p>If a type or type’s secondary methods are defined in the used module, then any
instances of the type obtained in the scope of the use may access the fields and
methods of that type, regardless of the <code class="docutils literal notranslate"><span class="pre">limitation-clause</span></code>. These fields
and methods cannot be specified in a <code class="docutils literal notranslate"><span class="pre">limitation-clause</span></code> on their own.  The
privacy of use statements is also ignored when determining if an instance can
access the fields and methods, for similar reasons.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">only</span></code> list is left empty or <code class="docutils literal notranslate"><span class="pre">except</span></code> is followed by <span class="math notranslate nohighlight">\(*\)</span>
then no symbols are made available to the scope without prefix. However,
any methods or fields defined within a module used in this way will
still be accessible on instances of the type. For example:</p>
<blockquote>
<div><p><em>Example (limited-access.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">record</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In A.foo()&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nx">M1</span> <span class="k">only</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">M1</span><span class="p">.</span><span class="nx">A</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Only accessible via the module prefix</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// Accessible because we have a record instance</span>
    <span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// Ditto</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>will print out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>3
In A.foo()
</pre></div>
</div>
</div></blockquote>
<p>Within an <code class="docutils literal notranslate"><span class="pre">only</span></code> list, a visible symbol from that module may optionally be
given a new name using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword. This new name will be usable from the
scope of the use in place of the old name unless the old name is additionally
specified in the <code class="docutils literal notranslate"><span class="pre">only</span></code> list. If a use which renames a symbol is present at
module scope, uses and imports of that module will also be able to access
that symbol using the new name instead of the old name. Renaming does not affect
accesses to that symbol via the source module’s or enumerated type’s prefix, nor
does it affect uses or imports of that module or enumerated type from other
contexts. It is an error to attempt to rename a symbol that does not exist or is
not visible in the respective module or enumerated type, or to rename a symbol
to a name that is already present in the same <code class="docutils literal notranslate"><span class="pre">only</span></code> list. It is, however,
perfectly acceptable to rename a symbol to a name present in the respective
module or enumerated type which was not specified via that <code class="docutils literal notranslate"><span class="pre">only</span></code> list.</p>
<p>If a use statement mentions multiple modules or enumerated types or a
mix of these symbols, only the last module or enumerated type can have a
<code class="docutils literal notranslate"><span class="pre">limitation-clause</span></code>. Limitation clauses are applied transitively as
well - in the first example, if module A’s use of module B contains an
<code class="docutils literal notranslate"><span class="pre">except</span></code> or <code class="docutils literal notranslate"><span class="pre">only</span></code> list, that list will also limit which of C’s
symbols are visible to A.</p>
</div>
<div class="section" id="using-enums">
<span id="id8"></span><h4>Using Enums<a class="headerlink" href="#using-enums" title="Permalink to this headline">¶</a></h4>
<p>Aside from modules, only enums can be listed as the last portion of a <code class="docutils literal notranslate"><span class="pre">use</span></code>
statement’s <code class="docutils literal notranslate"><span class="pre">module-or-enum-name</span></code>.  Doing so enables its constants to be
accessible without the enum’s name as a prefix (see <a class="reference internal" href="#explicit-naming"><span class="std std-ref">Qualified Naming of Module Symbols</span></a> for
how to access its constants normally).</p>
<p>For more information on enumerated types, please see <a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>.</p>
</div>
</div>
<div class="section" id="importing-modules">
<span id="id9"></span><h3>Importing Modules<a class="headerlink" href="#importing-modules" title="Permalink to this headline">¶</a></h3>
<p>The import statement provides either only qualified access to all of the public
symbols of a module or only unqualified access to the specified public symbols
of a module.</p>
<p>The syntax of the import statement is given by:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>import-statement:
  privacy-specifier[OPT] &#39;import&#39; import-expression-list ;

import-expression-list:
  import-expression
  import-expression , import-expression-list

import-expression:
  module-or-symbol-rename
  module-or-symbol-base unqualified-list

module-or-symbol-rename:
  rename-base
  identifier . module-or-symbol-rename

module-or-symbol-base:
  identifier
  identifier . module-or-symbol-base

unqualified-list:
  . { rename-list }
</pre></div>
</div>
<p>For example, the program</p>
<blockquote>
<div><p><em>Example (import1.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s foo.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">import</span> <span class="nx">M1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s main.&quot;</span><span class="p">);</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M2&#39;s main.
In M1&#39;s foo.
</pre></div>
</div>
</div></blockquote>
<p>This program is equivalent to:</p>
<blockquote>
<div><p><em>Example (import2.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s foo.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">import</span> <span class="nx">M1</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>

    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s main.&quot;</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which also prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M2&#39;s main.
In M1&#39;s foo.
</pre></div>
</div>
</div></blockquote>
<p>And both programs are also equivalent to:</p>
<blockquote>
<div><p><em>Example (import3.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s foo.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">import</span> <span class="nx">M1</span><span class="p">.{</span><span class="nx">foo</span><span class="p">};</span>

    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s main.&quot;</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which also prints out</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M2&#39;s main.
In M1&#39;s foo.
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">module-or-symbol-rename</span></code> or <code class="docutils literal notranslate"><span class="pre">module-or-symbol-base</span></code> in an <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement must begin with one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>a top-level module name</p></li>
<li><p>a module name currently in scope due to another <code class="docutils literal notranslate"><span class="pre">use</span></code> or <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement</p></li>
<li><p>any number of <code class="docutils literal notranslate"><span class="pre">super</span></code> components to indicate a number of parents of the
current module (e.g. <code class="docutils literal notranslate"><span class="pre">super.super.SomeModule</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> to indicate the requested module is a submodule of the current
module</p></li>
</ul>
</div></blockquote>
<p>A submodule may not be imported without either the full path to it, or a
<code class="docutils literal notranslate"><span class="pre">super</span></code> or <code class="docutils literal notranslate"><span class="pre">this</span></code> prefix at the beginning of the path.</p>
<p>A module or a public module-level symbol being imported may optionally be given
a new name using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword.  This new name will be usable from the
scope of the import in place of the old name.  This new name does not affect
imports or uses of that module from other contexts.</p>
<p>Import statements may be explicitly declared <code class="docutils literal notranslate"><span class="pre">public</span></code> or <code class="docutils literal notranslate"><span class="pre">private</span></code>.  By
default, imports are <code class="docutils literal notranslate"><span class="pre">private</span></code>.  Making an import <code class="docutils literal notranslate"><span class="pre">public</span></code> causes its
symbols to be visible as though they were defined in the scope with the import,
a strategy which will be referred to as <cite>re-exporting</cite>.  More information about
re-exporting can be found in the relevant section (<a class="reference internal" href="#reexporting"><span class="std std-ref">Re-exporting</span></a>).</p>
<p>The import statement may specify a single module or module-level symbol, or it
may specify multiple module-level symbols in the <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>.  Unlike
<code class="docutils literal notranslate"><span class="pre">use</span></code> statements, symbols specified for unqualified access are not able to be
accessed with the module qualifier.  A separate import statement may be provided
to enable this behavior.  It is an error to provide a name in an
<code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code> that does not exist or is not visible in the respective
module.</p>
<p>If a type or type’s secondary methods are defined in the imported module, then
any instances of the type obtained in the scope of the import may access the
fields and methods of that type, regardless of the <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>. These
fields and methods cannot be specified in an <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code> on their own.
The privacy of import statements is also ignored when determining if an instance
can access the fields and methods, for similar reasons.</p>
<p>Within an <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>, a visible symbol from that module may optionally
be given a new name using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword.  This new name will be usable from
the scope of the import in place of the old name unless the old name is
additionally specified in the <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>.  If an import which renames
a symbol is present at module scope, imports and uses of that module will also
be able to access that symbol using the new name instead of the old name.
Renaming does not affect accesses to that symbol via the source module’s prefix,
nor does it affect imports or uses of that module from other contexts.  It is an
error to attempt to rename a symbol that does not exist or is not visible in the
respective module, or to rename a symbol to a name that is already present in
the same <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>.  It is, however, perfectly acceptable to rename a
symbol to a name present in the respective module which was not specified via
that <code class="docutils literal notranslate"><span class="pre">unqualified-list</span></code>.</p>
<p>The list of symbols for unqualified access can also be applied transitively -
in the second example of re-exporting, if module A’s import of B only allowed
access to certain symbols, that list will also limit which of the symbols from
C1, C2, and C3 will be available to A.</p>
</div>
<div class="section" id="qualified-naming-of-module-symbols">
<span id="explicit-naming"></span><h3>Qualified Naming of Module Symbols<a class="headerlink" href="#qualified-naming-of-module-symbols" title="Permalink to this headline">¶</a></h3>
<p>When a module’s symbol is visible—via a use or import statement, or lexically
for nested modules—its public symbols can be accessed via qualified naming with
the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>module-access-expression:
  module-identifier-list . identifier

module-identifier-list:
  module-identifier
  module-identifier . module-identifier-list
</pre></div>
</div>
<p>This allows two symbols that have the same name to be distinguished
based on the name of their module. Using qualified naming in a function
call restricts the set of candidate functions to those in the specified
module.</p>
<p>If code tries to access a symbol that conflicts with one or more other symbols
defined in other modules, the compiler will issue an error. Qualified naming can
be used to disambiguate the symbols in this case.</p>
<blockquote>
<div><p><em>Example (ambiguity.chpl)</em>.</p>
<p>In the following example,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M1&#39;s x is: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M1&#39;s y is: &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M3</span><span class="p">;</span>
  <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">printX</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M2&#39;s x is: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">printX</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="nx">printX</span><span class="p">();</span> <span class="c1">// This is not ambiguous</span>
    <span class="nx">printY</span><span class="p">();</span> <span class="c1">// ERROR: This is ambiguous</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M3</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">printY</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M3&#39;s y is: &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to printX() is not ambiguous because M2’s definition shadows
that of M1. On the other hand, the call to printY() is ambiguous
because it is defined in both M1 and M3. This will result in a
compiler error. The call could be qualified via M1.printY() or
M3.printY() to resolve this ambiguity.</p>
</div></blockquote>
</div>
<div class="section" id="disabling-qualified-access">
<span id="disabling-qualified"></span><h3>Disabling Qualified Access<a class="headerlink" href="#disabling-qualified-access" title="Permalink to this headline">¶</a></h3>
<p>While import statements are naturally set up to choose between enabling
qualified or unqualified access, use statements by default always enable at
least qualified access to a module’s symbols.  This can be disabled for a
particular use statement by providing <code class="docutils literal notranslate"><span class="pre">_</span></code> as the new name for the module.</p>
<p>When a module is renamed to <code class="docutils literal notranslate"><span class="pre">_</span></code>, symbols within it will only be accessible
without a module name prefix - no prefix will be usable to access the symbol.
For example:</p>
<blockquote>
<div><p><em>Example (use-no-qualified.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">bSymbol</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">B</span> <span class="k">as</span> <span class="nx">_</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">bSymbol</span><span class="p">);</span>
    <span class="c1">// writeln(B.bSymbol); // Would not work</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this code, module A uses a module B and renames B to <code class="docutils literal notranslate"><span class="pre">_</span></code>.  B defines a
symbol <code class="docutils literal notranslate"><span class="pre">bSymbol</span></code>, which means that A can contain accesses to <code class="docutils literal notranslate"><span class="pre">bSymbol</span></code>,
but cannot contain accesses to <code class="docutils literal notranslate"><span class="pre">B.bSymbol</span></code> or <code class="docutils literal notranslate"><span class="pre">_.bSymbol</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="re-exporting">
<span id="reexporting"></span><h3>Re-exporting<a class="headerlink" href="#re-exporting" title="Permalink to this headline">¶</a></h3>
<p>Making a use or import <code class="docutils literal notranslate"><span class="pre">public</span></code> causes the symbols brought in by that
statement to be visible as though they were defined in the scope with the use or
import, a strategy which will be referred to as <cite>re-exporting</cite>.  However,
symbols with the same name in the scope with the use or import will still take
precedence.</p>
<blockquote>
<div><p><em>Example (use-reexport1.chpl)</em>.</p>
<p>Say we have a module A that uses a module B, and module B contains a public
use of module C:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cSymbol</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">use</span> <span class="nx">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nx">B</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">C</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, C will be visible to A as though it was a submodule of B, and
its symbols can also be treated as though they were defined within B.  This
means that A can contain mentions like <code class="docutils literal notranslate"><span class="pre">B.C.cSymbol</span></code> if cSymbol was a
symbol defined in C, regardless of if C was actually a submodule of B.</p>
<p>This also means that A can contain mentions like <code class="docutils literal notranslate"><span class="pre">B.cSymbol</span></code> which would
access C’s cSymbol, assuming these symbols were not shadowed by symbols with
the same name in B.</p>
<p><em>Example (use-reexport2.chpl)</em>.</p>
<p>However, if the public use of C also disabled accesses to the module name
using the <code class="docutils literal notranslate"><span class="pre">as</span></code> keyword, e.g.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cSymbol</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">use</span> <span class="nx">C</span> <span class="k">as</span> <span class="nx">_</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nx">B</span><span class="p">;</span>
    <span class="c1">// writeln(B.C.cSymbol); // Would not work</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then A could only contain mentions like <code class="docutils literal notranslate"><span class="pre">B.cSymbol</span></code>, it could not access
<code class="docutils literal notranslate"><span class="pre">cSymbol</span></code> using <code class="docutils literal notranslate"><span class="pre">B.C.cSymbol</span></code>.  This is because C is not present as a
public name in B’s scope.</p>
</div></blockquote>
<p>Conversely, if B’s use of C was <code class="docutils literal notranslate"><span class="pre">private</span></code> then A would not be able to see C’s
symbols at all due to that <code class="docutils literal notranslate"><span class="pre">use</span></code>.</p>
<p>The situation for <code class="docutils literal notranslate"><span class="pre">import</span></code> is similar.  Because import statements only
enable either qualified or unqualified access to a symbol, it more closely
resembles the second example instead of the first.</p>
<blockquote>
<div><p><em>Example (import-reexport1.chpl)</em>.</p>
<p>Say we have a module A that imports module B, and module B contains a public
import of module C:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cSymbol</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">import</span> <span class="nx">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">import</span> <span class="nx">B</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">C</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, C will be visible to A as though it was a submodule of B.  This
means that A can contain mentions like <code class="docutils literal notranslate"><span class="pre">B.C.cSymbol</span></code> if cSymbol was a
symbol defined in C, regardless of if C was actually a submodule of B.</p>
<p><em>Example (import-reexport2.chpl)</em>.</p>
<p>Alternatively, if module B contains a public import of some public symbols
defined in module C, then those symbols will be visible to A as though they
were defined in module B, unless they are shadowed by symbols of the same
name in B.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">cSymbol</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">import</span> <span class="nx">C</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">import</span> <span class="nx">B</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">cSymbol</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, A’s mention of <code class="docutils literal notranslate"><span class="pre">B.cSymbol</span></code> accesses <code class="docutils literal notranslate"><span class="pre">cSymbol</span></code> from C.</p>
</div></blockquote>
<p>Again, if B’s import of C is <code class="docutils literal notranslate"><span class="pre">private</span></code> then A will not be able to see C’s
symbols due to that <code class="docutils literal notranslate"><span class="pre">import</span></code>.</p>
<p>This notion of re-exporting extends to the case in which a scope uses multiple
modules.</p>
<blockquote>
<div><p><em>Example (use-reexport3.chpl)</em>.</p>
<p>Say we have a module A that uses a module B, and module B contains a
public use of modules C1, C2, and C3.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">C1</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c1Symbol</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">C2</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c2Symbol</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">C3</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">c3Symbol</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">use</span> <span class="nx">C1</span><span class="p">,</span> <span class="nx">C2</span><span class="p">,</span> <span class="nx">C3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nx">B</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">C1</span><span class="p">.</span><span class="nx">c1Symbol</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">C2</span><span class="p">.</span><span class="nx">c2Symbol</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">C3</span><span class="p">.</span><span class="nx">c3Symbol</span><span class="p">);</span>

    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">c1Symbol</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">c2Symbol</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">c3Symbol</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case all three of those modules will be accessible by A as though
they were submodules of B.  This also means that symbols in C1, C2, and C3
will be accessible as though they were defined in B, assuming these symbols
were not shadowed by symbols with the same name in B and that these symbols
do not conflict with each other.</p>
</div></blockquote>
<p>This similarly applies to import statements that contain multiple
subexpressions.</p>
</div>
<div class="section" id="module-initialization">
<span id="id10"></span><h3>Module Initialization<a class="headerlink" href="#module-initialization" title="Permalink to this headline">¶</a></h3>
<p>Module initialization occurs at program start-up. All module-scope
statements within a module other than function and type declarations are
executed during module initialization. Modules that are not referred to,
including both top-level modules and sub-modules, will not be
initialized.</p>
<blockquote>
<div><p><em>Example (init.chpl)</em>.</p>
<p>In the code,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>       <span class="c1">// executed at module initialization</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hi!&quot;</span><span class="p">);</span>      <span class="c1">// executed at module initialization</span>
<span class="k">proc</span> <span class="nf">sayGoodbye</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Bye!&quot;</span><span class="p">);</span>   <span class="c1">// not executed at module initialization</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function foo() will be invoked and its result assigned to x. Then
“Hi!” will be printed.</p>
</div></blockquote>
<p>Module initialization order is discussed
in <a class="reference internal" href="#module-initialization-order"><span class="std std-ref">Module Initialization Order</span></a>.</p>
</div>
<div class="section" id="module-deinitialization">
<span id="id11"></span><h3>Module Deinitialization<a class="headerlink" href="#module-deinitialization" title="Permalink to this headline">¶</a></h3>
<p>Module deinitialization occurs at program tear-down. During module
deinitialization:</p>
<ul class="simple">
<li><p>If the module contains a deinitializer, which is a module-scope
function named <code class="docutils literal notranslate"><span class="pre">deinit()</span></code>, it is executed first.</p></li>
<li><p>If the module declares module-scope variables, they are deinitialized in
the reverse order of their initialization.</p></li>
</ul>
<p>Module deinitialization order is discussed
in <a class="reference internal" href="#module-deinitialization-order"><span class="std std-ref">Module Deinitialization Order</span></a>.</p>
</div>
</div>
<div class="section" id="program-execution">
<span id="id12"></span><h2>Program Execution<a class="headerlink" href="#program-execution" title="Permalink to this headline">¶</a></h2>
<p>Chapel programs start by initializing all modules and then executing the
main function (<a class="reference internal" href="#the-main-function"><span class="std std-ref">The main Function</span></a>).</p>
<div class="section" id="the-main-function">
<span id="id13"></span><h3>The <em>main</em> Function<a class="headerlink" href="#the-main-function" title="Permalink to this headline">¶</a></h3>
<p>The main function must be called <code class="docutils literal notranslate"><span class="pre">main</span></code> and must have zero arguments.
It can be specified with or without parentheses. In any Chapel program,
there is a single main function that defines the program’s entry point.
If a program defines multiple potential entry points, the implementation
may provide a compiler flag that disambiguates between main functions in
multiple modules.</p>
<blockquote>
<div><p><em>Implementation Notes</em>.</p>
<p>In the current Chapel compiler implementation, the <em>– –main-module</em> flag
can be used to specify the module from which the main function
definition will be used.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (main-module.chpl)</em>.</p>
<p>Because it defines two <code class="docutils literal notranslate"><span class="pre">main</span></code> functions, the following code will
yield an error unless a main module is specified on the command line.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;&#39;s main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M1</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">M1</span><span class="p">.</span><span class="nx">main</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;&#39;s main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If M1 is specified as the main module, the program will output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>M1&#39;s main
</pre></div>
</div>
<p>If M2 is specified as the main module the program will output:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>M1&#39;s main
M2&#39;s main
</pre></div>
</div>
<p>Notice that main is treated like just another function if it is not
in the main module and can be called as such.</p>
</div></blockquote>
<p>To aid in exploratory programming, a default main function is created if
the program does not contain a user-defined main function. The default
main function is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<blockquote>
<div><p><em>Example (no-main.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;hello, world&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>is a legal and complete Chapel program. The startup code for a Chapel
program first calls the module initialization code for the main
module and then calls <code class="docutils literal notranslate"><span class="pre">main()</span></code>. This program’s initialization
function is the file-scope writeln() statement. The module
declaration is taken to be the entire file, as described
in <a class="reference internal" href="#implicit-modules"><span class="std std-ref">Files and Implicit Modules</span></a>.</p>
</div></blockquote>
</div>
<div class="section" id="module-initialization-order">
<span id="id14"></span><h3>Module Initialization Order<a class="headerlink" href="#module-initialization-order" title="Permalink to this headline">¶</a></h3>
<p>Module initialization is performed using the following algorithm.</p>
<p>Starting from the module that defines the main function, the modules named in
its use and import statements are visited depth-first and initialized in
post-order. If a use or import statement names a module that has already been
visited, it is not visited a second time. Thus, infinite recursion is avoided.</p>
<p>Modules used or imported by a given module are visited in the order in which
they appear in the program text. For nested modules, the parent module and its
uses are initialized before the nested module and its uses or imports.</p>
<blockquote>
<div><p><em>Example (init-order.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">M1</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M2</span><span class="p">.</span><span class="nx">M3</span><span class="p">;</span>
  <span class="k">use</span> <span class="nx">M2</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M1&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In main&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M2</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">M4</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M2&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="k">module</span> <span class="nc">M3</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M3&#39;s initializer&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">M4</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In M4&#39;s initializer&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints the following</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>In M4&#39;s initializer
In M2&#39;s initializer
In M3&#39;s initializer
In M1&#39;s initializer
In main
</pre></div>
</div>
<p>M1, the main module, uses M2.M3 and then M2, thus M2.M3 must be
initialized. Because M2.M3 is a nested module, M4 (which is used by
M2) must be initialized first. M2 itself is initialized, followed by
M2.M3. Finally M1 is initialized, and the main function is run.</p>
</div></blockquote>
</div>
<div class="section" id="module-deinitialization-order">
<span id="id15"></span><h3>Module Deinitialization Order<a class="headerlink" href="#module-deinitialization-order" title="Permalink to this headline">¶</a></h3>
<p>Module deinitialization is performed in the reverse order of module
initialization, as specified in
<a class="reference internal" href="#module-initialization-order"><span class="std std-ref">Module Initialization Order</span></a>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="procedures.html" class="btn btn-neutral float-right" title="Procedures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="statements.html" class="btn btn-neutral float-left" title="Statements" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>