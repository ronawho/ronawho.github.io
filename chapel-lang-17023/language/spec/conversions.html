

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Conversions &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Expressions" href="expressions.html" />
    <link rel="prev" title="Variables" href="variables.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/conversions";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Conversions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-numeric-and-bool-conversions">Implicit Numeric and Bool Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-compile-time-constant-conversions">Implicit Compile-Time Constant Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-class-conversions">Implicit Class Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-type-argument-conversions">Implicit Type Argument Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-statement-bool-conversions">Implicit Statement Bool Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions-to-generic-types">Implicit Conversions To Generic Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-conversions">Explicit Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#explicit-numeric-conversions">Explicit Numeric Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-tuple-to-complex-conversion">Explicit Tuple to Complex Conversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-enumeration-conversions">Explicit Enumeration Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-class-conversions">Explicit Class Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-range-conversions">Explicit Range Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-domain-conversions">Explicit Domain Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-string-to-bytes-conversions">Explicit String to Bytes Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-type-to-string-conversions">Explicit Type to String Conversions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Conversions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/conversions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="conversions">
<span id="chapter-conversions"></span><h1>Conversions<a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h1>
<p>A <em>conversion</em> converts an expression of one type to another type,
possibly changing its value. In certain cases noted below the source
expression can be a type expression. We refer to these two types the
<em>source</em> and <em>target</em> types. Conversions can be either
implicit (<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) or
explicit (<a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>).</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Should Chapel allow for user-defined conversions?
If so, how would the user define them?</p>
</div></blockquote>
<div class="section" id="implicit-conversions">
<span id="id1"></span><h2>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>An <em>implicit conversion</em> is a conversion that occurs implicitly, that
is, not due to an explicit specification in the program. Implicit
conversions occur at the locations in the program listed below. Each
location determines the target type. The source and target types of an
implicit conversion must be allowed. They determine whether and how the
expression’s value changes.</p>
<p>An implicit conversion occurs at each of the following program
locations:</p>
<ul class="simple">
<li><p>In an assignment, the expression on the right-hand side of the
assignment is converted to the type of the variable or another lvalue
on the left-hand side of the assignment.</p></li>
<li><p>In a variable or field declaration, the initializing expression is
converted to the type of the variable or field. The initializing
expression is the r.h.s. of the <code class="docutils literal notranslate"><span class="pre">=</span></code> in the declaration, if present,
or in the field initialization statement in an initializer.</p></li>
<li><p>The actual argument of a function call or an operator is converted to
the type of the corresponding formal argument, if the formal’s intent
is <code class="docutils literal notranslate"><span class="pre">param</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, or an abstract intent
(<a class="reference internal" href="procedures.html#abstract-intents"><span class="std std-ref">Abstract Intents</span></a>) with the semantics of <code class="docutils literal notranslate"><span class="pre">in</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>.</p></li>
<li><p>The actual type argument of a function call or an operator is
converted to the corresponding formal argument of the <code class="docutils literal notranslate"><span class="pre">type</span></code> intent
or the <code class="docutils literal notranslate"><span class="pre">this</span></code> formal of a type method. See
<a class="reference internal" href="#implicit-type-arg-conversions"><span class="std std-ref">Implicit Type Argument Conversions</span></a>.</p></li>
<li><p>If the formal argument’s intent is <code class="docutils literal notranslate"><span class="pre">out</span></code>, the formal argument is
converted to the type of the corresponding actual argument upon
function return.</p></li>
<li><p>The return or yield expression within a function without a <code class="docutils literal notranslate"><span class="pre">ref</span></code>
return intent is converted to the return type of that function.</p></li>
<li><p>The condition of a conditional expression, conditional statement,
while-do or do-while loop statement is converted to the boolean type.
See <a class="reference internal" href="#implicit-statement-bool-conversions"><span class="std std-ref">Implicit Statement Bool Conversions</span></a>.</p></li>
</ul>
<p>Implicit conversions are not applied for actual arguments passed to
<code class="docutils literal notranslate"><span class="pre">ref</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> formal arguments.</p>
<p>Implicit conversions <em>are allowed</em> between the following source and
target types, as defined in the referenced subsections:</p>
<ul class="simple">
<li><p>numeric and boolean
types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>),</p></li>
<li><p>numeric types in the special case when the expression’s value is a
compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>),
and</p></li>
<li><p>class types (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>),</p></li>
<li><p>class and generic types in certain cases
(<a class="reference internal" href="#implicit-type-arg-conversions"><span class="std std-ref">Implicit Type Argument Conversions</span></a>)</p></li>
<li><p>from an integral or class type to <code class="docutils literal notranslate"><span class="pre">bool</span></code> in certain
cases (<a class="reference internal" href="#implicit-statement-bool-conversions"><span class="std std-ref">Implicit Statement Bool Conversions</span></a>).</p></li>
<li><p>generic target types
(<a class="reference internal" href="#implicit-generic-type-conversions"><span class="std std-ref">Implicit Conversions To Generic Types</span></a>)</p></li>
</ul>
<p>In addition, an implicit conversion from a type to the same type is
allowed for any type. Such conversion does not change the value of the
expression.</p>
<p>Implicit conversion is not transitive. That is, if an implicit
conversion is allowed from type <code class="docutils literal notranslate"><span class="pre">T1</span></code> to <code class="docutils literal notranslate"><span class="pre">T2</span></code> and from <code class="docutils literal notranslate"><span class="pre">T2</span></code> to
<code class="docutils literal notranslate"><span class="pre">T3</span></code>, that by itself does not allow an implicit conversion from <code class="docutils literal notranslate"><span class="pre">T1</span></code>
to <code class="docutils literal notranslate"><span class="pre">T3</span></code>.</p>
<div class="section" id="implicit-numeric-and-bool-conversions">
<span id="implicit-numbool-conversions"></span><h3>Implicit Numeric and Bool Conversions<a class="headerlink" href="#implicit-numeric-and-bool-conversions" title="Permalink to this headline">¶</a></h3>
<p>Implicit conversions among numeric types are allowed when all values
representable in the source type can also be represented in the target
type, retaining their full precision. In addition, implicit conversions
from types <code class="docutils literal notranslate"><span class="pre">int(64)</span></code> and <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> to types <code class="docutils literal notranslate"><span class="pre">real(64)</span></code> and
<code class="docutils literal notranslate"><span class="pre">complex(128)</span></code> are allowed, even though they may result in a loss of
precision.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We allow these additional conversions because they are an important
convenience for application programmers. Therefore we are willing to
lose precision in these cases. The largest real and complex types are
chosen to retain precision as often as as possible.</p>
</div></blockquote>
<p>Any boolean type can be implicitly converted to any other boolean type,
retaining the boolean value. Any boolean type can be implicitly
converted to any integral type by representing <code class="docutils literal notranslate"><span class="pre">false</span></code> as 0 and
<code class="docutils literal notranslate"><span class="pre">true</span></code> as 1, except (if applicable) a boolean cannot be converted to
<code class="docutils literal notranslate"><span class="pre">int(1)</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We disallow implicit conversion of a boolean to a real, imaginary, or
complex type because of the following. We expect that the cases where
such a conversion is needed will more likely be unintended by the
programmer. Marking those cases as errors will draw the programmer’s
attention. If such a conversion is actually desired, a cast
<a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a> can be inserted.</p>
</div></blockquote>
<p>Legal implicit conversions with numeric and boolean types may thus be
tabulated as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 15%" />
<col style="width: 11%" />
<col style="width: 17%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Source Type</p></td>
<td><p>bool(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>uint(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>int(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>real(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>imag(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>complex(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>bool(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s\)</span>; <span class="math notranslate nohighlight">\(2 \le t\)</span></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>uint(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s &lt; t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t)\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t/2)\)</span></p></td>
</tr>
<tr class="row-even"><td><p>uint(64)</p></td>
<td></td>
<td></td>
<td></td>
<td><p>real(64)</p></td>
<td></td>
<td><p>complex(128)</p></td>
</tr>
<tr class="row-odd"><td><p>int(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t)+1\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t/2)+1\)</span></p></td>
</tr>
<tr class="row-even"><td><p>int(64)</p></td>
<td></td>
<td></td>
<td></td>
<td><p>real(64)</p></td>
<td></td>
<td><p>complex(128)</p></td>
</tr>
<tr class="row-odd"><td><p>real(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-even"><td><p>imag(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>complex(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
</tr>
</tbody>
</table>
<p>Here, <span class="math notranslate nohighlight">\(mant(i)\)</span> is the number of bits in the (unsigned) mantissa
of the <span class="math notranslate nohighlight">\(i\)</span>-bit floating-point type. <a class="footnote-reference brackets" href="#id16" id="id2">1</a> Conversions for the
default integral and real types (<code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">complex</span></code>, etc.) are the
same as for their explicitly-sized counterparts.</p>
</div>
<div class="section" id="implicit-compile-time-constant-conversions">
<span id="id3"></span><h3>Implicit Compile-Time Constant Conversions<a class="headerlink" href="#implicit-compile-time-constant-conversions" title="Permalink to this headline">¶</a></h3>
<p>A parameter of numeric type can be implicitly converted to any other
numeric type if the value of the parameter can be represented exactly by
the target type. This rule does not allow conversions from <code class="docutils literal notranslate"><span class="pre">real</span></code> to
<code class="docutils literal notranslate"><span class="pre">imag</span></code>, or from <code class="docutils literal notranslate"><span class="pre">complex</span></code> to a non-complex type. It does allow
conversions from <code class="docutils literal notranslate"><span class="pre">real</span></code> or <code class="docutils literal notranslate"><span class="pre">imag</span></code> to <code class="docutils literal notranslate"><span class="pre">complex</span></code>.</p>
</div>
<div class="section" id="implicit-class-conversions">
<span id="id4"></span><h3>Implicit Class Conversions<a class="headerlink" href="#implicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of class type can be implicitly converted to the borrow
type; to a nilable type; or to a parent class type. The value <code class="docutils literal notranslate"><span class="pre">nil</span></code>
can be implicitly converted to any nilable class type.</p>
<p>First, class types can be converted to the corresponding <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>
type. For example, <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> can be implicitly converted to
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>, and <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C?</span></code> can be implicitly converted to
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>. This coercion is equivalent to calling the
<code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method. See <a class="reference internal" href="classes.html#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a>.
For example:</p>
<blockquote>
<div><p><em>Example (implicit-conversion-to-borrow.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// equivalent to f(c.borrow())</span>
</pre></div>
</div>
</div></blockquote>
<p>Second, an expression of non-nilable class type can be implicitly
converted to the nilable class type. Continuing the above example:</p>
<blockquote>
<div><p><em>Example (implicit-conversion-to-nilable.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span><span class="p">:</span><span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">?)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// equivalent to g(b:borrowed C?)</span>
</pre></div>
</div>
</div></blockquote>
<p>Third, an implicit conversion from class type <code class="docutils literal notranslate"><span class="pre">D</span></code> to another class
type <code class="docutils literal notranslate"><span class="pre">C</span></code> is allowed when <code class="docutils literal notranslate"><span class="pre">D</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>Any combination of these three conversions is allowed.</p>
</div>
<div class="section" id="implicit-type-argument-conversions">
<span id="implicit-type-arg-conversions"></span><h3>Implicit Type Argument Conversions<a class="headerlink" href="#implicit-type-argument-conversions" title="Permalink to this headline">¶</a></h3>
<p>An implicit type argument conversion applies only when a type actual is
passed to a formal with the <code class="docutils literal notranslate"><span class="pre">type</span></code> intent. This includes the <code class="docutils literal notranslate"><span class="pre">this</span></code>
formal of a type method. In this case, a subset of Implicit Class
Conversions (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>) applies, in
addition to Implicit Conversions To Generic Types
(<a class="reference internal" href="#implicit-generic-type-conversions"><span class="std std-ref">Implicit Conversions To Generic Types</span></a>).</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>The details are forthcoming.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-statement-bool-conversions">
<span id="id5"></span><h3>Implicit Statement Bool Conversions<a class="headerlink" href="#implicit-statement-bool-conversions" title="Permalink to this headline">¶</a></h3>
<p>In the condition of an if-statement, while-loop, and do-while-loop, the
following implicit conversions to <code class="docutils literal notranslate"><span class="pre">bool</span></code> are supported:</p>
<ul class="simple">
<li><p>An expression of integral type is taken to be false if it is zero and
is true otherwise.</p></li>
<li><p>An expression of a class type is taken to be false if it is nil and
is true otherwise.</p></li>
</ul>
</div>
<div class="section" id="implicit-conversions-to-generic-types">
<span id="implicit-generic-type-conversions"></span><h3>Implicit Conversions To Generic Types<a class="headerlink" href="#implicit-conversions-to-generic-types" title="Permalink to this headline">¶</a></h3>
<p>When the target type <code class="docutils literal notranslate"><span class="pre">T</span></code> is generic (<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>), an
implicit conversion is allowed when there is an instantiation of this
type such that an implicit conversion is allowed between the source type
and that instantiation by another rule in this section.</p>
<p>That instantiation is taken to be the instantiated type of the variable,
field, formal argument, or the return type whose declared type is the
generic type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>The conversions in this subsection apply when the source is either an
expression or a type expression.</p>
</div>
</div>
<div class="section" id="explicit-conversions">
<span id="id6"></span><h2>Explicit Conversions<a class="headerlink" href="#explicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>Explicit conversions require a cast in the code. Casts are defined
in <a class="reference internal" href="expressions.html#casts"><span class="std std-ref">Casts</span></a>. Explicit conversions are supported between more
types than implicit conversions, but not between all types.</p>
<p>The explicit conversions are a superset of the implicit conversions. In
addition to the following definitions, an explicit conversion from a
type to the same type is allowed for any type. Such conversion does not
change the value of the expression.</p>
<div class="section" id="explicit-numeric-conversions">
<span id="id7"></span><h3>Explicit Numeric Conversions<a class="headerlink" href="#explicit-numeric-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from any numeric type or boolean to
bytes or string, and vice-versa.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> of equal
or larger size, its value is zero-extended to fit the new
representation. When a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is converted to a smaller <code class="docutils literal notranslate"><span class="pre">bool</span></code>,
<code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its most significant bits are truncated (as
appropriate) to fit the new representation.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, or <code class="docutils literal notranslate"><span class="pre">real</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, the
result is <code class="docutils literal notranslate"><span class="pre">false</span></code> if the number was equal to 0 and <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
<p>When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value
is sign-extended to fit the new representation. When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is
converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is zero-extended.
When an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> of
the same size, its binary representation is unchanged. When an <code class="docutils literal notranslate"><span class="pre">int</span></code>
or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is
truncated to fit the new representation.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em>.</p>
<p>There are several kinds of integer conversion which can result in a
loss of precision. Currently, the conversions are performed as
specified, and no error is reported. In the future, we intend to
improve type checking, so the user can be informed of potential
precision loss at compile time, and actual precision loss at run
time. Such cases include: When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">uint</span></code>
and the original value is negative; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to
an <code class="docutils literal notranslate"><span class="pre">int</span></code> and the sign bit of the result is true; When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is
converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated
bits differs from the original sign bit; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted
to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated bits is
true;</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>For integer conversions, the default behavior of a program should be
to produce a run-time error if there is a loss of precision. Thus,
cast expressions not only give rise to a value conversion at run
time, but amount to an assertion that the required precision is
preserved. Explicit conversion procedures would be available in the
run-time library so that one can perform explicit conversions that
result in a loss of precision but do not generate a run-time
diagnostic.</p>
</div></blockquote>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to a larger <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the
represented value is preserved. When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to
a smaller <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the closest representation in the target type
is chosen. <a class="footnote-reference brackets" href="#id17" id="id8">2</a></p>
<p>When converting to a <code class="docutils literal notranslate"><span class="pre">real</span></code> type from an integer type, integer types
smaller than <code class="docutils literal notranslate"><span class="pre">int</span></code> are first converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>. Then, the closest
representation of the converted value in the target type is chosen. The
exact behavior of this conversion is implementation-defined.</p>
<p>When converting from <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to <code class="docutils literal notranslate"><span class="pre">complex(2k)</span></code>, the original
value is copied into the real part of the result, and the imaginary part
of the result is set to zero. When converting from a <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to a
<code class="docutils literal notranslate"><span class="pre">complex(j)</span></code> such that <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">2k</span></code>, the conversion is
performed as if the original value is first converted to
<code class="docutils literal notranslate"><span class="pre">real(j/2)</span></code> and then to <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>The rules for converting from <code class="docutils literal notranslate"><span class="pre">imag</span></code> to <code class="docutils literal notranslate"><span class="pre">complex</span></code> are the same as
for converting from real, except that the imaginary part of the result
is set using the input value, and the real part of the result is set to
zero.</p>
</div>
<div class="section" id="explicit-tuple-to-complex-conversion">
<span id="id9"></span><h3>Explicit Tuple to Complex Conversion<a class="headerlink" href="#explicit-tuple-to-complex-conversion" title="Permalink to this headline">¶</a></h3>
<p>A two-tuple of numerical values may be converted to a <code class="docutils literal notranslate"><span class="pre">complex</span></code> value.
If the destination type is <code class="docutils literal notranslate"><span class="pre">complex(128)</span></code>, each member of the
two-tuple must be convertible to <code class="docutils literal notranslate"><span class="pre">real(64)</span></code>. If the destination type
is <code class="docutils literal notranslate"><span class="pre">complex(64)</span></code>, each member of the two-tuple must be convertible to
<code class="docutils literal notranslate"><span class="pre">real(32)</span></code>. The first member of the tuple becomes the real part of the
resulting complex value; the second member of the tuple becomes the
imaginary part of the resulting complex value.</p>
</div>
<div class="section" id="explicit-enumeration-conversions">
<span id="id10"></span><h3>Explicit Enumeration Conversions<a class="headerlink" href="#explicit-enumeration-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from any enumerated type to <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
or <code class="docutils literal notranslate"><span class="pre">string</span></code> and vice-versa, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions. For
enumerated types that are either <cite>concrete</cite> or <cite>semi-concrete</cite> (see
<a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>), conversions are supported from the enum to
any numeric or boolean type, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions.
Explicit conversions are also supported from integer values back to
concrete or semi-concrete enumerated types.</p>
<p>When converting from an enum to a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code>, the value
becomes the name of the enumerator.</p>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code> to an enum, the result
is the constant whose name matches the source value. If no matching
value exists, an <code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
<p>For a semi-concrete enumerated type, if a numeric conversion is
attempted for a constant with no underlying integer value, it will
generate a compile-time error for a <code class="docutils literal notranslate"><span class="pre">param</span></code> conversion or throw an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> otherwise.</p>
<p>When converting from an enum to an integer type, the value is first
converted to the enum’s underlying integer type and then to the target
type, following the rules above for converting between integers.</p>
<p>When converting from an enum to a real, imaginary, or complex type,
the value is first converted to the enum’s underlying integer type and
then to the target type.</p>
<p>When converting from an enum to a boolean type, the value is first
converted to the enum’s underlying integer type. If the result is
zero, the value of the <code class="docutils literal notranslate"><span class="pre">bool</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>; otherwise, it is
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>When converting from an integer value to an enum, the value is
converted to the enum’s underlying integer type and then converted to
the matching symbol.  If no symbol has the given integer value, an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
</div>
<div class="section" id="explicit-class-conversions">
<span id="id11"></span><h3>Explicit Class Conversions<a class="headerlink" href="#explicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of static class type <code class="docutils literal notranslate"><span class="pre">C</span></code> can be explicitly converted to
a class type <code class="docutils literal notranslate"><span class="pre">D</span></code> provided that <code class="docutils literal notranslate"><span class="pre">C</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">D</span></code> or <code class="docutils literal notranslate"><span class="pre">D</span></code> is
derived from <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>When at run time the source expression refers to an instance of <code class="docutils literal notranslate"><span class="pre">D</span></code> or
it subclass, its value is not changed. Otherwise, the cast fails and the
result depends on whether or not the destination type is nilable. If the
cast fails and the destination type is not nilable, the cast expression
will throw a <code class="docutils literal notranslate"><span class="pre">classCastError</span></code>. If the cast fails and the destination
type is nilable, as with <code class="docutils literal notranslate"><span class="pre">D?</span></code>, then the result will be <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>An expression of class type can also be converted to a different
nilability with a cast. For conversions from a nilable class type to a
non-nilable class type, the cast will throw a <code class="docutils literal notranslate"><span class="pre">NilClassError</span></code> if the
value was actually <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>In some cases a new variant of a class type needs to be computed that
has different nilability or memory management strategy. Supposing that
<code class="docutils literal notranslate"><span class="pre">T</span></code> represents a class type, then these casts may compute a new type:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span></code> - new management is <code class="docutils literal notranslate"><span class="pre">owned</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span></code> - new management <code class="docutils literal notranslate"><span class="pre">shared</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span></code> - new management <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span></code> - new management <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class</span></code> - non-nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class?</span></code> - nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>
management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> management</p></li>
</ul>
<p>The conversions in this subsection apply when the source is either an
expression or a type expression.</p>
</div>
<div class="section" id="explicit-range-conversions">
<span id="id12"></span><h3>Explicit Range Conversions<a class="headerlink" href="#explicit-range-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of stridable range type can be explicitly converted to an
unstridable range type, changing the stride to 1 in the process.</p>
</div>
<div class="section" id="explicit-domain-conversions">
<span id="id13"></span><h3>Explicit Domain Conversions<a class="headerlink" href="#explicit-domain-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of stridable domain type can be explicitly converted to an
unstridable domain type, changing all strides to 1 in the process.</p>
</div>
<div class="section" id="explicit-string-to-bytes-conversions">
<span id="id14"></span><h3>Explicit String to Bytes Conversions<a class="headerlink" href="#explicit-string-to-bytes-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of <code class="docutils literal notranslate"><span class="pre">string</span></code> type can be explicitly converted to a
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>. However, the reverse is not possible as a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> can
contain arbitrary bytes. Instead, <code class="docutils literal notranslate"><span class="pre">bytes.decode()</span></code> method should be
used to produce a <code class="docutils literal notranslate"><span class="pre">string</span></code> from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
</div>
<div class="section" id="explicit-type-to-string-conversions">
<span id="id15"></span><h3>Explicit Type to String Conversions<a class="headerlink" href="#explicit-type-to-string-conversions" title="Permalink to this headline">¶</a></h3>
<p>A type expression can be explicitly converted to a <code class="docutils literal notranslate"><span class="pre">string</span></code>. The
resultant <code class="docutils literal notranslate"><span class="pre">string</span></code> is the name of the type.</p>
<blockquote>
<div><p><em>Example (explicit-type-to-string.chpl)</em>.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
</pre></div>
</div>
<p>This program will print out the string <code class="docutils literal notranslate"><span class="pre">&quot;real(64)&quot;</span></code>.</p>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>For the IEEE 754 format, <span class="math notranslate nohighlight">\(mant(32)=24\)</span> and <span class="math notranslate nohighlight">\(mant(64)=53\)</span>.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>When converting to a smaller real type, a loss of precision is
<em>expected</em>. Therefore, there is no reason to produce a run-time
diagnostic.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="expressions.html" class="btn btn-neutral float-right" title="Expressions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="variables.html" class="btn btn-neutral float-left" title="Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>