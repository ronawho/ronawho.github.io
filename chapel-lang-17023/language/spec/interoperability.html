

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Interoperability &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Syntax" href="syntax.html" />
    <link rel="prev" title="Memory Consistency Model" href="memory-consistency-model.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/interoperability";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Interoperability</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interoperability-overview">Interoperability Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#calling-external-functions">Calling External Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calling-chapel-functions">Calling Chapel Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shared-language-elements">Shared Language Elements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shared-types">Shared Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-data">Shared Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-procedures">Shared Procedures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calling-chapel-procedures-externally">Calling Chapel Procedures Externally</a></li>
<li class="toctree-l4"><a class="reference internal" href="#argument-passing">Argument Passing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Interoperability</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/interoperability.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="interoperability">
<span id="chapter-interoperability"></span><h1>Interoperability<a class="headerlink" href="#interoperability" title="Permalink to this headline">¶</a></h1>
<p>Chapel’s interoperability features support cooperation between Chapel
and other languages. They provide the ability to create software systems
that incorporate both Chapel and non-Chapel components. Thus, they
support the reuse of existing software components while leveraging the
unique features of the Chapel language.</p>
<p>Interoperability can be broken down in terms of the exchange of types,
variables and procedures, and whether these are imported or exported. An
overview of procedure importing and exporting is provided
in <a class="reference internal" href="#interop-overview"><span class="std std-ref">Interoperability Overview</span></a>. Details on sharing types, variables
and procedures are supplied in <a class="reference internal" href="#shared-language-elements"><span class="std std-ref">Shared Language Elements</span></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>At present, the backend language for Chapel is C, which makes it
relatively easy to call C libraries from Chapel and vice versa. To
support a variety of platforms without requiring recompilation, it
may be desirable to move to an intermediate-language model.</p>
<p>In that case, each supported platform must minimally support that
virtual machine. However, in addition to increased portability, a
virtual machine model may expose elements of the underlying machine’s
programming model (hardware task queues, automated garbage
collection, etc.) that are not easily rendered in C. In addition, the
virtual machine model can support run-time task migration.</p>
</div>
</div></blockquote>
<p>The remainder of this chapter documents Chapel support of
interoperability through the existing C-language backend.</p>
<div class="section" id="interoperability-overview">
<span id="interop-overview"></span><h2>Interoperability Overview<a class="headerlink" href="#interoperability-overview" title="Permalink to this headline">¶</a></h2>
<p>The following two subsections provide an overview of calling
externally-defined (C) routines in Chapel, and setting up Chapel
routines so they can be called from external (C) code.</p>
<div class="section" id="calling-external-functions">
<span id="id1"></span><h3>Calling External Functions<a class="headerlink" href="#calling-external-functions" title="Permalink to this headline">¶</a></h3>
<p>To use an external function in a Chapel program, it is necessary to
inform the Chapel compiler of that routine’s signature through an
external function declaration. This permits Chapel to bind calls to that
function signature during function resolution. The user must also supply
a definition for the referenced function by naming a C source file, an
object file or an object library on the <code class="docutils literal notranslate"><span class="pre">chpl</span></code> command line.</p>
<p>An external procedure declaration has the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>external-procedure-declaration-statement:
  &#39;extern&#39; external-name[OPT] &#39;proc&#39; function-name argument-list return-intent[OPT] return-type[OPT]
</pre></div>
</div>
<p>Chapel code will call the external function using the parameter types
supplied in the <code class="docutils literal notranslate"><span class="pre">extern</span></code> declaration. Therefore, in general, the type
of each argument in the supplied <code class="docutils literal notranslate"><span class="pre">argument-list</span></code> must be the Chapel
equivalent of the corresponding external type.</p>
<p>The return value of the function can be used by Chapel only if its type
is declared using the optional <code class="docutils literal notranslate"><span class="pre">return-type</span></code> specifier. If it is
omitted, Chapel assumes that no value is returned, or equivalently that
the function returns <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>It is possible to use the <code class="docutils literal notranslate"><span class="pre">external-name</span></code> syntax to create an
<code class="docutils literal notranslate"><span class="pre">extern</span></code> function that presents a different name to Chapel code than
the name of the function actually used when linking. The
<code class="docutils literal notranslate"><span class="pre">external-name</span></code> expression must evaluate to a <code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">string</span></code>.
For example, the code below declares a function callable in Chapel as
<code class="docutils literal notranslate"><span class="pre">c_atoi</span></code> but that will actually link with the C <code class="docutils literal notranslate"><span class="pre">atoi</span></code> function.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;atoi&quot;</span> <span class="k">proc</span> <span class="nf">c_atoi</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span><span class="nx">c_string</span><span class="p">):</span><span class="nx">c_int</span><span class="p">;</span>
</pre></div>
</div>
<p>At present, external iterators are not supported.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>The overloading of function names is also not supported directly in
the compiler. However, one can use the <code class="docutils literal notranslate"><span class="pre">external-name</span></code> syntax to
supply a name to be used by the linker. In this way, function
overloading can be implemented “by hand”. This syntax also supports
calling external C++ routines: The <code class="docutils literal notranslate"><span class="pre">external-name</span></code> to use is the
mangled function name generated by the external compilation
environment <a class="footnote-reference brackets" href="#id16" id="id2">4</a>.</p>
</div>
</div></blockquote>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>Dynamic dispatch (polymorphism) is also unsupported in this version.
But this is not ruled out in future versions. Since Chapel already
supports type-based procedure declaration and resolution, it is a
small step to translate a type-relative extern method declaration
into a virtual method table entry. The mangled name of the correct
external function must be supplied for each polymorphic type
available. However, most likely the generation of <code class="docutils literal notranslate"><span class="pre">.chpl</span></code> header
files from C and C++ libraries can be fully automated.</p>
</div>
</div></blockquote>
<p>There are three ways to supply to the Chapel compiler the definition of
an external function: as a C source file (<code class="docutils literal notranslate"><span class="pre">.c</span></code> or <code class="docutils literal notranslate"><span class="pre">.h</span></code>), as an
object file and as an object library. It is platform-dependent whether
static libraries (archives), dynamic libraries or both are supported.
See the <code class="docutils literal notranslate"><span class="pre">chpl</span></code> man page for more information on how these file types
are handled.</p>
</div>
<div class="section" id="calling-chapel-functions">
<span id="id3"></span><h3>Calling Chapel Functions<a class="headerlink" href="#calling-chapel-functions" title="Permalink to this headline">¶</a></h3>
<p>To call a Chapel procedure from external code, it is necessary to expose
the corresponding function symbol to the linker. This is done by adding
the <code class="docutils literal notranslate"><span class="pre">export</span></code> linkage specifier to the function definition. The
<code class="docutils literal notranslate"><span class="pre">export</span></code> specifier ensures that the corresponding procedure will be
resolved, even if it is not called within the Chapel program or library
being compiled.</p>
<p>An exported procedure declaration has the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>exported-procedure-declaration-statement:
  &#39;export&#39; external-name[OPT] &#39;proc&#39; function-name argument-list return-intent[OPT] return-type[OPT]
    function-body

external-name:
  expression
</pre></div>
</div>
<p>The rest of the procedure declaration is the same as for a non-exported
function. An exported procedure can be called from within Chapel as
well. Currently, iterators cannot be exported.</p>
<p>As with the <code class="docutils literal notranslate"><span class="pre">extern-name</span></code> for <code class="docutils literal notranslate"><span class="pre">extern</span></code> <code class="docutils literal notranslate"><span class="pre">proc</span></code>, if this syntax
element is provided, then it must be a <code class="docutils literal notranslate"><span class="pre">param</span></code> <code class="docutils literal notranslate"><span class="pre">string</span></code> and will be
used to determine the name of the function to use when linking. For
example, the code below declares a function callable in C as
<code class="docutils literal notranslate"><span class="pre">chapel_addone</span></code> but it is callable from Chapel code as <code class="docutils literal notranslate"><span class="pre">addone</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">export</span> <span class="s">&quot;chapel_addone&quot;</span> <span class="k">proc</span> <span class="nf">addone</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span><span class="nx">c_int</span><span class="p">):</span><span class="nx">c_int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arg</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future</em>.</p>
<p>Currently, exported functions cannot have generic, <code class="docutils literal notranslate"><span class="pre">param</span></code> or type
arguments. This is because such functions actually represent a family
of functions, specific versions of which are instantiated as need
during function resolution.</p>
<p>Instantiating all possible versions of a template function is not
practical in general. However, if explicit instantiation were
supported in Chapel, an explicit instantiation with the export
linkage specifier would clearly indicate that the matching template
function was to be instantiated with the given <code class="docutils literal notranslate"><span class="pre">param</span></code> values and
argument types.</p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="shared-language-elements">
<span id="id4"></span><h2>Shared Language Elements<a class="headerlink" href="#shared-language-elements" title="Permalink to this headline">¶</a></h2>
<p>This section provides details on how to share Chapel types, variables
and procedures with external code. It is written assuming that the
intermediate language is C.</p>
<div class="section" id="shared-types">
<h3>Shared Types<a class="headerlink" href="#shared-types" title="Permalink to this headline">¶</a></h3>
<p>This subsection discusses how specific types are shared between Chapel
and external code.</p>
<div class="section" id="referring-to-standard-c-types">
<span id="id5"></span><h4>Referring to Standard C Types<a class="headerlink" href="#referring-to-standard-c-types" title="Permalink to this headline">¶</a></h4>
<p>In Chapel code, all standard C types must be expressed in terms of their
Chapel equivalents. This is true, whether the entity is exported,
imported or private. Standard C types and their corresponding Chapel
types are shown in the following table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 12%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C Type</p></th>
<th class="head"><p>Chapel Type</p></th>
<th class="head"><p>C Type</p></th>
<th class="head"><p>Chapel Type</p></th>
<th class="head"><p>C Type</p></th>
<th class="head"><p>Chapel Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int8_t</p></td>
<td><p>int(8)</p></td>
<td><p>uint8_t</p></td>
<td><p>uint(8)</p></td>
<td><p>_real32</p></td>
<td><p>real(32)</p></td>
</tr>
<tr class="row-odd"><td><p>int16_t</p></td>
<td><p>int(16)</p></td>
<td><p>uint16_t</p></td>
<td><p>uint(16)</p></td>
<td><p>_real64</p></td>
<td><p>real(64)</p></td>
</tr>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>int(32)</p></td>
<td><p>uint32_t</p></td>
<td><p>uint(32)</p></td>
<td><p>_imag32</p></td>
<td><p>imag(32)</p></td>
</tr>
<tr class="row-odd"><td><p>int64_t</p></td>
<td><p>int(64)</p></td>
<td><p>uint64_t</p></td>
<td><p>uint(64)</p></td>
<td><p>_imag64</p></td>
<td><p>imag(64)</p></td>
</tr>
<tr class="row-even"><td><p>chpl_bool</p></td>
<td><p>bool</p></td>
<td><p>const char*</p></td>
<td><p>c_string</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>_complex64</p></td>
<td><p>complex(64)</p></td>
<td><p>_complex128</p></td>
<td><p>complex(128)</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Standard C types are built-in. Their Chapel equivalents do not have to
be declared using the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword.</p>
<p>In C, the “colloquial” integer type names <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>,
<code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, (<code class="docutils literal notranslate"><span class="pre">signed</span></code>) <code class="docutils literal notranslate"><span class="pre">short</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>), <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>
(<code class="docutils literal notranslate"><span class="pre">int</span></code>), (<code class="docutils literal notranslate"><span class="pre">signed</span></code>) <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, (<code class="docutils literal notranslate"><span class="pre">signed</span></code>) <code class="docutils literal notranslate"><span class="pre">long</span></code>
(<code class="docutils literal notranslate"><span class="pre">int</span></code>), <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>), (<code class="docutils literal notranslate"><span class="pre">signed</span></code>) <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>
(<code class="docutils literal notranslate"><span class="pre">int</span></code>) and <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) may have an
implementation-defined width. <a class="footnote-reference brackets" href="#id17" id="id6">5</a>. When referring to C types in a
Chapel program, the burden of making sure the type sizes agree is on the
user. A Chapel implementation must ensure that all of the C equivalents
in the above table are defined and have the correct representation with
respect to the corresponding Chapel type.</p>
</div>
<div class="section" id="referring-to-external-c-types">
<span id="id7"></span><h4>Referring to External C Types<a class="headerlink" href="#referring-to-external-c-types" title="Permalink to this headline">¶</a></h4>
<p>An externally-defined type can be referenced using a external type
declaration with the following syntax.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>external-type-alias-declaration-statement:
  &#39;extern&#39; &#39;type&#39; type-alias-declaration-list ;
</pre></div>
</div>
<p>In each <code class="docutils literal notranslate"><span class="pre">type-alias-declaration</span></code>, if the <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> part is
supplied, then Chapel uses the supplied type specifier internally.
Otherwise, it treats the named type as an opaque type. The definition
for an external type must be supplied by a C header file named on the
<code class="docutils literal notranslate"><span class="pre">chpl</span></code> command line.</p>
<p>Fixed-size C array types can be described within Chapel using its
homogeneous tuple type. For example, the C typedef</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">typedef</span> <span class="nx">double</span> <span class="nx">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>can be described in Chapel using</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kd">type</span> <span class="nx">vec</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="referring-to-external-c-structs">
<span id="id8"></span><h4>Referring to External C Structs<a class="headerlink" href="#referring-to-external-c-structs" title="Permalink to this headline">¶</a></h4>
<p>External C struct types can be referred to within Chapel by prefixing a
Chapel <code class="docutils literal notranslate"><span class="pre">record</span></code> definition with the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>external-record-declaration-statement:
  &#39;extern&#39; external-name[OPT] simple-record-declaration-statement
</pre></div>
</div>
<p>For example, consider an external C structure defined in <code class="docutils literal notranslate"><span class="pre">foo.h</span></code>
called <code class="docutils literal notranslate"><span class="pre">fltdbl</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">typedef</span> <span class="nx">struct</span> <span class="nx">_fltdbl</span> <span class="p">{</span>
  <span class="nx">float</span> <span class="nx">x</span><span class="p">;</span>
  <span class="nx">double</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span> <span class="nx">fltdbl</span><span class="p">;</span>
</pre></div>
</div>
<p>This type could be referred to within a Chapel program using</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">record</span> <span class="nc">fltdbl</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and defined by supplying <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> on the <code class="docutils literal notranslate"><span class="pre">chpl</span></code> command line.</p>
<p>Within the Chapel declaration, some or all of the fields from the C
structure may be omitted. The order of these fields need not match the
order they were specified within the C code. Any fields that are not
specified (or that cannot be specified because there is no equivalent
Chapel type) cannot be referenced within the Chapel code. Some effort is
made to preserve the values of the undefined fields when copying these
structs but Chapel cannot guarantee the contents or memory story of
fields of which it has no knowledge.</p>
<p>If the optional <code class="docutils literal notranslate"><span class="pre">external-name</span></code> is supplied, then it is used verbatim
as the exported struct symbol.</p>
<p>A C header file containing the struct’s definition in C must be
specified on the chpl compiler command line. Note that only typdef’d C
structures are supported by default. That is, in the C header file, the
<code class="docutils literal notranslate"><span class="pre">struct</span></code> must be supplied with a type name through a <code class="docutils literal notranslate"><span class="pre">typedef</span></code>
declaration. If this is not true, you can use the <code class="docutils literal notranslate"><span class="pre">external-name</span></code> part
to apply the <code class="docutils literal notranslate"><span class="pre">struct</span></code> specifier. As an example of this, given a C
declaration of:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">struct</span> <span class="nx">Vec3</span> <span class="p">{</span>
  <span class="nx">double</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>in Chapel you would refer to this <code class="docutils literal notranslate"><span class="pre">struct</span></code> via</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;struct Vec3&quot;</span> <span class="k">record</span> <span class="nc">Vec3</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="opaque-types">
<span id="id9"></span><h4>Opaque Types<a class="headerlink" href="#opaque-types" title="Permalink to this headline">¶</a></h4>
<p>It is possible refer to external pointer-based C types that cannot be
described in Chapel by using the “opaque” keyword. As the name implies,
these types are opaque as far as Chapel is concerned and cannot be used
for operations other than argument passing and assignment.</p>
<p>For example, Chapel could be used to call an external C function that
returns a pointer to a structure (that can’t or won’t be described as a
pointer to an external record) as follows:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">returnStructPtr</span><span class="p">():</span> <span class="kt">opaque</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">structPtr</span><span class="p">:</span> <span class="kt">opaque</span> <span class="o">=</span> <span class="nx">returnStructPtr</span><span class="p">();</span>
</pre></div>
</div>
<p>However, because the type of <code class="docutils literal notranslate"><span class="pre">structPtr</span></code> is opaque, it can be used
only in assignments and the arguments of functions expecting the same
underlying type.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">copyOfStructPtr</span> <span class="o">=</span> <span class="nx">structPtr</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">proc</span> <span class="nf">operateOnStructPtr</span><span class="p">(</span><span class="nx">ptr</span><span class="p">:</span> <span class="kt">opaque</span><span class="p">);</span>
<span class="nx">operateOnStructPtr</span><span class="p">(</span><span class="nx">structPtr</span><span class="p">);</span>
</pre></div>
</div>
<p>Like a <code class="docutils literal notranslate"><span class="pre">void*</span></code> in C, Chapel’s <code class="docutils literal notranslate"><span class="pre">opaque</span></code> carries no information
regarding the underlying type. It therefore subverts type safety, and
should be used with caution.</p>
</div>
</div>
<div class="section" id="shared-data">
<span id="id10"></span><h3>Shared Data<a class="headerlink" href="#shared-data" title="Permalink to this headline">¶</a></h3>
<p>This subsection discusses how to access external variables and
constants.</p>
<p>A C variable or constant can be referred to within Chapel by prefixing
its declaration with the extern keyword. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kd">var</span> <span class="nx">bar</span><span class="p">:</span> <span class="nx">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>would tell the Chapel compiler about an external C variable named
<code class="docutils literal notranslate"><span class="pre">bar</span></code> of type <code class="docutils literal notranslate"><span class="pre">foo</span></code>. Similarly,</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kd">const</span> <span class="nx">baz</span><span class="p">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
</pre></div>
</div>
<p>would refer to an external 32-bit integer constant named <code class="docutils literal notranslate"><span class="pre">baz</span></code> in the
C code. In practice, external consts can be used to provide Chapel
definitions for #defines and enum symbols in addition to traditional C
constants.</p>
<blockquote>
<div><p><em>Implementation Notes</em>.</p>
<p>Note that since params must be known to Chapel at compile-time and
the Chapel compiler does not necessarily parse C code, external
params are not supported.</p>
</div></blockquote>
</div>
<div class="section" id="shared-procedures">
<span id="id11"></span><h3>Shared Procedures<a class="headerlink" href="#shared-procedures" title="Permalink to this headline">¶</a></h3>
<p>This subsection provides additional detail and examples for calling
external procedures from Chapel and for exporting Chapel functions for
external use.</p>
<div class="section" id="calling-external-c-functions">
<span id="id12"></span><h4>Calling External C Functions<a class="headerlink" href="#calling-external-c-functions" title="Permalink to this headline">¶</a></h4>
<p>To call an external C function, a prototype of the routine must appear
in the Chapel code. This is accomplished by providing the Chapel
signature of the function preceded by the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword. For
example, for a C function foo() that takes no arguments and returns
nothing, the prototype would be:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">();</span>
</pre></div>
</div>
<p>To refer to the return value of a C function, its type must be supplied
through a <code class="docutils literal notranslate"><span class="pre">return-type</span></code> clause in the prototype. <a class="footnote-reference brackets" href="#id18" id="id13">6</a></p>
<p>If the above function returns a C <code class="docutils literal notranslate"><span class="pre">double</span></code>, it would be declared as:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">():</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>Similarly, for external functions that expect arguments, the types of
those arguments types may be declared in Chapel using explicit argument
type specifiers.</p>
<p>The types of function arguments may be omitted from the external
procedure declaration, in which case they are inferred based on the
Chapel callsite. For example, the Chapel code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span><span class="p">):</span> <span class="kt">real</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</pre></div>
</div>
<p>would imply that the external function foo takes two 64-bit integer
values and returns a 64-bit real. External function declarations with
omitted type arguments can also be used call external C macros.</p>
<p>External function arguments can be declared using the
<code class="docutils literal notranslate"><span class="pre">default-expression</span></code> syntax. In this case, the default argument will
be supplied by the Chapel compiler if the corresponding actual argument
is omitted at the callsite. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">):</span> <span class="kt">real</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Would cause external function foo() to be invoked with the arguments 0
and 1.2.</p>
<p>C varargs functions can be declared using Chapel’s
<code class="docutils literal notranslate"><span class="pre">variable-argument-expression</span></code> syntax (<code class="docutils literal notranslate"><span class="pre">...</span></code>). For example, the C
<code class="docutils literal notranslate"><span class="pre">printf</span></code> function can be declared in Chapel as</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">proc</span> <span class="nf">printf</span><span class="p">(</span><span class="nx">fmt</span><span class="p">:</span> <span class="nx">c_string</span><span class="p">,</span> <span class="nx">vals</span><span class="o">..</span><span class="p">.?</span><span class="nx">numvals</span><span class="p">):</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>External C functions or macros that accept type arguments can also be
prototyped in Chapel by declaring the argument as a type. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="nx">foo</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">);</span>
</pre></div>
</div>
<p>Calling such a routine with a Chapel type will cause the type identifier
(e.g., ’int’) to be passed to the routine. <a class="footnote-reference brackets" href="#id19" id="id14">7</a></p>
</div>
</div>
<div class="section" id="calling-chapel-procedures-externally">
<span id="id15"></span><h3>Calling Chapel Procedures Externally<a class="headerlink" href="#calling-chapel-procedures-externally" title="Permalink to this headline">¶</a></h3>
<p>To call a Chapel procedure from external code, the procedure name must
be exported using the <code class="docutils literal notranslate"><span class="pre">export</span></code> keyword. An exported procedure taking
no arguments and returning a 64-bit integer can be declared as:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">export</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">():</span> <span class="kt">int</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p>If the optional <code class="docutils literal notranslate"><span class="pre">external-name</span></code> is supplied, that is the name used in
linking with external code. For example, if we declare</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">export</span> <span class="s">&quot;myModule_foo&quot;</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">():</span> <span class="kt">int</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p>then the name <code class="docutils literal notranslate"><span class="pre">foo</span></code> is used to refer to the procedure within chapel
code, whereas a call to the same function from C code would appear as
<code class="docutils literal notranslate"><span class="pre">myModule_foo();</span></code>. If the external name is omitted, then its internal
name is also used externally.</p>
<p>When a procedure is exported, all of the types and functions on which it
depends are also exported. Iterators cannot be explicitly exported.</p>
</div>
<div class="section" id="argument-passing">
<span id="interop-argument-passing"></span><h3>Argument Passing<a class="headerlink" href="#argument-passing" title="Permalink to this headline">¶</a></h3>
<p>The manner in which arguments are passed to an external function can be
controlled using argument intents. The following table shows the
correspondence between Chapel intents and C argument type declarations.
These correspondences pertain to both imported and exported function
signatures.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Chapel</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T</p></td>
<td><p>const T</p></td>
</tr>
<tr class="row-odd"><td><p>in T</p></td>
<td><p>T</p></td>
</tr>
<tr class="row-even"><td><p>ref T</p></td>
<td><p>T*</p></td>
</tr>
<tr class="row-odd"><td><p>param</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>type</p></td>
<td><p>char*</p></td>
</tr>
</tbody>
</table>
<p>Currently, <code class="docutils literal notranslate"><span class="pre">param</span></code> arguments are not allowed in an extern function
declaration, and <code class="docutils literal notranslate"><span class="pre">type</span></code> args are passed as a string containing the
name of the actual type being passed. Note that the level of indirection
is changed when passing arguments to a C function using
the <code class="docutils literal notranslate"><span class="pre">ref</span></code> intent. The C code implementing that function must
dereference the argument to extract its value.</p>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id2">4</a></span></dt>
<dd><p>In UNIX-like programming environments, <code class="docutils literal notranslate"><span class="pre">nm</span></code> and <code class="docutils literal notranslate"><span class="pre">grep</span></code> can be
used to find the mangled name of a given function within an object
file or object library.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>However, most implementations have settled on using 8, 16, 32, and 64
bits (respectively) to represent <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code> and
<code class="docutils literal notranslate"><span class="pre">long</span></code>, and <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> types</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id13">6</a></span></dt>
<dd><p>The return type cannot be inferred, since an <code class="docutils literal notranslate"><span class="pre">extern</span></code> procedure
declaration has no body.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id14">7</a></span></dt>
<dd><p>In practice, this will typically only be useful if the external
function is a macro or built-in that can handle type identifiers.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="syntax.html" class="btn btn-neutral float-right" title="Syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="memory-consistency-model.html" class="btn btn-neutral float-left" title="Memory Consistency Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>