

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Records" href="records.html" />
    <link rel="prev" title="Tuples" href="tuples.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/classes";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#class-declarations">Class Declarations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-lifetime-and-borrows">Class Lifetime and Borrows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-types">Class Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nilable-class-types">Nilable Class Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-values">Class Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-nil-value">The <em>nil</em> Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-fields">Class Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-methods">Class Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nested-classes">Nested Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-object-class">The <em>object</em> Class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-base-class-fields">Accessing Base Class Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shadowing-base-class-fields">Shadowing Base Class Fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overriding-base-class-methods">Overriding Base Class Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#class-new">Class New</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-initializers">Class Initializers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-initializers">User-Defined Initializers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-compiler-generated-initializer">The Compiler-Generated Initializer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-postinit-method">The postinit Method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-inherited-classes">Initializing Inherited Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#field-accesses">Field Accesses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#variable-getter-methods">Variable Getter Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#class-method-calls">Class Method Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-operations">Common Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-assignment">Class Assignment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#deleting-unmanaged-class-instances">Deleting Unmanaged Class Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-deinitializer">Class Deinitializer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<span id="chapter-classes"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<p>Classes are data structures with associated state and functions. A
variable of class type either refers to a class instance, or contains a
special <code class="docutils literal notranslate"><span class="pre">nil</span></code> value. Note that <em>object</em> is another name for a class
instance. Storage for a class instance is not necessarily tied to the
scope of the variable(s) referring to that class instance. It is
possible for multiple variables to refer to the same class instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">new-expression</span></code> can be used to create an instance of a class
(<a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>). Depending on the memory management strategy, a
class instance is either deleted automatically or can be deleted using
the <code class="docutils literal notranslate"><span class="pre">delete-statement</span></code> (<a class="reference internal" href="#class-delete"><span class="std std-ref">Deleting Unmanaged Class Instances</span></a>).</p>
<p>A class declaration (<a class="reference internal" href="#class-declarations"><span class="std std-ref">Class Declarations</span></a>) generates a class
type (<a class="reference internal" href="#class-types"><span class="std std-ref">Class Types</span></a>). A variable of a class type can refer
to an instance of that class or any of its derived classes.</p>
<p>A class is generic if it has generic fields. A class can also be generic
if it inherits from a generic class. Generic classes and fields are
discussed in <a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<div class="section" id="class-declarations">
<span id="id1"></span><h2>Class Declarations<a class="headerlink" href="#class-declarations" title="Permalink to this headline">¶</a></h2>
<p>A class is defined with the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>class-declaration-statement:
  &#39;class&#39; identifier class-inherit[OPT] { class-statement-list[OPT] }

class-inherit:
  : basic-class-type

class-statement-list:
  class-statement
  class-statement class-statement-list

class-statement:
  variable-declaration-statement
  method-declaration-statement
  type-declaration-statement
  empty-statement
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">class-declaration-statement</span></code> defines a new class type symbol
specified by the identifier. It inherits from the class specified in the
<code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause, when provided (<a class="reference internal" href="#inheritance"><span class="std std-ref">Inheritance</span></a>).</p>
<p>The body of a class declaration consists of a sequence of statements
where each of the statements either defines a variable (called a field),
a procedure or iterator (called a method), or a type alias. In addition,
empty statements are allowed in class declarations, and they have no
effect.</p>
<p>If a class declaration contains a type alias or a parameter field, or it
contains a variable or constant without a specified type and without an
initialization expression, then it declares a generic class type.
Generic classes are described in <a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em>.</p>
<p>Privacy controls for classes and records are currently not specified,
as discussion is needed regarding its impact on inheritance, for
instance.</p>
</div>
</div></blockquote>
<div class="section" id="class-lifetime-and-borrows">
<span id="id2"></span><h3>Class Lifetime and Borrows<a class="headerlink" href="#class-lifetime-and-borrows" title="Permalink to this headline">¶</a></h3>
<p>The lifetime of a class instance is the time between its creation and
its deletion. It is legal to access the class fields or methods only
during its lifetime.</p>
<p>Each allocation of a class instance specifies a <em>memory management
strategy</em>. Four memory management strategies are available: <code class="docutils literal notranslate"><span class="pre">owned</span></code>,
<code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">owned</span></code> and <code class="docutils literal notranslate"><span class="pre">shared</span></code> class instances always have their lifetime
managed by the compiler. In other words, the compiler automatically calls
<code class="docutils literal notranslate"><span class="pre">delete</span></code> on these instances to reclaim their memory. For these
instances, <code class="docutils literal notranslate"><span class="pre">=</span></code> and copy initialization can result in the transfer or
sharing of ownership. See the module documentation for <a class="reference internal" href="../../builtins/OwnedObject.html#module-OwnedObject" title="OwnedObject: `owned` (along with :record:`~SharedObject.shared`) manage the"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">owned</span></code></a> and <a class="reference internal" href="../../builtins/SharedObject.html#module-SharedObject" title="SharedObject: :record:`shared` (along with :record:`~OwnedObject.owned`) manage the"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">shared</span></code></a>.  When <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> is
used as a memory management strategy in a <code class="docutils literal notranslate"><span class="pre">new-expression</span></code>, it also
creates an instance that has its lifetime managed by the compiler
(<a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>).</p>
<p>Class instances that are <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> have their lifetime managed
explicitly and <code class="docutils literal notranslate"><span class="pre">delete</span></code> must be used to reclaim their memory.</p>
<p>No matter the memory management strategy used, class types support
<em>borrowing</em>. A <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> class instance refers to the same class
instance as another variable but has no impact on the lifetime of that
instance. The process of getting such a reference to an instance is
called <em>borrowing</em>.</p>
<p>There are several ways to borrow an instance. To borrow explicitly the
instance managed by another variable, call the <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method.
Additionally, coercions are available that are equivalent to calling the
<code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method. For example:</p>
<blockquote>
<div><p><em>Example (borrowing.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>   <span class="c1">// &#39;own&#39; manages the memory of the instance</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">own</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span>      <span class="c1">// &#39;b&#39; refers to the same instance but has no</span>
                             <span class="c1">// impact on the lifetime.</span>

  <span class="kd">var</span> <span class="nx">bc</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">own</span><span class="p">;</span>  <span class="c1">// &#39;bc&#39; stores the result of own.borrow()</span>
                             <span class="c1">// due to coercion from owned C to</span>
                             <span class="c1">// borrowed C</span>

                             <span class="c1">// Note that these coercions can also apply</span>
                             <span class="c1">// in the context of procedure calls.</span>

                             <span class="c1">// the instance referred to by &#39;own&#39; is</span>
                             <span class="c1">// deleted here, at the end of the containing</span>
                             <span class="c1">// block.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method is available on all class types (including
<code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> and <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>) in order to support generic programming.
For nilable class types, it returns the borrowed nilable class type.</p>
<p>Errors due to accessing an instance after the end of its lifetime are
particularly difficult to debug. For this reason, the compiler includes
a component called the lifetime checker. It identifies some cases where
a borrowing variable can be accessed beyond the lifetime of an instance
it refers to.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p>The details of lifetime checking are not yet finalized or specified.
Additional syntax to specify the lifetimes of function returns will
probably be needed.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="class-types">
<span id="id3"></span><h3>Class Types<a class="headerlink" href="#class-types" title="Permalink to this headline">¶</a></h3>
<p>A class type is formed by the combination of a basic class type and a
memory management strategy.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>class-type:
  basic-class-type
  &#39;owned&#39; basic-class-type
  &#39;shared&#39; basic-class-type
  &#39;borrowed&#39; basic-class-type
  &#39;unmanaged&#39; basic-class-type
</pre></div>
</div>
<p>A basic class type is given simply by the class name for non-generic
classes. Generic classes must be instantiated to serve as a
fully-specified type, for example to declare a variable. This is done
with type constructors, which are defined in Section <a class="reference internal" href="generics.html#type-constructors"><span class="std std-ref">The Type Constructor</span></a>.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>basic-class-type:
  identifier
  identifier ( named-expression-list )
</pre></div>
</div>
<p>A basic class type, including a generic class type that is not fully
specified, may appear in the inheritance lists of other class
declarations.</p>
<p>If no memory management strategy is indicated, the class will be
considered to have generic management.</p>
<p>Variables of class type cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> unless the class type is
nilable (<a class="reference internal" href="#nilable-classes"><span class="std std-ref">Nilable Class Types</span></a>).</p>
<p>The memory management strategies have the following meaning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span></code> the instance will be deleted automatically when the
<code class="docutils literal notranslate"><span class="pre">owned</span></code> variable goes out of scope, but only one <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable
can refer to the instance at a time. See the module documentation for
<a class="reference internal" href="../../builtins/OwnedObject.html#module-OwnedObject" title="OwnedObject: `owned` (along with :record:`~SharedObject.shared`) manage the"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">owned</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span></code> will be deleted when all of the <code class="docutils literal notranslate"><span class="pre">shared</span></code> variables
referring to the instance go out of scope. See
the module documentation for <a class="reference internal" href="../../builtins/SharedObject.html#module-SharedObject" title="SharedObject: :record:`shared` (along with :record:`~OwnedObject.owned`) manage the"><code class="xref chpl chpl-mod docutils literal notranslate"><span class="pre">shared</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed</span></code> refers to a class instance that has a lifetime managed
by another variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> the instance must have <code class="docutils literal notranslate"><span class="pre">delete</span></code> called on it
explicitly to reclaim its memory.</p></li>
</ul>
<p>It is an error to apply more than one memory management strategy to a
class type. However, in some cases, generic code needs to compute a
variant of the class type using a different memory management strategy.
Casts from the class type to a different memory management strategy are
available for this purpose
(see <a class="reference internal" href="conversions.html#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>).</p>
<blockquote>
<div><p><em>Example (duplicate-management.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="k">borrowed</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (changing-management.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">borrowedC</span> <span class="o">=</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">ownedC</span> <span class="o">=</span> <span class="p">(</span><span class="nx">borrowedC</span><span class="p">:</span><span class="k">owned</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="nilable-class-types">
<span id="nilable-classes"></span><h3>Nilable Class Types<a class="headerlink" href="#nilable-class-types" title="Permalink to this headline">¶</a></h3>
<p>Variables of a class type cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> and do not have a default
value unless the class type is nilable. To create a nilable class type,
use the postfix <code class="docutils literal notranslate"><span class="pre">?</span></code> operator. For example, if <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class, then
<code class="docutils literal notranslate"><span class="pre">C?</span></code> indicates the nilable class type with generic memory management strategy.
The <code class="docutils literal notranslate"><span class="pre">?</span></code> operator can be combined with memory management specifiers as
well. For example, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code> indicates a nilable class using the
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> memory management strategy. Note that the <code class="docutils literal notranslate"><span class="pre">?</span></code> operator
applies only to types.</p>
<p>A nilable type can also be created with a cast to <code class="docutils literal notranslate"><span class="pre">class?</span></code>. For example,
if <code class="docutils literal notranslate"><span class="pre">T</span></code> is a class type, then <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">class?</span></code> indicates its nilable counterpart,
or <code class="docutils literal notranslate"><span class="pre">T</span></code> itself if it is already nilable. <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">borrowed</span> <span class="pre">class?</span></code> produces
the nilable <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>To create a non-nilable class type from a nilable class type, apply a
cast to <code class="docutils literal notranslate"><span class="pre">class</span></code> or to a more specific type. For example, if <code class="docutils literal notranslate"><span class="pre">T</span></code> is
a class type, then <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">class</span></code> indicates its non-nilable counterpart,
or <code class="docutils literal notranslate"><span class="pre">T</span></code> itself if it is already non-nilable. <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">borrowed</span> <span class="pre">class</span></code>
produces the non-nilable <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>The postfix <code class="docutils literal notranslate"><span class="pre">!</span></code> operator converts a class value to a non-nilable type.
If the value is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it returns a copy of that value if it is
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> or <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, or a borrow from it if it is <code class="docutils literal notranslate"><span class="pre">owned</span></code>
or <code class="docutils literal notranslate"><span class="pre">shared</span></code>. If the value is in fact <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it halts.</p>
<p>An alternative to <code class="docutils literal notranslate"><span class="pre">!</span></code> is to use a cast to a non-nilable type. Such a
cast will throw <code class="docutils literal notranslate"><span class="pre">NilClassError</span></code> if the value was in fact <code class="docutils literal notranslate"><span class="pre">nil</span></code>.
See <a class="reference internal" href="conversions.html#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>.</p>
<p>Non-nilable class types are implicitly convertible to nilable class
types. See <a class="reference internal" href="conversions.html#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>.</p>
<p>Class methods generally expect a receiver of type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>
(see <a class="reference internal" href="#class-methods"><span class="std std-ref">Class Methods</span></a>). Since such a class method call might
involve dynamic dispatch, it is a program error to call a class method
on a class receiver storing <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The compiler will not
resolve calls to class methods if the receiver has nilable type. If the
programmer knows that the receiver cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code> at that moment,
they can use <code class="docutils literal notranslate"><span class="pre">!</span></code> to assert that the receiver is not <code class="docutils literal notranslate"><span class="pre">nil</span></code> and to
convert it to the non-nilable borrowed type. For example:</p>
<blockquote>
<div><p><em>Example (nilable-classes-bang.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>

<span class="c1">// Invoke c.method() only when c is non-nil.</span>
<span class="k">if</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">c</span><span class="o">!</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span> <span class="c1">// c! converts from &#39;owned C?&#39; to &#39;borrowed C&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">borrow()</span></code> method is an exception. Suppose it is invoked on an
expression of a class type <code class="docutils literal notranslate"><span class="pre">C</span></code>. It will return <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> for any
non-nilable <code class="docutils literal notranslate"><span class="pre">C</span></code> type (e.g. <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>). It will return
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code> for any nilable <code class="docutils literal notranslate"><span class="pre">C</span></code> type (e.g. <code class="docutils literal notranslate"><span class="pre">C?</span></code>).</p>
</div>
<div class="section" id="class-values">
<span id="id4"></span><h3>Class Values<a class="headerlink" href="#class-values" title="Permalink to this headline">¶</a></h3>
<p>A class value is either a reference to an instance of a class or <code class="docutils literal notranslate"><span class="pre">nil</span></code>
(<a class="reference internal" href="#class-nil-value"><span class="std std-ref">The nil Value</span></a>). Class instances can be created using a
<code class="docutils literal notranslate"><span class="pre">new</span></code> expression (<a class="reference internal" href="#class-new"><span class="std std-ref">Class New</span></a>).</p>
<p>For a given class type, a legal value of that type is a reference to an
instance of either that class or a class inheriting, directly or
indirectly, from that class. <code class="docutils literal notranslate"><span class="pre">nil</span></code> is a legal value of any non-nilable
class type.</p>
<p>The default value of a concrete nilable class type is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Generic
class types and non-nilable class types do not have a default value.
For this reason, rectangular arrays of non-nilable classes cannot be
resized, since the new array values don’t have a logical default
value.  For similar reasons, associative and sparse arrays of
non-nilable classes are not currently supported.</p>
<blockquote>
<div><p><em>Example (declaration.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span>    <span class="c1">// c has class type owned C?, meaning</span>
                     <span class="c1">// the instance can be nil and is deleted automatically</span>
                     <span class="c1">// when it is not.</span>
<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>         <span class="c1">// Now c refers to an initialized instance of type C.</span>
<span class="kd">var</span> <span class="nx">c2</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span> <span class="c1">// The type of c2 is borrowed C?.</span>
                     <span class="c1">// c2 refers to the same object as c.</span>
<span class="k">class</span> <span class="nc">D</span> <span class="p">:</span> <span class="nx">C</span> <span class="p">{}</span>    <span class="c1">// Class D is derived from C.</span>
<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">D</span><span class="p">();</span>      <span class="c1">// Now c refers to an object of type D.</span>
                  <span class="c1">// Since c is owned, the previous is deleted.</span>
<span class="c1">// the C and D instances allocated above will be reclaimed</span>
<span class="c1">// at the end of this block.</span>
</pre></div>
</div>
<p>When the variable <code class="docutils literal notranslate"><span class="pre">c</span></code> is declared, it initially has the value of
<code class="docutils literal notranslate"><span class="pre">nil</span></code>. The next statement assigned to it an instance of the class
<code class="docutils literal notranslate"><span class="pre">C</span></code>. The declaration of variable <code class="docutils literal notranslate"><span class="pre">c2</span></code> shows that these steps can
be combined. The type of <code class="docutils literal notranslate"><span class="pre">c2</span></code> is also <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>, determined
implicitly from the the initialization expression. Finally, an object
of type <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">D</span></code> is created and assigned to <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="the-nil-value">
<span id="class-nil-value"></span><h3>The <em>nil</em> Value<a class="headerlink" href="#the-nil-value" title="Permalink to this headline">¶</a></h3>
<p>Chapel provides <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate the absence of a reference to any
object. Invoking a class method or accessing a field of the <code class="docutils literal notranslate"><span class="pre">nil</span></code>
value results in a run-time or compile-time error.</p>
<p><code class="docutils literal notranslate"><span class="pre">nil</span></code> can be assigned to a variable of any nilable class type. There
is a restriction for using <code class="docutils literal notranslate"><span class="pre">nil</span></code> as the default value or the actual
argument of a function formal, or as the initializer for a variable or a
field. Such a use is disallowed when the declared type of the
formal/variable/field is non-nilable or generic, including generic
memory management.</p>
</div>
<div class="section" id="class-fields">
<span id="id5"></span><h3>Class Fields<a class="headerlink" href="#class-fields" title="Permalink to this headline">¶</a></h3>
<p>A variable declaration within a class declaration defines a <em>field</em>
within that class. Each class instance consists of one variable per each
<code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field in the class.</p>
<blockquote>
<div><p><em>Example (defineActor.chpl)</em>.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Actor</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">age</span><span class="p">:</span> <span class="kt">uint</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines a new class type called <code class="docutils literal notranslate"><span class="pre">Actor</span></code> that has two fields: the
string field <code class="docutils literal notranslate"><span class="pre">name</span></code> and the unsigned integer field <code class="docutils literal notranslate"><span class="pre">age</span></code>.</p>
</div></blockquote>
<p>Field access is described in <a class="reference internal" href="#class-field-accesses"><span class="std std-ref">Field Accesses</span></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em></p>
<p><code class="docutils literal notranslate"><span class="pre">ref</span></code> fields, which are fields corresponding to variable
declarations with <code class="docutils literal notranslate"><span class="pre">ref</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> keywords, are an area of
future work.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="class-methods">
<span id="id6"></span><h3>Class Methods<a class="headerlink" href="#class-methods" title="Permalink to this headline">¶</a></h3>
<p>Methods on classes are referred to as <em>class methods</em>.
See <a class="reference internal" href="methods.html#chapter-methods"><span class="std std-ref">Methods</span></a> for more information about methods.</p>
<p>Within a class method, the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> is generally the non-nilable
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code> variant of the class type. It is different for type methods
(see below) and it might be a different type if the class method is
declared as a secondary method with a type expression.</p>
<p>For example:</p>
<blockquote>
<div><p><em>Example (class-method-this-type.chpl)</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class C {
  proc primaryMethod() {
    assert(this.type == borrowed C);
  }
}
proc C.secondaryMethod() {
  assert(this.type == borrowed C);
}
proc (owned C?).secondaryMethodWithTypeExpression() {
  assert(this.type == owned C?);
}

var x:owned C? = new owned C();
x!.primaryMethod();   // within the method, this: borrowed C
x!.secondaryMethod(); // within the method, this: borrowed C
x.secondaryMethodWithTypeExpression(); // within the method, this: owned C?
</pre></div>
</div>
</div></blockquote>
<p>For type methods on a class, <code class="docutils literal notranslate"><span class="pre">this</span></code> will accept any management or
nilability variant of the class type and it will refer to that type in
the body of the method. For example:</p>
<blockquote>
<div><p><em>Example (class-type-method-this.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">type</span> <span class="nx">typeMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// print out the type of &#39;this&#39;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">(</span><span class="nx">C</span><span class="p">).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;C&#39;</span>
<span class="p">(</span><span class="k">owned</span> <span class="nx">C</span><span class="p">).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;owned C&#39;</span>
<span class="p">(</span><span class="k">borrowed</span> <span class="nx">C</span><span class="p">?).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;borrowed C?&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p>When a type method is defined only in a parent class, the type will be
the corresponding variant of the parent class. For example:</p>
<blockquote>
<div><p><em>Example (class-type-method-inherit.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">type</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">typeMethod</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span> <span class="c1">// print out the type &#39;this&#39;</span>
<span class="p">}</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;Parent&#39;</span>
<span class="p">(</span><span class="k">borrowed</span> <span class="nx">Child</span><span class="p">?).</span><span class="nx">typeMethod</span><span class="p">();</span> <span class="c1">// prints &#39;borrowed Parent?&#39;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="nested-classes">
<span id="id7"></span><h3>Nested Classes<a class="headerlink" href="#nested-classes" title="Permalink to this headline">¶</a></h3>
<p>A class defined within another class or record is a nested class. A
nested class can be referenced only within its immediately enclosing
class or record.</p>
</div>
</div>
<div class="section" id="inheritance">
<span id="id8"></span><h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h2>
<p>A class inherits, or <em>derives</em>, from the class specified in the class
declaration’s <code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause when such clause is present.
Otherwise the class inherits from the predefined <code class="docutils literal notranslate"><span class="pre">object</span></code> class
(<a class="reference internal" href="#the-object-class"><span class="std std-ref">The object Class</span></a>). In either case, there is exactly one
<em>parent</em> class. There can be many classes that inherit from a particular
parent class.</p>
<p>It is possible for a class to inherit from a generic class. Suppose for
example that a class <code class="docutils literal notranslate"><span class="pre">C</span></code> inherits from class <code class="docutils literal notranslate"><span class="pre">ParentC</span></code>. In this
situation, <code class="docutils literal notranslate"><span class="pre">C</span></code> will have type constructor arguments based upon generic
fields in the <code class="docutils literal notranslate"><span class="pre">ParentC</span></code> as described
in <a class="reference internal" href="generics.html#type-constructors"><span class="std std-ref">The Type Constructor</span></a>. Furthermore, a fully specified <code class="docutils literal notranslate"><span class="pre">C</span></code>
will be a subclass of a corresponding fully specified <code class="docutils literal notranslate"><span class="pre">ParentC</span></code>.</p>
<div class="section" id="the-object-class">
<span id="id9"></span><h3>The <em>object</em> Class<a class="headerlink" href="#the-object-class" title="Permalink to this headline">¶</a></h3>
<p>All classes are derived from the <code class="docutils literal notranslate"><span class="pre">object</span></code> class, either directly or
indirectly. If no class name appears in <code class="docutils literal notranslate"><span class="pre">class-inherit</span></code> clause, the
class derives implicitly from <code class="docutils literal notranslate"><span class="pre">object</span></code>. Otherwise, a class derives
from <code class="docutils literal notranslate"><span class="pre">object</span></code> indirectly through the class it inherits. A variable of
type <code class="docutils literal notranslate"><span class="pre">object</span></code> can hold a reference to an object of any class type.</p>
</div>
<div class="section" id="accessing-base-class-fields">
<span id="id10"></span><h3>Accessing Base Class Fields<a class="headerlink" href="#accessing-base-class-fields" title="Permalink to this headline">¶</a></h3>
<p>A derived class contains data associated with the fields in its base
classes. The fields can be accessed in the same way that they are
accessed in their base class unless a getter method is overridden in the
derived class, as discussed
in <a class="reference internal" href="#overriding-base-class-methods"><span class="std std-ref">Overriding Base Class Methods</span></a>.</p>
</div>
<div class="section" id="shadowing-base-class-fields">
<span id="id11"></span><h3>Shadowing Base Class Fields<a class="headerlink" href="#shadowing-base-class-fields" title="Permalink to this headline">¶</a></h3>
<p>A field in the derived class can be declared with the same name as a
field in the base class. Such a field shadows the field in the base
class in that it is always referenced when it is accessed in the context
of the derived class.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>There is an expectation that there will be a way to reference the
field in the base class but this is not defined at this time.</p>
</div></blockquote>
</div>
<div class="section" id="overriding-base-class-methods">
<span id="id12"></span><h3>Overriding Base Class Methods<a class="headerlink" href="#overriding-base-class-methods" title="Permalink to this headline">¶</a></h3>
<p>If a method in a derived class is declared with a signature identical to
that of a method in a base class, then it is said to override the base
class’s method. Such methods may be considered for dynamic dispatch if
certain criteria are met. In particular, dynamic dispatch will be used
when the method receiver has a static type of the base class but refers
to an instance of a derived class type. Additionally, a method eligible
for dynamic dispatch must not be a class method (see <a class="reference internal" href="#class-methods"><span class="std std-ref">Class Methods</span></a>),
must not return <code class="docutils literal notranslate"><span class="pre">type</span></code>, and must not return <code class="docutils literal notranslate"><span class="pre">param</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Class methods, methods that return <code class="docutils literal notranslate"><span class="pre">type</span></code>, and methods that return
<code class="docutils literal notranslate"><span class="pre">param</span></code> are not considered as candidates for dynamic dispatch because
they are resolved at compile-time based on the static type of the
method receiver.</p>
</div></blockquote>
<p>In order to have identical signatures, two methods must have the same
names, and their formal arguments must have the same names, intents, types,
and order.</p>
<p>The return type of the overriding method must either be the same as the
return type of the base class’s method or be a subclass of the base class
method’s return type.</p>
<p>Methods that override a base class method must be marked with the
<code class="docutils literal notranslate"><span class="pre">override</span></code> keyword in the <code class="docutils literal notranslate"><span class="pre">procedure-kind</span></code>. Additionally, methods
marked with <code class="docutils literal notranslate"><span class="pre">override</span></code> but for which there is no parent class method
with an identical signature will result in a compiler error.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>This feature is designed to help avoid cases where class authors
accidentally override a method without knowing it; or fail to
override a method that they intended to due to not meeting the
identical signature condition.</p>
</div></blockquote>
<p>Methods without parentheses are not candidates for dynamic dispatch.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Methods without parentheses are primarily used for field accessors. A
default is created if none is specified. The field accessor should
not dispatch dynamically since that would make it impossible to
access a base field within a base method should that field be
shadowed by a subclass.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="class-new">
<span id="id13"></span><h2>Class New<a class="headerlink" href="#class-new" title="Permalink to this headline">¶</a></h2>
<p>To create an instance of a class, use a <code class="docutils literal notranslate"><span class="pre">new</span></code> expression. For example:</p>
<blockquote>
<div><p><em>Example (class-new.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The new expression can be defined by the following syntax:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>new-expression:
  &#39;new&#39; type-expression ( argument-list )
</pre></div>
</div>
<p>An initializer for a given class is called by placing the <code class="docutils literal notranslate"><span class="pre">new</span></code>
operator in front of a type expression. Any initializer arguments follow
the class name in a parenthesized list.</p>
<p>Syntactically, the <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> includes <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>,
<code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>. However these have important
consequences for class new expressions. In particular, suppose <code class="docutils literal notranslate"><span class="pre">C</span></code> is
a <code class="docutils literal notranslate"><span class="pre">type-expression</span></code> that results in a class type. Then:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code> allocates and initializes an instance that will be
deleted at the end of the current block unless it is transferred to
another <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable. It results in something of type
<code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">shared</span> <span class="pre">C()</span></code> allocates and initializes the instance that will
be deleted when the last <code class="docutils literal notranslate"><span class="pre">shared</span></code> variable referring to it goes out
of scope. Results in something of type <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span> <span class="pre">C()</span></code> allocates and initializes an instance that will
be automatically deleted at the end of the current block. This
process is managed by an <code class="docutils literal notranslate"><span class="pre">owned</span></code> temporary. Unlike
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code>, this results in a value of type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> and
ownership of the instance cannot be transferred out of the block. In
other words, <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span> <span class="pre">C()</span></code> is equivalent to</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">()).</span><span class="nx">borrow</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">unmanaged</span> <span class="pre">C()</span></code> allocates and initializes an instance that must
have <code class="docutils literal notranslate"><span class="pre">delete</span></code> called on it explicitly to avoid a memory leak. It
results in something of type <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C</span></code>.</p></li>
</ul>
<p>See also <a class="reference internal" href="#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a> and
<a class="reference internal" href="#class-types"><span class="std std-ref">Class Types</span></a>.</p>
</div>
<div class="section" id="class-initializers">
<span id="id14"></span><h2>Class Initializers<a class="headerlink" href="#class-initializers" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">new</span></code> expression allocates memory for the desired class and invokes
an <em>initializer</em> method on the uninitialized memory, passing any
arguments following the class name. An initializer is implemented by a
method named <code class="docutils literal notranslate"><span class="pre">init</span></code> and is responsible for initializing the fields of
the class.</p>
<p>Any initializers declared in a program are <em>user-defined</em> initializers.
If the program declares no initializers for a class, the compiler must
generate an initializer for that class based on the types and
initialization expressions of fields defined by that class.</p>
<div class="section" id="user-defined-initializers">
<span id="id15"></span><h3>User-Defined Initializers<a class="headerlink" href="#user-defined-initializers" title="Permalink to this headline">¶</a></h3>
<p>A user-defined initializer is an initializer method explicitly declared
in the program. An initializer declaration has the same syntax as a
method declaration, with the restrictions that the name of the method
must be <code class="docutils literal notranslate"><span class="pre">init</span></code> and there must not be a return type specifier. When an
initializer is called, the usual function resolution mechanism
(<a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>) is applied with the exception that
an initializer may not be virtually dispatched.</p>
<p>A user-defined initializer is responsible for initializing all fields.
An initializer may omit initialization of fields, but all fields that
are initialized must be initialized in declaration order.</p>
<p>Initializers for generic classes (<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>) handle
generic fields without default values differently and may need to
satisfy additional requirements. See
Section <a class="reference internal" href="generics.html#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a> for details.</p>
<blockquote>
<div><p><em>Example (simpleInitializers.chpl)</em>.</p>
<p>The following example shows a class with two initializers:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MessagePoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">message</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="s">&quot;a point&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// class MessagePoint</span>

<span class="c1">// create two objects</span>
<span class="kd">var</span> <span class="nx">mp1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MessagePoint</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">mp2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MessagePoint</span><span class="p">(</span><span class="s">&quot;point mp2&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer lets the user specify the initial coordinates
and the second initializer lets the user specify the initial message
when creating a MessagePoint.</p>
</div></blockquote>
<div class="section" id="field-initialization-versus-assignment">
<span id="id16"></span><h4>Field Initialization Versus Assignment<a class="headerlink" href="#field-initialization-versus-assignment" title="Permalink to this headline">¶</a></h4>
<p>Within the body of an initializer, the first use of a field as the
left-hand side of an assignment statement will be considered
initialization. Subsequent uses of the assignment operator on the field
will invoke regular assignment as defined by the language.</p>
<blockquote>
<div><p><em>Example (fieldInitAssignment.chpl)</em>.</p>
<p>The following example documents the difference between field
initialization and field assignment.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PointDoubleX</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>              <span class="c1">// initialization</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// use of initialized field</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// assignment, use of initialized field</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>              <span class="c1">// initialization</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PointDoubleX</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first statement in the initializer initializes field <code class="docutils literal notranslate"><span class="pre">x</span></code> to the
value of the formal <code class="docutils literal notranslate"><span class="pre">x</span></code>. The second statement simply reads the
value of the initialized field. The third statement reads the value
of the field, doubles it, and <em>assigns</em> the result to the field
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div></blockquote>
<p>If a field is used before it is initialized, an compile-time error will
be issued.</p>
<blockquote>
<div><p><em>Example (usedBeforeInitialized.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// Error: use of uninitialized field!</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first statement in the initializer reads the value of
uninitialized field <code class="docutils literal notranslate"><span class="pre">x</span></code>, so the compiler will issue an error:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>usedBeforeInitialized.chpl:4: In initializer:
usedBeforeInitialized.chpl:5: error: field &quot;x&quot; used before it is initialized
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="omitting-field-initializations">
<span id="id17"></span><h4>Omitting Field Initializations<a class="headerlink" href="#omitting-field-initializations" title="Permalink to this headline">¶</a></h4>
<p>In order to support productive and elegant initializers, the language
allows field initializations to be omitted if the field has a type or if
the field has an initialization expression. The compiler will insert
initialization statements for such fields based on their types and
default values.</p>
<blockquote>
<div><p><em>Example (fieldInitOmitted.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LabeledPoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&#39;Unlabeled&#39;</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="c1">// compiler inserts &quot;this.msg = &#39;Unlabeled&#39;&quot;;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compiler inserts &quot;this.x = 0.0;&quot;</span>
    <span class="c1">// compiler inserts &quot;this.y = 0.0;&quot;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="s">&quot;Origin&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer initializes the values of fields <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>, and the compiler inserts initialization for the <code class="docutils literal notranslate"><span class="pre">msg</span></code> field
by using its default value. The second initializer initializes the
<code class="docutils literal notranslate"><span class="pre">msg</span></code> field, and the compiler inserts initialization for fields
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> based on the type of those fields
(<a class="reference internal" href="variables.html#default-values-for-types"><span class="std std-ref">Default Initialization</span></a>).</p>
</div></blockquote>
<p>In order to reduce ambiguity and to ensure a well-defined order for
side-effects, the language requires that all fields be initialized in
field declaration order. This applies regardless of whether field
initializations are omitted from the initializer body. If fields are
initialized out of order, a compile-time error will be issued.</p>
<blockquote>
<div><p><em>Example (fieldsOutOfOrder.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="c1">// compiler inserts &quot;this.y = 1.0;&quot;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// Error!</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer leverages the well-defined order of omitted
field initialization to use the default value of field <code class="docutils literal notranslate"><span class="pre">y</span></code> in order
to explicitly initialize field <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>The second initializer initializes field <code class="docutils literal notranslate"><span class="pre">z</span></code> before field <code class="docutils literal notranslate"><span class="pre">y</span></code>,
causing a compile-time error to be issued.</p>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Without this rule the compiler could insert default initialization
for field <code class="docutils literal notranslate"><span class="pre">y</span></code> before <code class="docutils literal notranslate"><span class="pre">z</span></code> is explicitly initialized. The following
statement would then be <em>assignment</em> to field <code class="docutils literal notranslate"><span class="pre">y</span></code>, despite
appearing to be initialization. This subtle difference may be
confusing and surprising, and is avoided by requiring fields to be
initialized in field declaration order.</p>
</div></blockquote>
</div>
<div class="section" id="limitations-on-instance-usage-in-initializers">
<span id="id18"></span><h4>Limitations on Instance Usage in Initializers<a class="headerlink" href="#limitations-on-instance-usage-in-initializers" title="Permalink to this headline">¶</a></h4>
<p>As the initializer makes progress, the class instance is incrementally
initialized. In order to prevent usage of uninitialized memory, there
are restrictions on usage of the class instance before it is fully
initialized:</p>
<ul class="simple">
<li><p>Methods may not be invoked on partially-initialized instances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">this</span></code> may not be passed to functions while partially-initialized</p></li>
</ul>
<p>These rules allow all methods and functions to assume that class
instances have been initialized, provided their value is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>The compiler could conceivably attempt to analyze methods and
functions to determine which fields are used, and selectively allow
method calls on partially-initialized class instances. Instead, it is
simpler for the language to forbid method calls on
partially-initialized instances.</p>
</div></blockquote>
<p>Methods may be called and <code class="docutils literal notranslate"><span class="pre">this</span></code> may be passed to functions only after
the built-in <code class="docutils literal notranslate"><span class="pre">complete</span></code> method is invoked. This method may not be
overridden. If any fields have not been initialized by the time the
<code class="docutils literal notranslate"><span class="pre">complete</span></code> method is invoked, they will be considered omitted and the
compiler will insert initialization statements as described earlier. If
the user does not invoke the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method explicitly, the
compiler will insert a call to <code class="docutils literal notranslate"><span class="pre">complete</span></code> at the end of the
initializer.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Due to support for omitted field initialization, there is potential
for confusion regarding the overall status of initialization. This
confusion is addressed in the design by requiring <code class="docutils literal notranslate"><span class="pre">complete</span></code> to
explicitly mark the transition between partially and fully
initialized instances.</p>
</div></blockquote>
<blockquote>
<div><p><em>Implementors’ note</em>.</p>
<p>Even if the user explicitly initializes every field, the <code class="docutils literal notranslate"><span class="pre">complete</span></code>
method is still required to invoke other methods.</p>
<p><em>Example (thisDotComplete.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LabeledPoint</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&#39;Unlabeled&#39;</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="c1">// compiler inserts initialization for &#39;max&#39; and &#39;msg&#39;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">complete</span><span class="p">();</span> <span class="c1">// &#39;this&#39; is now considered to be fully initialized</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">verify</span><span class="p">();</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">msg</span> <span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// compiler inserts initialization for fields &#39;x&#39;, &#39;y&#39;, and &#39;max&#39;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>

    <span class="c1">// Illegal: this.verify();</span>
    <span class="c1">// Implicit &#39;this.complete();&#39;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">verify</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="k">then</span>
      <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;LabeledPoint out of bounds!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LabeledPoint</span><span class="p">(</span><span class="s">&quot;Origin&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer leverages the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method to initialize
the remaining fields and to allow for the usage of the <code class="docutils literal notranslate"><span class="pre">verify</span></code>
method. Calling the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method or passing <code class="docutils literal notranslate"><span class="pre">this</span></code> to
<code class="docutils literal notranslate"><span class="pre">writeln</span></code> before the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method is called would result in
a compile-time error.</p>
<p>The second initializer exists to emphasize the rule that even though
all fields are initialized after the initialization of the <code class="docutils literal notranslate"><span class="pre">msg</span></code>
field, the compiler does not consider the type initialized until the
<code class="docutils literal notranslate"><span class="pre">complete</span></code> method is called. If the second initializer tried to
invoke the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method, a compile-time error would be issued.</p>
</div></blockquote>
</div>
<div class="section" id="invoking-other-initializers">
<span id="id19"></span><h4>Invoking Other Initializers<a class="headerlink" href="#invoking-other-initializers" title="Permalink to this headline">¶</a></h4>
<p>In order to allow for code-reuse, an initializer may invoke another
initializer implemented for the same type. Because the invoked
initializer must operate on completely uninitialized memory, a
compile-time error will be issued for field initialization before a call
to <code class="docutils literal notranslate"><span class="pre">init</span></code>. Because each initializer either explicitly or implicitly
invokes the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method, all fields and methods may be used
after such a call to <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<blockquote>
<div><p><em>Example (thisDotInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="c1">// implicit &#39;this.complete();&#39;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">u</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="p">);</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The second initializer leverages the first initializer to initialize
all fields with the same value. After the <code class="docutils literal notranslate"><span class="pre">init</span></code> call the type is
fully initialized, the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method has been invoked, and so
<code class="docutils literal notranslate"><span class="pre">this</span></code> can be passed to the <code class="docutils literal notranslate"><span class="pre">writeln</span></code> function.</p>
</div></blockquote>
</div>
<div class="section" id="initializing-fields-in-conditional-statements">
<span id="id20"></span><h4>Initializing Fields in Conditional Statements<a class="headerlink" href="#initializing-fields-in-conditional-statements" title="Permalink to this headline">¶</a></h4>
<p>Fields may be initialized inside of conditional statements, with the
restriction that the same set of fields must be initialized in every
branch. If the user omits any field initializations, the compiler will
insert field initializations up to and including the field furthest in
field declaration order between the conditional branches. If the else
branch of a conditional statement is omitted, the compiler will generate
an empty else branch and insert field initialization statements as
needed.</p>
<blockquote>
<div><p><em>Example (initFieldConditional.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">theta</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">polar</span> <span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">polar</span> <span class="p">{</span>
      <span class="c1">// compiler inserts initialization for fields &#39;x&#39; and &#39;y&#39;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="c1">// compiler inserts initialization for field &#39;r&#39;</span>
    <span class="p">}</span>
    <span class="c1">// compiler inserts initialization for field &#39;theta&#39;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler identifies field <code class="docutils literal notranslate"><span class="pre">r</span></code> as the latest field in both
branches, and inserts omitted field initialization statements as
needed to ensure that fields <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">r</span></code> are all
initialized by the end of the conditional.</p>
</div></blockquote>
<p>Conditionals may also contain calls to parent initializers
(<a class="reference internal" href="#initializing-inherited"><span class="std std-ref">Initializing Inherited Classes</span></a>) and other initializers defined
for the current type, provided that the initialization state is the same
at the end of the conditional statement.</p>
<blockquote>
<div><p><em>Example (thisDotInitConditional.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">cond</span> <span class="p">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">cond</span> <span class="p">{</span>
      <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">complete</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The first initializer must invoke the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method at the end
of the if-branch in order to match the state at the end of the
else-branch.</p>
</div></blockquote>
</div>
<div class="section" id="miscellaneous-field-initialization-rules">
<h4>Miscellaneous Field Initialization Rules<a class="headerlink" href="#miscellaneous-field-initialization-rules" title="Permalink to this headline">¶</a></h4>
<p>Fields may not be initialized within loop statements or parallel
statements.</p>
</div>
</div>
<div class="section" id="the-compiler-generated-initializer">
<span id="id21"></span><h3>The Compiler-Generated Initializer<a class="headerlink" href="#the-compiler-generated-initializer" title="Permalink to this headline">¶</a></h3>
<p>A compiler-generated initializer for a class is created automatically if
there are no initializers for that class in the program. The
compiler-generated initializer has one argument for every field in the
class, each of which has a default value equal to the field’s default
value (if present) or the default value of the field’s type (if not).
The order and names of arguments matches the order and names of field
declarations within the class.</p>
<p>Generic fields are discussed in
Section <a class="reference internal" href="generics.html#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Initializer</span></a>.</p>
<p>The compiler-generated initializer will initialize each field to the
value of the corresponding actual argument.</p>
<blockquote>
<div><p><em>Example (defaultInitializer.chpl)</em>.</p>
<p>Given the class</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>there are no user-defined initializers for <code class="docutils literal notranslate"><span class="pre">C</span></code>, so <code class="docutils literal notranslate"><span class="pre">new</span></code>
expressions will invoke <code class="docutils literal notranslate"><span class="pre">C</span></code>’s compiler-generated initializer. The
<code class="docutils literal notranslate"><span class="pre">x</span></code> argument of the compiler-generated initializer has the default
value <code class="docutils literal notranslate"><span class="pre">0</span></code>. The <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> arguments have the default values
<code class="docutils literal notranslate"><span class="pre">3.14</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;Hello,</span> <span class="pre">World!</span></code>”, respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">C</span></code> instances can be created by calling the compiler-generated
initializer as follows:</p>
<ul class="simple">
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,3.14,&quot;Hello,</span> <span class="pre">World!&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,3.14,&quot;Hello,</span> <span class="pre">World!&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(z=&quot;&quot;)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,3.14,&quot;&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,</span> <span class="pre">z=&quot;&quot;)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(2,3.14,&quot;&quot;)</span></code>.</p></li>
<li><p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C(0,0.0,&quot;&quot;)</span></code> specifies the initial values for all
fields explicitly.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="the-postinit-method">
<span id="id22"></span><h3>The postinit Method<a class="headerlink" href="#the-postinit-method" title="Permalink to this headline">¶</a></h3>
<p>The compiler-generated initializer is powerful and flexible, but cannot
satisfy all initialization patterns desired by users. One way for users
to leverage the compiler-generated initializer while adding their own
functionality is to implement a method named <code class="docutils literal notranslate"><span class="pre">postinit</span></code>. The
<code class="docutils literal notranslate"><span class="pre">postinit</span></code> method may also be implemented for types with user-defined
initializers.</p>
<p>The compiler will insert a call to the <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method after the
initializer invoked by the <code class="docutils literal notranslate"><span class="pre">new</span></code> expression finishes, if the method
exists. The <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method accepts zero arguments and may not
return anything. Otherwise, this method behaves like any other method.</p>
<blockquote>
<div><p><em>Example (postinit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">verify</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">verify</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="k">then</span>
      <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;  Point out of bounds!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">5.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">D</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point3D</span><span class="p">(</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Each of the <code class="docutils literal notranslate"><span class="pre">new</span></code> expressions invokes the compiler-generated
initializer, then invokes the <code class="docutils literal notranslate"><span class="pre">verify</span></code> method via the <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>(0.0, 0.0)
(1.0, 2.0)
(0.0, 5.0)
(50.0, 50.0)
  Point out of bounds!
</pre></div>
</div>
</div></blockquote>
<p>For classes that inherit, the user may invoke the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method or let the compiler insert a call automatically
(<a class="reference internal" href="#the-postinit-method-for-inheriting-classes"><span class="std std-ref">The postinit Method for Inheriting Classes</span></a>).</p>
</div>
<div class="section" id="initializing-inherited-classes">
<span id="initializing-inherited"></span><h3>Initializing Inherited Classes<a class="headerlink" href="#initializing-inherited-classes" title="Permalink to this headline">¶</a></h3>
<p>User-defined initializers also allow for control over initialization of
parent classes. All the fields of the parent type must be initialized
before any fields of the child type, otherwise a compile-time error is
issued. This allows for parent fields to be used in the definition of
child fields. An initializer may invoke a parent’s initializer using the
<code class="docutils literal notranslate"><span class="pre">super</span></code> keyword.</p>
<p>If the user does not explicitly call the parent’s initializer, the
compiler will insert a call to the parent initializer with zero
arguments at the start of the initializer.</p>
<blockquote>
<div><p><em>Example (simpleSuperInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">val</span> <span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">:</span> <span class="nx">A</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">val</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// implicit super.init();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">b</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">b1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">b2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</pre></div>
</div>
<p>The first initializer explicitly calls an initializer for class
<code class="docutils literal notranslate"><span class="pre">A</span></code>. Once the parent’s initializer is complete, fields of class
<code class="docutils literal notranslate"><span class="pre">B</span></code> may be initialized.</p>
<p>The second initializer implicitly invokes the parent’s initializer
with zero arguments, and then uses the parent’s fields to initialize
its own fields.</p>
</div></blockquote>
<p>As stated earlier, the compiler will insert a zero-argument call to the
parent’s initializer if the user has not explicitly written one
themselves. The exception to this rule is if the initializer body
invokes another initializer on the current type
(<a class="reference internal" href="#invoking-other-initializers"><span class="std std-ref">Invoking Other Initializers</span></a>). This other initializer
will either contain an implicit or explicit call to the parent
initializer, and so the calling initializer should not attempt to
initialize the parent itself. This also means that parent fields may not
be accessed before explicit calls to <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<blockquote>
<div><p><em>Example (superInitThisInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The second initializer does not contain an implicit call to the
parent’s initializer because it explicitly invokes another
initializer.</p>
</div></blockquote>
<div class="section" id="calling-methods-on-parent-classes">
<span id="id23"></span><h4>Calling Methods on Parent Classes<a class="headerlink" href="#calling-methods-on-parent-classes" title="Permalink to this headline">¶</a></h4>
<p>Once <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> returns, the dynamic type of <code class="docutils literal notranslate"><span class="pre">this</span></code> is the
parent’s type until the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method
(<a class="reference internal" href="#limitations-on-instance-usage-in-initializers"><span class="std std-ref">Limitations on Instance Usage in Initializers</span></a>) is
invoked (except when the child’s fields are initialized and used). As a
result, the parent’s methods may be called and <code class="docutils literal notranslate"><span class="pre">this</span></code> may be passed to
functions as though it were of the parent type.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> returns the instance is in some
partially-initialized, but valid, state. Allowing <code class="docutils literal notranslate"><span class="pre">this</span></code> to be
treated as the parent allows for additional functionality and
flexibility for users.</p>
</div></blockquote>
<blockquote>
<div><p><em>Example (dynamicThisInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parent.foo&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// parent&#39;s compiler-generated initializer</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Parent.foo()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">complete</span><span class="p">();</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// Child.foo()</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="k">proc</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Child.foo&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Once the parent’s initializer is finished, the parent method <code class="docutils literal notranslate"><span class="pre">foo</span></code>
may be called. After the <code class="docutils literal notranslate"><span class="pre">complete</span></code> method is invoked, a call to
<code class="docutils literal notranslate"><span class="pre">foo</span></code> resolves to the child’s overridden
(<a class="reference internal" href="#overriding-base-class-methods"><span class="std std-ref">Overriding Base Class Methods</span></a>) implementation:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Parent.foo
Child.foo
{x = 1.0, y = 2.0, z = 3.0}
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="the-compiler-generated-initializer-for-inheriting-classes">
<span id="id24"></span><h4>The Compiler Generated Initializer for Inheriting Classes<a class="headerlink" href="#the-compiler-generated-initializer-for-inheriting-classes" title="Permalink to this headline">¶</a></h4>
<p>The compiler-generated initializer for inheriting classes will have
arguments with default values and names based on the field declarations
in the parent class. Formals for the parent type will be listed before
formals for the child type.</p>
<blockquote>
<div><p><em>Example (compilerGeneratedInheritanceInit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span> <span class="c1">// x=1.0, y=2.0, z=3.0</span>
<span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">y</span><span class="o">=</span><span class="mf">10.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Any <code class="docutils literal notranslate"><span class="pre">new</span></code> expressions using the <code class="docutils literal notranslate"><span class="pre">Child</span></code> type can invoke an
initializer with three formals named <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> that all
have default values based on their types.</p>
</div></blockquote>
</div>
<div class="section" id="the-postinit-method-for-inheriting-classes">
<span id="id25"></span><h4>The postinit Method for Inheriting Classes<a class="headerlink" href="#the-postinit-method-for-inheriting-classes" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method on inheriting classes allows users to invoke the
parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method using the <code class="docutils literal notranslate"><span class="pre">super</span></code> keyword. If the user
does not explicitly invoke the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>, the compiler will
insert the call at the top of the user’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method. If the
parent type has a <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method but the inheriting class does not,
the compiler will generate a <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method that simply invokes the
parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method.</p>
<blockquote>
<div><p><em>Example (inheritancePostinit.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Parent.postinit: &quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">postinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// compiler inserts &quot;super.postinit();&quot;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Child.postinit: &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler inserts a call to the parent’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method in
the child’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code> method, and invokes the child’s <code class="docutils literal notranslate"><span class="pre">postinit</span></code>
method after the compiler-generated initializer finishes:</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>Parent.postinit: 1.0, 2.0
Child.postinit: 3.0, 4.0
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="field-accesses">
<span id="class-field-accesses"></span><h2>Field Accesses<a class="headerlink" href="#field-accesses" title="Permalink to this headline">¶</a></h2>
<p>The field in a class is accessed via a field access expression.</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>field-access-expression:
  receiver-clause[OPT] identifier

receiver-clause:
  expression .
</pre></div>
</div>
<p>The receiver-clause specifies the <em>receiver</em>, which is the class
instance whose field is being accessed. The receiver clause can be
omitted when the field access is within a method. In this case the
receiver is the method’s receiver. The receiver clause can also be
omitted when the field access is within a class declaration. In this
case the receiver is the instance being implicitly defined or
referenced.</p>
<p>The identifier in the field access expression indicates which field is
accessed.</p>
<p>A field can be modified via an assignment statement where the left-hand
side of the assignment is a field access expression.</p>
<p>Accessing a parameter or type field returns a parameter or type,
respectively. In addition to being available for access with a class
instance receiver, parameter and type fields can be accessed from the
instantiated class type itself.</p>
<blockquote>
<div><p><em>Example (useActor1.chpl)</em>.</p>
<p>Given a variable <code class="docutils literal notranslate"><span class="pre">anActor</span></code> of type <code class="docutils literal notranslate"><span class="pre">Actor</span></code> as defined above, the
code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span><span class="p">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="nx">anActor</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="nx">anActor</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
</pre></div>
</div>
<p>reads the field <code class="docutils literal notranslate"><span class="pre">name</span></code> and assigns the value to the variable <code class="docutils literal notranslate"><span class="pre">s</span></code>,
and assigns the field <code class="docutils literal notranslate"><span class="pre">age</span></code> in the object <code class="docutils literal notranslate"><span class="pre">anActor</span></code> the value
<code class="docutils literal notranslate"><span class="pre">27</span></code>.</p>
</div></blockquote>
<div class="section" id="variable-getter-methods">
<span id="getter-methods"></span><h3>Variable Getter Methods<a class="headerlink" href="#variable-getter-methods" title="Permalink to this headline">¶</a></h3>
<p>All field accesses are performed via getters. A getter is a method
without parentheses with the same name as the field. It is defined in
the field’s class and has a <code class="docutils literal notranslate"><span class="pre">ref</span></code> return intent
(<a class="reference internal" href="procedures.html#ref-return-intent"><span class="std std-ref">The Ref Return Intent</span></a>). If the program does not define it,
the default getter, which simply returns the field, is provided.</p>
<blockquote>
<div><p><em>Example (getterSetter.chpl)</em>.</p>
<p>In the code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">setCount</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">x</span> <span class="kd">ref</span> <span class="p">{</span>
    <span class="nx">setCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">x</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>an explicit variable getter method is defined for field <code class="docutils literal notranslate"><span class="pre">x</span></code>. It
returns the field <code class="docutils literal notranslate"><span class="pre">x</span></code> and increments another field that records the
number of times x was assigned a value.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="class-method-calls">
<span id="id26"></span><h2>Class Method Calls<a class="headerlink" href="#class-method-calls" title="Permalink to this headline">¶</a></h2>
<p>Class method calls are similar to other method calls which are described
in <a class="reference internal" href="methods.html#method-calls"><span class="std std-ref">Method Calls</span></a>. However, class method calls are subject
to dynamic dispatch.</p>
<p>The receiver-clause (or its absence) specifies the method’s receiver in
the same way it does for field accesses
<a class="reference internal" href="#class-field-accesses"><span class="std std-ref">Field Accesses</span></a>.</p>
<p>See (<a class="reference internal" href="methods.html#method-receiver-and-this"><span class="std std-ref">The Method Receiver and the this Argument</span></a>) for more details of about
method receivers.</p>
</div>
<div class="section" id="common-operations">
<h2>Common Operations<a class="headerlink" href="#common-operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="class-assignment">
<span id="id27"></span><h3>Class Assignment<a class="headerlink" href="#class-assignment" title="Permalink to this headline">¶</a></h3>
<p>Classes are assigned by reference. After an assignment from one variable
of a class type to another, both variables reference the same class
instance. Assignments from an <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable to another <code class="docutils literal notranslate"><span class="pre">owned</span></code> or
<code class="docutils literal notranslate"><span class="pre">shared</span></code> variable are an exception. They transfer ownership, leaving
the source variable empty i.e. storing <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<blockquote>
<div><p><em>Example (owned-assignment.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// assume that C is a class</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span> <span class="c1">// default initialized to store `nil`</span>
<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// transfers ownership from a to b</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a is left storing `nil`</span>
</pre></div>
</div>
</div></blockquote>
<p>In contrast, assignment for <code class="docutils literal notranslate"><span class="pre">shared</span></code> variables allows both variables
to refer to the same class instance.</p>
<p>The following assignments between variables or expressions with
different memory management strategies are disallowed:</p>
<ul class="simple">
<li><p>to <code class="docutils literal notranslate"><span class="pre">owned</span></code> from <code class="docutils literal notranslate"><span class="pre">shared</span></code> or <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, as it would not ensure
unique ownership of the instance</p></li>
<li><p>to <code class="docutils literal notranslate"><span class="pre">shared</span></code> from <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, as the original owner would be
unaware of the shared ownership</p></li>
<li><p>to <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, or <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> from <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, as both
the source and the destination would appear responsible for deleting
the instance</p></li>
</ul>
</div>
</div>
<div class="section" id="deleting-unmanaged-class-instances">
<span id="class-delete"></span><h2>Deleting Unmanaged Class Instances<a class="headerlink" href="#deleting-unmanaged-class-instances" title="Permalink to this headline">¶</a></h2>
<p>Memory associated with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> class instances can be reclaimed
with the <code class="docutils literal notranslate"><span class="pre">delete</span></code> statement:</p>
<div class="highlight-syntax notranslate"><div class="highlight"><pre><span></span>delete-statement:
  &#39;delete&#39; expression-list ;
</pre></div>
</div>
<p>where the expression-list specifies the class objects whose memory will
be reclaimed. Prior to releasing their memory, the deinitialization
routines for these objects will be executed
(<a class="reference internal" href="#class-deinitializer"><span class="std std-ref">Class Deinitializer</span></a>). The expression-list can contain
array expressions, in which case each element of that array will be
deleted in parallel using a <code class="docutils literal notranslate"><span class="pre">forall</span></code> loop over the array. It is legal
to delete a class variable whose value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, though this has no
effect. If a class instance is referenced after it has been deleted, the
behavior is undefined.</p>
<blockquote>
<div><p><em>Example (delete.chpl)</em>.</p>
<p>The following example allocates a new object <code class="docutils literal notranslate"><span class="pre">c</span></code> of class type
<code class="docutils literal notranslate"><span class="pre">C</span></code> and then deletes it.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Does nothing: c is nil.</span>

<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">();</span> <span class="c1">// Creates a new object.</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Deletes that object.</span>

<span class="c1">// The following statements reference an object after it has been deleted, so</span>
<span class="c1">// the behavior of each is &quot;undefined&quot;:</span>
<span class="c1">// writeln(c.i); // May read from freed memory.</span>
<span class="c1">// c.i = 3;      // May overwrite freed memory.</span>
<span class="c1">// delete c;     // May confuse some allocators.</span>
</pre></div>
</div>
</div></blockquote>
<div class="section" id="class-deinitializer">
<span id="id28"></span><h3>Class Deinitializer<a class="headerlink" href="#class-deinitializer" title="Permalink to this headline">¶</a></h3>
<p>A class author may create a deinitializer to specify additional actions
to be performed when a class instance is deleted. A class deinitializer
is a method named <code class="docutils literal notranslate"><span class="pre">deinit()</span></code>. It must take no arguments (aside from the
implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument). If defined, the deinitializer is called each
time a <code class="docutils literal notranslate"><span class="pre">delete</span></code> statement is invoked with a valid instance of that
class type. The deinitializer is not called if the argument of <code class="docutils literal notranslate"><span class="pre">delete</span></code>
evaluates to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Note that when an <code class="docutils literal notranslate"><span class="pre">owned</span></code> or <code class="docutils literal notranslate"><span class="pre">shared</span></code> reaches
its deinit point (see <a class="reference internal" href="variables.html#deinit-points"><span class="std std-ref">Deinit Points</span></a>), it may call <code class="docutils literal notranslate"><span class="pre">delete</span></code> on a
class instance which in turn will run the deinitializer and then reclaim
the memory.</p>
<blockquote>
<div><p><em>Example (classDeinitializer.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">deinit</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Bye, bye &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>              <span class="c1">// Does nothing: c is nil.</span>

<span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Creates a new instance.</span>
<span class="k">delete</span> <span class="nx">c</span><span class="p">;</span>               <span class="c1">// Deletes that instance: Writes out &quot;Bye, bye 1&quot;</span>
                        <span class="c1">// and reclaims the memory that was held by c.</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">own</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Creates a new owned instance</span>
                            <span class="c1">// The instance is automatically deleted at</span>
                            <span class="c1">// the end of this block, so &quot;Bye, bye 2&quot; is</span>
                            <span class="c1">// output and then the memory is reclaimed.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="records.html" class="btn btn-neutral float-right" title="Records" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tuples.html" class="btn btn-neutral float-left" title="Tuples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>