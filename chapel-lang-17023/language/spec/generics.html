

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Generics &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Input and Output" href="input-and-output.html" />
    <link rel="prev" title="Iterators" href="iterators.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/spec/generics";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversions.html">Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Generics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generic-functions">Generic Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#formal-type-arguments">Formal Type Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-parameter-arguments">Formal Parameter Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-without-types">Formal Arguments without Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-with-queried-types">Formal Arguments with Queried Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-of-generic-type">Formal Arguments of Generic Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-of-partially-generic-type">Formal Arguments of Partially Generic Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formal-arguments-of-generic-array-types">Formal Arguments of Generic Array Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-visibility-in-generic-functions">Function Visibility in Generic Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generic-types">Generic Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#built-in-generic-types">Built-in Generic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-classes-and-records">Generic Classes and Records</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-aliases-in-generic-types">Type Aliases in Generic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameters-in-generic-types">Parameters in Generic Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fields-without-types">Fields without Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-type-constructor">The Type Constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-methods">Generic Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-compiler-generated-initializer">The Compiler-Generated Initializer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-initializers">User-Defined Initializers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#user-defined-compiler-diagnostics">User-Defined Compiler Diagnostics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-general-and-specialized-versions-of-a-function">Creating General and Specialized Versions of a Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-a-generic-stack">Example: A Generic Stack</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Generics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/language/spec/generics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="generics">
<span id="chapter-generics"></span><h1>Generics<a class="headerlink" href="#generics" title="Permalink to this headline">¶</a></h1>
<p>Chapel supports generic functions and types that are parameterizable
over both types and parameters. The generic functions and types look
similar to non-generic functions and types already discussed.</p>
<div class="section" id="generic-functions">
<span id="id1"></span><h2>Generic Functions<a class="headerlink" href="#generic-functions" title="Permalink to this headline">¶</a></h2>
<p>A function is generic if any of the following conditions hold:</p>
<ul class="simple">
<li><p>Some formal argument is specified with an intent of <code class="docutils literal notranslate"><span class="pre">type</span></code> or
<code class="docutils literal notranslate"><span class="pre">param</span></code>.</p></li>
<li><p>Some formal argument has no specified type and no default value.</p></li>
<li><p>Some formal argument is specified with a queried type.</p></li>
<li><p>The type of some formal argument is a generic type, e.g., <code class="docutils literal notranslate"><span class="pre">List</span></code>.
Queries may be inlined in generic types, e.g., <code class="docutils literal notranslate"><span class="pre">List(?eltType)</span></code>.</p></li>
<li><p>The type of some formal argument is an array type where either the
element type is queried or omitted or the domain is queried or
omitted.</p></li>
</ul>
<p>These conditions are discussed in the next sections.</p>
<div class="section" id="formal-type-arguments">
<span id="id2"></span><h3>Formal Type Arguments<a class="headerlink" href="#formal-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>If a formal argument is specified with intent <code class="docutils literal notranslate"><span class="pre">type</span></code>, then a type must
be passed to the function at the call site. A copy of the function is
instantiated for each unique type that is passed to this function at a
call site. The formal argument has the semantics of a type alias.</p>
<blockquote>
<div><p><em>Example (build2tuple.chpl)</em>.</p>
<p>The following code defines a function that takes two types at the
call site and returns a 2-tuple where the types of the components of
the tuple are defined by the two type arguments and the values are
specified by the types default values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">build2Tuple</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">tt</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x2</span><span class="p">:</span> <span class="nx">tt</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is instantiated with “normal” function call syntax
where the arguments are types:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t2</span> <span class="o">=</span> <span class="nx">build2Tuple</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">);</span>
<span class="nx">t2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>A formal type argument can include a formal type (a colon followed by a
type). This pattern is sometimes useful to create generic functions
accepting type arguments that only apply to a specific group of types.</p>
<blockquote>
<div><p><em>Example (typeColonArgument.chpl)</em>.</p>
<p>Suppose that we’d like to define a function that accepts a type
argument and returns 1 represented in that type.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">getOne</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span><span class="nx">numeric</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">:</span><span class="nx">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now calls to this function will resolve to the appropriate version
based upon the argument type supplied.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">anInt8</span> <span class="o">=</span> <span class="nx">getOne</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
<span class="kd">var</span> <span class="nx">aReal</span> <span class="o">=</span> <span class="nx">getOne</span><span class="p">(</span><span class="kt">real</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="formal-parameter-arguments">
<span id="id3"></span><h3>Formal Parameter Arguments<a class="headerlink" href="#formal-parameter-arguments" title="Permalink to this headline">¶</a></h3>
<p>If a formal argument is specified with intent <code class="docutils literal notranslate"><span class="pre">param</span></code>, then a
parameter must be passed to the function at the call site. A copy of the
function is instantiated for each unique parameter that is passed to
this function at a call site. The formal argument is a parameter.</p>
<blockquote>
<div><p><em>Example (fillTuple.chpl)</em>.</p>
<p>The following code defines a function that takes an integer parameter
<code class="docutils literal notranslate"><span class="pre">p</span></code> at the call site as well as a regular actual argument of
integer type <code class="docutils literal notranslate"><span class="pre">x</span></code>. The function returns a homogeneous tuple of size
<code class="docutils literal notranslate"><span class="pre">p</span></code> where each component in the tuple has the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function call <code class="docutils literal notranslate"><span class="pre">fillTuple(3,</span> <span class="pre">3)</span></code> returns a 3-tuple where each
component contains the value <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="formal-arguments-without-types">
<span id="id4"></span><h3>Formal Arguments without Types<a class="headerlink" href="#formal-arguments-without-types" title="Permalink to this headline">¶</a></h3>
<p>If the type of a formal argument is omitted, the type of the formal
argument is taken to be the type of the actual argument passed to the
function at the call site. A copy of the function is instantiated for
each unique actual type.</p>
<blockquote>
<div><p><em>Example (fillTuple2.chpl)</em>.</p>
<p>The example from the previous section can be extended to be generic
on a parameter as well as the actual argument that is passed to it by
omitting the type of the formal argument <code class="docutils literal notranslate"><span class="pre">x</span></code>. Additionally the
parameter argument can allow any type be passed. The following code
defines a function that returns a homogeneous tuple of size <code class="docutils literal notranslate"><span class="pre">p</span></code>
where each component in the tuple is initialized to <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this function, the type of the tuple is taken to be the type of
the actual argument. The call <code class="docutils literal notranslate"><span class="pre">fillTuple(3,</span> <span class="pre">3.14)</span></code> returns a
3-tuple of real values <code class="docutils literal notranslate"><span class="pre">(3.14,</span> <span class="pre">3.14,</span> <span class="pre">3.14)</span></code>. The return type is
<code class="docutils literal notranslate"><span class="pre">(real,</span> <span class="pre">real,</span> <span class="pre">real)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="formal-arguments-with-queried-types">
<span id="id5"></span><h3>Formal Arguments with Queried Types<a class="headerlink" href="#formal-arguments-with-queried-types" title="Permalink to this headline">¶</a></h3>
<p>If the type of a formal argument is specified as a queried type, the
type of the formal argument is taken to be the type of the actual
argument passed to the function at the call site. A copy of the function
is instantiated for each unique actual type. The queried type has the
semantics of a type alias.</p>
<blockquote>
<div><p><em>Example (fillTuple3.chpl)</em>.</p>
<p>The example from the previous section can be rewritten to use a
queried type for clarity:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">fillTuple</span><span class="p">(</span><span class="kd">param</span> <span class="nx">p</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">p</span><span class="o">*</span><span class="nx">t</span><span class="p">;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">result</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
    <span class="nx">result</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Example (query.chpl)</em>.</p>
<p>Type queries can also be used to constrain the types of other
function arguments and/or the return type. In this example, the type
query on the first argument establishes type constraints on the other
arguments and also determines the return type.</p>
<p>The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="nx">sumOfThree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">sumOfThree</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">));</span>

<span class="k">proc</span> <span class="nf">sumOfThree</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="p">?</span><span class="nx">t</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span><span class="nx">t</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span><span class="nx">t</span><span class="p">):</span><span class="nx">t</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">sum</span><span class="p">:</span> <span class="nx">t</span><span class="p">;</span>

   <span class="nx">sum</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
   <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>produces the output</p>
<div class="highlight-printoutput notranslate"><div class="highlight"><pre><span></span>6
12.0
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="formal-arguments-of-generic-type">
<span id="id6"></span><h3>Formal Arguments of Generic Type<a class="headerlink" href="#formal-arguments-of-generic-type" title="Permalink to this headline">¶</a></h3>
<p>If the type of a formal argument is a generic type, there must exist an
instantiation of that type that the actual argument can be implicitly
coerced to (<a class="reference internal" href="conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>). A copy of the function is
instantiated for each unique instantiation of the formal’s type.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code defines a function <code class="docutils literal notranslate"><span class="pre">writeTop</span></code> that takes an
actual argument that is a generic stack
(see <a class="reference internal" href="#example-generic-stack"><span class="std std-ref">Example: A Generic Stack</span></a>) and outputs the top element
of the stack. The function is generic on the type of its argument.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">writeTop</span><span class="p">(</span><span class="nx">s</span><span class="p">:</span> <span class="nx">Stack</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">write</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">top</span><span class="p">.</span><span class="nx">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Types and parameters may be queried from the types of formal arguments
as well. In the example above, the formal argument’s type could also be
specified as <code class="docutils literal notranslate"><span class="pre">Stack(?t)</span></code> in which case the symbol <code class="docutils literal notranslate"><span class="pre">t</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">s.itemType</span></code>.</p>
<p>Note that generic types which have default values for all of their
generic fields, <em>e.g. range</em>, are not generic when simply specified and
require a query to mark the argument as generic. For simplicity, the
identifier may be omitted.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The following code defines a class with a type field that has a
default value. Function <code class="docutils literal notranslate"><span class="pre">f</span></code> is defined to take an argument of this
class type where the type field is instantiated to the default.
Function <code class="docutils literal notranslate"><span class="pre">g</span></code>, on the other hand, is generic on its argument because
of the use of the question mark.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">t</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// c.type is always int</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(?))</span> <span class="p">{</span>
  <span class="c1">// c.type may not be int</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="formal-arguments-of-partially-generic-type">
<span id="id7"></span><h3>Formal Arguments of Partially Generic Type<a class="headerlink" href="#formal-arguments-of-partially-generic-type" title="Permalink to this headline">¶</a></h3>
<p>The generic type for a formal argument may be specified with some
queries or generic types and some concrete types or values. Using
concrete types or values in this manner makes the argument <em>partially
concrete</em> for the purpose of function resolution.</p>
<blockquote>
<div><p><em>Example (nested-type-queries.chpl)</em>.</p>
<p>Given the code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">elementType</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">indexType</span><span class="p">;</span>
  <span class="kd">type</span> <span class="nx">containerType</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">containedType</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(</span><span class="kt">real</span><span class="p">,?</span><span class="nx">t</span><span class="p">,?</span><span class="nx">u</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">f</span></code> can only apply when the <code class="docutils literal notranslate"><span class="pre">c.elementType==real</span></code>.</p>
<p>It’s also possible to use a generic type as an argument to <code class="docutils literal notranslate"><span class="pre">C</span></code>. The
following function, <code class="docutils literal notranslate"><span class="pre">g</span></code>, can only apply when <code class="docutils literal notranslate"><span class="pre">c.containerType</span></code> is
an instance of <code class="docutils literal notranslate"><span class="pre">Container</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span> <span class="nx">C</span><span class="p">(?</span><span class="nx">t</span><span class="p">,?</span><span class="nx">u</span><span class="p">,</span><span class="nx">Container</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Similarly, a tuple type with query arguments forms a <em>partially
concrete</em> argument.</p>
<blockquote>
<div><p><em>Example</em>.</p>
<p>The function definition</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?</span><span class="nx">t</span><span class="p">,</span><span class="kt">real</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// body</span>
<span class="p">}</span>
</pre></div>
</div>
<p>specifies that <code class="docutils literal notranslate"><span class="pre">tuple.size</span> <span class="pre">==</span> <span class="pre">2</span> <span class="pre">&amp;&amp;</span> <span class="pre">tuple(2).type</span> <span class="pre">==</span> <span class="pre">real</span></code>.</p>
</div></blockquote>
<p>Homogeneous tuple arguments of generic type are also supported:</p>
<blockquote>
<div><p><em>Example (partially-concrete-star-tuple.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Number</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="nx">Number</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>specifies that <code class="docutils literal notranslate"><span class="pre">f</span></code> accepts a tuple with 2 elements, where each
element has the same type, and that type is instantiation of
<code class="docutils literal notranslate"><span class="pre">Number</span></code>.</p>
</div></blockquote>
<p>Note that specifying a tuple consisting entirely of queried types does
create a <em>partially concrete argument</em> because the size of the tuple is
constrained.</p>
<blockquote>
<div><p><em>Example (partially-concrete-tuple-ambiguity.chpl)</em>.</p>
<p>The following program results in an ambiguity error:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?,</span><span class="kt">real</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">tuple</span><span class="p">:</span> <span class="p">(?,?))</span> <span class="p">{</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">(</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>since the <code class="docutils literal notranslate"><span class="pre">tuple</span></code> arguments in both versions of <code class="docutils literal notranslate"><span class="pre">f</span></code> are
<em>partially concrete</em>.</p>
</div></blockquote>
</div>
<div class="section" id="formal-arguments-of-generic-array-types">
<span id="id8"></span><h3>Formal Arguments of Generic Array Types<a class="headerlink" href="#formal-arguments-of-generic-array-types" title="Permalink to this headline">¶</a></h3>
<p>If the type of a formal argument is an array where either the domain or
the element type is queried or omitted, the type of the formal argument
is taken to be the type of the actual argument passed to the function at
the call site. If the domain is omitted, the domain of the formal
argument is taken to be the domain of the actual argument.</p>
<p>A queried domain may not be modified via the name to which it is bound
(see <a class="reference internal" href="arrays.html#association-of-arrays-to-domains"><span class="std std-ref">Association of Arrays to Domains</span></a> for rationale).</p>
</div>
</div>
<div class="section" id="function-visibility-in-generic-functions">
<span id="id9"></span><h2>Function Visibility in Generic Functions<a class="headerlink" href="#function-visibility-in-generic-functions" title="Permalink to this headline">¶</a></h2>
<p>When resolving a function call, as defined in <a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>,
there is an additional source of visible functions when the call is
nested within a generic function. The additional source is the functions
visible from the call site that the enclosing generic function is invoked from.
This call site is referred to as the <em>point of instantiation</em>.
If there are multiple enclosing generic functions or the call is nested
within a concrete function that is, in turn, nested in generic function(s),
the point of instantiation is the call site of the innermost generic function.</p>
<p>If no candidate functions are found during the initial steps of
identifying visible and candidate functions, function resolution
continues the search for visible and candidate functions
at the point of instantiation. If still no candidates are found,
the search continues to the point of instantiation of the innermost
generic function that contains the previous point of instantiation.
Once candidate(s) are found, the search succeeds and
function resolution proceeds to selecting the most specific functions.
Otherwise the search will reach a point of instantiation that is not
within a generic function. For example, it can be at the module level or
enclosed in only concrete function(s). If no candidates have been found,
the compiler issues a “call cannot be resolved” error.</p>
<blockquote>
<div><p><em>Example (point-of-instantiation.chpl)</em>.</p>
<p>Consider the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">LibraryA</span> <span class="p">{</span>
  <span class="k">proc</span> <span class="nf">callWorkers</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">worker1</span><span class="p">();</span>
    <span class="nx">worker2</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">LibraryB</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">LibraryA</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">worker1</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in LibraryB&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">libFun</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callWorkers</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">module</span> <span class="nc">Application</span> <span class="p">{</span>
  <span class="k">use</span> <span class="nx">LibraryB</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">worker1</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in Application&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">worker2</span><span class="p">()</span> <span class="p">{</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in Application&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">libFun</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When resolving the call to <code class="docutils literal notranslate"><span class="pre">worker1</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>
there are no visible functions at the scope of the call. Since
<code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code> is a generic function, resolution looks at
its point of instantiation, which is its call within <code class="docutils literal notranslate"><span class="pre">libFun()</span></code>.
There, a single candidate function for <code class="docutils literal notranslate"><span class="pre">worker1</span></code> is found, so
function resolution determines that this is the target function.</p>
<p>Since the search is complete, no further points of instantiation
are visited. Therefore <code class="docutils literal notranslate"><span class="pre">LibraryB</span></code> is assured that whenever
<code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code> looks to its callers for <code class="docutils literal notranslate"><span class="pre">worker1</span></code>,
the implementation in <code class="docutils literal notranslate"><span class="pre">LibraryB</span></code> will be used.
Other overloads, such <code class="docutils literal notranslate"><span class="pre">worker1()</span></code> in module <code class="docutils literal notranslate"><span class="pre">Application</span></code>,
will not be considered.</p>
<p>When resolving the call to <code class="docutils literal notranslate"><span class="pre">worker2</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>,
resolution again looks at its point of instantiation, namely
its call within <code class="docutils literal notranslate"><span class="pre">libFun()</span></code>. No visible functions can be found
there. Since <code class="docutils literal notranslate"><span class="pre">libFun</span></code> is also a generic function, the search
continues in turn to its point of instantiation, which is
its call in module <code class="docutils literal notranslate"><span class="pre">Application</span></code>. Since a definition of <code class="docutils literal notranslate"><span class="pre">worker2</span></code>
is visible there, it will be considered the candidate for the call
to <code class="docutils literal notranslate"><span class="pre">worker2</span></code> in <code class="docutils literal notranslate"><span class="pre">callWorkers()</span></code>.</p>
</div></blockquote>
<p>If the generic function is only called indirectly through dynamic
dispatch, the point of instantiation is defined as the point at which
the derived type (the type of the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument) is defined
or instantiated (if the derived type is generic).</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>Visible function lookup in Chapel’s generic functions is handled
differently than in C++’s template functions in that there is no
split between dependent and independent types.</p>
<p>Also, dynamic dispatch and instantiation is handled differently.
Chapel supports dynamic dispatch over methods that are generic in
some of its formal arguments.</p>
<p>Note that the Chapel lookup mechanism is still under development and
discussion. Comments or questions are appreciated.</p>
</div></blockquote>
</div>
<div class="section" id="generic-types">
<span id="id10"></span><h2>Generic Types<a class="headerlink" href="#generic-types" title="Permalink to this headline">¶</a></h2>
<p>Generic types comprise built-in generic types, generic classes, and
generic records.</p>
<div class="section" id="built-in-generic-types">
<span id="id11"></span><h3>Built-in Generic Types<a class="headerlink" href="#built-in-generic-types" title="Permalink to this headline">¶</a></h3>
<p>The types <code class="docutils literal notranslate"><span class="pre">integral</span></code>, <code class="docutils literal notranslate"><span class="pre">numeric</span></code> and <code class="docutils literal notranslate"><span class="pre">enum</span></code> are generic types that
can only be instantiated with, respectively, the signed and unsigned
integral types, all of the numeric types, and all enumerated types. The
type <code class="docutils literal notranslate"><span class="pre">enumerated</span></code> is currently available as a synonym for <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">record</span></code> can be instantiated with any record type.</p>
<p>The memory management strategies <code class="docutils literal notranslate"><span class="pre">owned</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>,
and <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> (see <a class="reference internal" href="classes.html#class-types"><span class="std std-ref">Class Types</span></a>) are also generic
types that can be instantiated with any class using that memory
management strategy. These types indicate generic nilability.</p>
<p>The types <code class="docutils literal notranslate"><span class="pre">class</span></code> and <code class="docutils literal notranslate"><span class="pre">class?</span></code>, on their own or in combination with
memory management strategies, are also generic types. They can be
instantiated as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code> can instantiate with any non-nilable class using any memory
management strategy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class?</span></code> can instantiate with any class using any memory management
strategy but will use the nilable variant of that class in an
instantiation. When used as an argument type, a value of non-nilable
class type will be implicitly converted to the nilable type on the
call. As a result, a formal of type <code class="docutils literal notranslate"><span class="pre">class?</span></code> can accept an actual
of any class type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span></code> can instantiate with any <code class="docutils literal notranslate"><span class="pre">owned</span></code> class - taking the
nilability from whatever it instantiated from.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">class</span></code> can instantiate with any non-nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code> class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">class?</span></code> can instantiate from any nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code> class. As
with <code class="docutils literal notranslate"><span class="pre">class?</span></code>, it can also instantiate from a non-nilable <code class="docutils literal notranslate"><span class="pre">owned</span></code>
class, in which case a implicit conversion would occur in a call.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">class?</span></code> behave similarly to
the above but with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management strategy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">class?</span></code> behave
similarly to the above but with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management strategy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">class?</span></code> behave
similarly to the above but with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> management strategy.</p></li>
</ul>
</div>
<div class="section" id="generic-classes-and-records">
<h3>Generic Classes and Records<a class="headerlink" href="#generic-classes-and-records" title="Permalink to this headline">¶</a></h3>
<p>The remainder of this section <a class="reference internal" href="#generic-types"><span class="std std-ref">Generic Types</span></a> specifies
generic class and record types that are not built-in types
(<a class="reference internal" href="#built-in-generic-types"><span class="std std-ref">Built-in Generic Types</span></a>).</p>
<p>A class or record is generic if it contains one or more generic fields.
A generic field is one of:</p>
<ul class="simple">
<li><p>a specified or unspecified type alias,</p></li>
<li><p>a parameter field, or</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field that has no type and no initialization
expression.</p></li>
</ul>
<p>For each generic field, the class or record is parameterized over:</p>
<ul class="simple">
<li><p>the type bound to the type alias,</p></li>
<li><p>the value of the parameter field, or</p></li>
<li><p>the type of the <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field, respectively.</p></li>
</ul>
<p>Correspondingly, the class or record is instantiated with a set of types
and parameter values, one type or value per generic field.</p>
</div>
<div class="section" id="type-aliases-in-generic-types">
<span id="id12"></span><h3>Type Aliases in Generic Types<a class="headerlink" href="#type-aliases-in-generic-types" title="Permalink to this headline">¶</a></h3>
<p>If a class or record defines a type alias, the class or record is
generic over the type that is bound to that alias. Such a type alias is
accessed as if it were a field from either a class or record instance or
from the instantiated class or record type itself. Similar to a
parameter field, it cannot be assigned except in its declaration.</p>
<p>The type alias becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">type</span></code> to the
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Initializer</span></a>) for its class
or record. This makes the compiler-generated initializer generic. The
type alias also becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">type</span></code> to the type
constructor (<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). If the type alias
declaration binds it to a type, that type becomes the default for these
arguments, otherwise they have no defaults.</p>
<p>The class or record is instantiated by binding the type alias to the
actual type passed to the corresponding argument of a user-defined
(<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or compiler-generated
initializer or type constructor. If that argument has a default, the
actual type can be omitted, in which case the default will be used
instead.</p>
<blockquote>
<div><p><em>Example (NodeClass.chpl)</em>.</p>
<p>The following code defines a class called <code class="docutils literal notranslate"><span class="pre">Node</span></code> that implements a
linked list data structure. It is generic over the type of the
element contained in the linked list.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">eltType</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">eltType</span><span class="p">)?;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Node(real,</span> <span class="pre">3.14)</span></code> creates a node in the linked list
that contains the value <code class="docutils literal notranslate"><span class="pre">3.14</span></code>. The <code class="docutils literal notranslate"><span class="pre">next</span></code> field is set to nil.
The type specifier <code class="docutils literal notranslate"><span class="pre">Node</span></code> is a generic type and cannot be used to
define a variable. The type specifier <code class="docutils literal notranslate"><span class="pre">Node(real)</span></code> denotes the type
of the <code class="docutils literal notranslate"><span class="pre">Node</span></code> class instantiated over <code class="docutils literal notranslate"><span class="pre">real</span></code>. Note that the type
of the <code class="docutils literal notranslate"><span class="pre">next</span></code> field is specified as <code class="docutils literal notranslate"><span class="pre">Node(eltType)</span></code>; the type of
<code class="docutils literal notranslate"><span class="pre">next</span></code> is the same type as the type of the object that it is a
field of.</p>
</div></blockquote>
</div>
<div class="section" id="parameters-in-generic-types">
<span id="id13"></span><h3>Parameters in Generic Types<a class="headerlink" href="#parameters-in-generic-types" title="Permalink to this headline">¶</a></h3>
<p>If a class or record defines a parameter field, the class or record is
generic over the value that is bound to that field. The field can be
accessed from a class or record instance or from the instantiated class
or record type itself.</p>
<p>The parameter becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">param</span></code> to the
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Initializer</span></a>) for that class
or record. This makes the compiler-generated initializer generic. The
parameter also becomes an argument with intent <code class="docutils literal notranslate"><span class="pre">param</span></code> to the type
constructor (<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). If the parameter
declaration has an initialization expression, that expression becomes
the default for these arguments, otherwise they have no defaults.</p>
<p>The class or record is instantiated by binding the parameter to the
actual value passed to the corresponding argument of a user-defined
(<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or compiler-generated
initializer or type constructor. If that argument has a default, the
actual value can be omitted, in which case the default will be used
instead.</p>
<blockquote>
<div><p><em>Example (IntegerTuple.chpl)</em>.</p>
<p>The following code defines a class called <code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> that is
generic over an integer parameter which defines the number of
components in the class.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntegerTuple</span> <span class="p">{</span>
  <span class="kd">param</span> <span class="nx">size</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">size</span><span class="o">*</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">IntegerTuple(3)</span></code> creates an instance of the
<code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> class that is instantiated over parameter <code class="docutils literal notranslate"><span class="pre">3</span></code>. The
field <code class="docutils literal notranslate"><span class="pre">data</span></code> becomes a 3-tuple of integers. The type of this class
instance is <code class="docutils literal notranslate"><span class="pre">IntegerTuple(3)</span></code>. The type specified by
<code class="docutils literal notranslate"><span class="pre">IntegerTuple</span></code> is a generic type.</p>
</div></blockquote>
</div>
<div class="section" id="fields-without-types">
<span id="id14"></span><h3>Fields without Types<a class="headerlink" href="#fields-without-types" title="Permalink to this headline">¶</a></h3>
<p>If a <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field in a class or record has no specified
type or initialization expression, the class or record is generic over
the type of that field. The field becomes an argument with default
intent to the compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Initializer</span></a>). That argument
has no specified type and no default value. This makes the
compiler-generated initializer generic. The field also becomes an
argument with <code class="docutils literal notranslate"><span class="pre">type</span></code> intent and no default to the type constructor
(<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). Correspondingly, an actual value
must always be passed to the default initializer argument and an actual
type to the type constructor argument.</p>
<p>The class or record is instantiated by binding the type of the field to
the type of the value passed to the corresponding argument of a
user-defined (<a class="reference internal" href="#generic-user-initializers"><span class="std std-ref">User-Defined Initializers</span></a>) or
compiler-generated initializer
(<a class="reference internal" href="#generic-compiler-generated-initializers"><span class="std std-ref">The Compiler-Generated Initializer</span></a>). When the type
constructor is invoked, the class or record is instantiated by binding
the type of the field to the actual type passed to the corresponding
argument.</p>
<blockquote>
<div><p><em>Example (fieldWithoutType.chpl)</em>.</p>
<p>The following code defines another class called <code class="docutils literal notranslate"><span class="pre">Node</span></code> that
implements a linked list data structure. It is generic over the type
of the element contained in the linked list. This code does not
specify the element type directly in the class as a type alias but
rather omits the type from the <code class="docutils literal notranslate"><span class="pre">data</span></code> field.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="kd">type</span><span class="p">)?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A node with integer element type can be defined in the call to the
initializer. The call <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Node(1)</span></code> defines a node with the value
<code class="docutils literal notranslate"><span class="pre">1</span></code>. The code</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>defines a two-element list with nodes containing the values <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">2</span></code>. The type of each object could be specified as <code class="docutils literal notranslate"><span class="pre">Node(int)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="the-type-constructor">
<span id="type-constructors"></span><h3>The Type Constructor<a class="headerlink" href="#the-type-constructor" title="Permalink to this headline">¶</a></h3>
<p>A type constructor is automatically created for each class or record. A
type constructor is a type function (<a class="reference internal" href="procedures.html#type-return-intent"><span class="std std-ref">The Type Return Intent</span></a>)
that has the same name as the class or record. It takes one argument per
the class’s or record’s generic field, including fields inherited from
the superclasses, if any. The formal argument has intent <code class="docutils literal notranslate"><span class="pre">type</span></code> for a
type alias field and is a parameter for a parameter field. It accepts
the type to be bound to the type alias and the value to be bound to the
parameter, respectively. For a generic <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span></code> field, the
corresponding formal argument also has intent <code class="docutils literal notranslate"><span class="pre">type</span></code>. It accepts the
type of the field, as opposed to a value as is the case for a parameter
field. The formal arguments occur in the same order as the fields are
declared and have the same names as the corresponding fields. Unlike the
compiler-generated initializer, the type constructor has only those
arguments that correspond to generic fields.</p>
<p>A call to a type constructor accepts actual types and parameter values
and returns the type of the class or record that is instantiated
appropriately for each field
(<a class="reference internal" href="#type-aliases-in-generic-types"><span class="std std-ref">Type Aliases in Generic Types</span></a>,
<a class="reference internal" href="#parameters-in-generic-types"><span class="std std-ref">Parameters in Generic Types</span></a>,
<a class="reference internal" href="#fields-without-types"><span class="std std-ref">Fields without Types</span></a>). Such an instantiated type must
be used as the type of a variable, array element, non-generic formal
argument, and in other cases where uninstantiated generic class or
record types are not allowed.</p>
<p>When a generic field declaration has an initialization expression or a
type alias is specified, that initializer becomes the default value for
the corresponding type constructor argument. Uninitialized fields,
including all generic <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span></code> fields, and unspecified type
aliases result in arguments with no defaults; actual types or values for
these arguments must always be provided when invoking the type
constructor.</p>
</div>
<div class="section" id="generic-methods">
<span id="id15"></span><h3>Generic Methods<a class="headerlink" href="#generic-methods" title="Permalink to this headline">¶</a></h3>
<p>All methods bound to generic classes or records, including initializers,
are generic over the implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> argument. This is in addition to
being generic over any other argument that is generic.</p>
</div>
<div class="section" id="the-compiler-generated-initializer">
<span id="generic-compiler-generated-initializers"></span><h3>The Compiler-Generated Initializer<a class="headerlink" href="#the-compiler-generated-initializer" title="Permalink to this headline">¶</a></h3>
<p>If no user-defined initializers are supplied for a given generic class,
the compiler generates one in a manner similar to that for
concrete classes (<a class="reference internal" href="classes.html#the-compiler-generated-initializer"><span class="std std-ref">The Compiler-Generated Initializer</span></a>).
However, the compiler-generated initializer for a generic class or
record (<a class="reference internal" href="classes.html#the-compiler-generated-initializer"><span class="std std-ref">The Compiler-Generated Initializer</span></a>) is generic
over each argument that corresponds to a generic field, as specified
above.</p>
<p>The argument has intent <code class="docutils literal notranslate"><span class="pre">type</span></code> for a type alias field and has intent
<code class="docutils literal notranslate"><span class="pre">param</span></code> for a parameter field. It accepts the type to be bound to the
type alias and the value to be bound to the parameter, respectively.
This is the same as for the type constructor. For a generic <code class="docutils literal notranslate"><span class="pre">var</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span></code> field, the corresponding formal argument has the default
intent and accepts the value for the field to be initialized with. The
type of the field is inferred automatically to be the type of the
initialization value.</p>
<p>The default values for the generic arguments of the compiler-generated
initializer are the same as for the type constructor
(<a class="reference internal" href="#type-constructors"><span class="std std-ref">The Type Constructor</span></a>). For example, the arguments
corresponding to the generic <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span></code> fields, if any, never
have defaults, so the corresponding actual values must always be
provided.</p>
</div>
<div class="section" id="user-defined-initializers">
<span id="generic-user-initializers"></span><h3>User-Defined Initializers<a class="headerlink" href="#user-defined-initializers" title="Permalink to this headline">¶</a></h3>
<p>If a generic field of a class or record does not have a default value or
type alias, each user-defined initializer for that class must explicitly
initialize that field. In the event that the initializer is called using
an already instantiated type as the receiver, the class or record
instance created by the initializer must have that same instantiated
type.</p>
<blockquote>
<div><p><em>Example (initializersForGenericFields.chpl)</em>.</p>
<p>In the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyGenericClass</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">t1</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">p1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">c1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x1</span><span class="p">:</span> <span class="nx">t1</span><span class="p">;</span> <span class="c1">// this field is not generic</span>

  <span class="kd">type</span> <span class="nx">t5</span> <span class="o">=</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">param</span> <span class="nx">p5</span> <span class="o">=</span> <span class="s">&quot;a string&quot;</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">c5</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v5</span> <span class="o">=</span> <span class="mi">555</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x5</span><span class="p">:</span> <span class="nx">t5</span><span class="p">;</span> <span class="c1">// this field is not generic</span>

  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">t1</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v1</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
    <span class="c1">// compiler inserts initialization for remaining fields</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t5</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p5</span><span class="p">,</span> <span class="nx">c5</span><span class="p">,</span> <span class="nx">v5</span><span class="p">,</span> <span class="nx">x5</span><span class="p">,</span>
            <span class="kd">type</span> <span class="nx">t1</span><span class="p">,</span> <span class="kd">param</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">c1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v1</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x1</span> <span class="o">=</span> <span class="nx">x1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t5</span> <span class="o">=</span> <span class="nx">t5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p5</span> <span class="o">=</span> <span class="nx">p5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c5</span> <span class="o">=</span> <span class="nx">c5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">v5</span> <span class="o">=</span> <span class="nx">v5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x5</span> <span class="o">=</span> <span class="nx">x5</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// class MyGenericClass</span>

<span class="kd">var</span> <span class="nx">g1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyGenericClass</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">g2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyGenericClass</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="s">&quot;this is g2&quot;</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mi">333</span><span class="p">,</span> <span class="mi">3333</span><span class="p">,</span>
                            <span class="kt">real</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">222</span><span class="p">,</span> <span class="mf">222.2</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
</pre></div>
</div>
<p>The initializers are required to initialize fields <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>,
<code class="docutils literal notranslate"><span class="pre">c1</span></code>, and <code class="docutils literal notranslate"><span class="pre">v1</span></code>. Otherwise, field initializations may be omitted
according to previously-described initializer semantics.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="user-defined-compiler-diagnostics">
<span id="user-defined-compiler-errors"></span><h2>User-Defined Compiler Diagnostics<a class="headerlink" href="#user-defined-compiler-diagnostics" title="Permalink to this headline">¶</a></h2>
<p>The special compiler diagnostic function calls <code class="docutils literal notranslate"><span class="pre">compilerError</span></code> and
<code class="docutils literal notranslate"><span class="pre">compilerWarning</span></code> generate compiler diagnostic of the indicated
severity if the function containing these calls may be called when the
program is executed and the function call is not eliminated by parameter
folding.</p>
<p>The compiler diagnostic is defined by the actual arguments which must be
string parameters. The diagnostic points to the spot in the Chapel
program from which the function containing the call is called.
Compilation halts if a <code class="docutils literal notranslate"><span class="pre">compilerError</span></code> is encountered whereas it will
continue after encountering a <code class="docutils literal notranslate"><span class="pre">compilerWarning</span></code>.</p>
<blockquote>
<div><p><em>Example (compilerDiagnostics.chpl)</em>.</p>
<p>The following code shows an example of using user-defined compiler
diagnostics to generate warnings and errors:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="k">then</span>
    <span class="nx">compilerError</span><span class="p">(</span><span class="s">&quot;foo() called with non-matching types: &quot;</span><span class="p">,</span>
                  <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">,</span> <span class="s">&quot; != &quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In 2-argument foo...&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">compilerWarning</span><span class="p">(</span><span class="s">&quot;1-argument version of foo called with type: &quot;</span><span class="p">,</span>
                  <span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In generic foo!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first routine generates a compiler error whenever the compiler
encounters a call to it where the two arguments have different types.
It prints out an error message indicating the types of the arguments.
The second routine generates a compiler warning whenever the compiler
encounters a call to it.</p>
<p>Thus, if the program foo.chpl contained the following calls:</p>
<div class="highlight-chapel notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nx">foo</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="s">&quot;bye&quot;</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>compiling the program would generate output like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>foo.chpl:1: warning: <span class="m">1</span>-argument version of foo called with type: real<span class="o">(</span><span class="m">64</span><span class="o">)</span>
foo.chpl:2: warning: <span class="m">1</span>-argument version of foo called with type: string
foo.chpl:6: error: foo<span class="o">()</span> called with non-matching types: int<span class="o">(</span><span class="m">64</span><span class="o">)</span> !<span class="o">=</span> real<span class="o">(</span><span class="m">64</span><span class="o">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="creating-general-and-specialized-versions-of-a-function">
<span id="id16"></span><h2>Creating General and Specialized Versions of a Function<a class="headerlink" href="#creating-general-and-specialized-versions-of-a-function" title="Permalink to this headline">¶</a></h2>
<p>The Chapel language facility supports three mechanisms for using generic
functions along with concrete functions. These mechanisms allow users to
create a general generic implementation and also a special
implementation for specific concrete types.</p>
<p>The first mechanism applies to functions. According to the function
resolution rules described in <a class="reference internal" href="procedures.html#function-resolution"><span class="std std-ref">Function Resolution</span></a>,
functions accepting concrete arguments are selected in preference to
those with a totally generic argument. So, creating a second version of
a generic function that declares a concrete type will cause the concrete
function to be used where possible:</p>
<blockquote>
<div><p><em>Example (specializeGenericFunction.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in generic foo(x)&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in specific foo(x:int)&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myReal</span><span class="p">:</span><span class="kt">real</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">myReal</span><span class="p">);</span> <span class="c1">// outputs &quot;in generic foo(x)&quot;</span>
<span class="kd">var</span> <span class="nx">myInt</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="nx">myInt</span><span class="p">);</span> <span class="c1">// outputs &quot;in specific foo(x:int)&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>This program will run the generic foo function if the argument is a
real, but it runs the specific version for int if the argument is an
int.</p>
<p>The second mechanism applies when working with methods on generic types.
When declaring a secondary method, the receiver type can be a
parenthesized expression. In that case, the compiler will evaluate the
parenthesized expression at compile time in order to find the concrete
receiver type. Then, the resolution rules described above will cause the
concrete method to be selected when applicable. For example:</p>
<blockquote>
<div><p><em>Example (specializeGenericMethod.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">MyNode</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">field</span><span class="p">;</span>  <span class="c1">// since no type is specified here, MyNode is a generic type</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">MyNode.foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in generic MyNode.foo()&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="p">(</span><span class="nx">MyNode</span><span class="p">(</span><span class="kt">int</span><span class="p">)).</span><span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;in specific MyNode(int).foo()&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myRealNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyNode</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="nx">myRealNode</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// outputs &quot;in generic MyNode.foo()&quot;</span>
<span class="kd">var</span> <span class="nx">myIntNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">myIntNode</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// outputs &quot;in specific MyNode(int).foo()&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>The third mechanism is to use a where clause. Where clauses limit a
generic method to particular cases. Unlike the previous two cases, a
where clause can be used to declare special implementation of a function
that works with some set of types - in other words, the special
implementation can still be a generic function. See also
<a class="reference internal" href="procedures.html#where-clauses"><span class="std std-ref">Where Clauses</span></a>.</p>
</div>
<div class="section" id="example-a-generic-stack">
<span id="example-generic-stack"></span><h2>Example: A Generic Stack<a class="headerlink" href="#example-a-generic-stack" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><em>Example (genericStack.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNode</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>              <span class="c1">// type of item</span>
  <span class="kd">var</span> <span class="nx">item</span><span class="p">:</span> <span class="nx">itemType</span><span class="p">;</span>         <span class="c1">// item in node</span>
  <span class="kd">var</span> <span class="nx">next</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">)?;</span> <span class="c1">// reference to next node (same type)</span>
<span class="p">}</span>

<span class="k">record</span> <span class="nc">Stack</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">itemType</span><span class="p">;</span>             <span class="c1">// type of items</span>
  <span class="kd">var</span> <span class="nx">top</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">)?;</span> <span class="c1">// top node on stack linked list</span>

  <span class="k">proc</span> <span class="nf">push</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">itemType</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">top</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">MyNode</span><span class="p">(</span><span class="nx">itemType</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">top</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">isEmpty</span> <span class="k">then</span>
      <span class="nx">halt</span><span class="p">(</span><span class="s">&quot;attempt to pop an item off an empty stack&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">oldTop</span> <span class="o">=</span> <span class="nx">top</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">oldItem</span> <span class="o">=</span> <span class="nx">top</span><span class="o">!</span><span class="p">.</span><span class="nx">item</span><span class="p">;</span>
    <span class="nx">top</span> <span class="o">=</span> <span class="nx">top</span><span class="o">!</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="nx">oldTop</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">oldItem</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">isEmpty</span> <span class="k">return</span> <span class="nx">top</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="input-and-output.html" class="btn btn-neutral float-right" title="Input and Output" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="iterators.html" class="btn btn-neutral float-left" title="Iterators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>