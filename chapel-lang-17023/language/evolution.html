

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapel Evolution &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Documentation Archives" href="archivedSpecs.html" />
    <link rel="prev" title="on-clauses: controlling locality/affinity" href="../users-guide/locality/onClauses.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "language/evolution";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapel Evolution</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#version-1-22-april-2020">version 1.22, April 2020</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vs-1-based-indexing">0- vs. 1-based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rationale-for-0-vs-1-based-indexing">Rationale for 0- vs. 1-based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-neutral-features">Index-neutral Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tips-for-updating-existing-chapel-code">Tips for Updating Existing Chapel code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#need-help">Need Help?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-21-april-2020">version 1.21, April 2020</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#split-initialization">split initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-elision">copy elision</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deinitialization-point-of-nested-call-expressions">deinitialization point of nested call expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-20-september-2019">version 1.20, September 2019</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nilability-changes">nilability changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nilability-and-casts">nilability and casts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-downcasts">class downcasts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#casting-c-pointers-to-classes">casting C pointers to classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#undecorated-classes-have-generic-management">undecorated classes have generic management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#new-default-intent-for-owned-and-shared">new default intent for owned and shared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#new-c-is-owned">new C is owned</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-18-september-2018">version 1.18, September 2018</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initializers-replace-constructors">initializers replace constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-memory-management">class memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overriding-methods-must-be-marked">overriding methods must be marked</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-15-april-2017">version 1.15, April 2017</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#array-lexical-scoping">array lexical scoping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-alias-operator-deprecated">array alias operator deprecated</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays-return-by-value-by-default">arrays return by value by default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-default-intent">array default intent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#record-this-default-intent">record <cite>this</cite> default intent</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-13-april-2016">version 1.13, April 2016</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ref-return-intent">ref return intent</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-12-october-2015">version 1.12, October 2015</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lexical-scoping">lexical scoping</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-11-april-2015">version 1.11, April 2015</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#forall-intents">forall intents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-select-statement">type select statement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-10-october-2014">version 1.10, October 2014</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#task-intents-syntax">task intents syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#var-function-return-intents-changed-to-ref">‘var’ function return intents changed to ‘ref’</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-9-april-2014">version 1.9, April 2014</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-precedence-changes-to-benefit-common-cases">operator precedence changes to benefit common cases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#improved-interpretation-of-d">improved interpretation of {D}</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-8-october-2013">version 1.8, October 2013</a></li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-6-october-2012">version 1.6, October 2012</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#domain-literals">domain literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zippered-iteration">zippered iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ignoring-tuple-components-underscore">ignoring tuple components/underscore</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-1-4-october-2011">version 1.4, October 2011</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-declaration-keywords">function declaration keywords</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Chapel Evolution</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/language/evolution.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapel-evolution">
<span id="id1"></span><h1>Chapel Evolution<a class="headerlink" href="#chapel-evolution" title="Permalink to this headline">¶</a></h1>
<p>Like any language, Chapel has changed over time. This page is designed
to describe significant language changes that have a high likelihood
of breaking existing user codes or code samples from presentations or
papers that predated the changes.</p>
<p>Note that the compiler flag <code class="docutils literal notranslate"><span class="pre">--warn-unstable</span></code> is available and can be
useful when migrating programs to the current version of the language.
The purpose of this flag is to identify portions of a program that use a
language feature which has changed meaning.  It also flags features that
are considered unstable and may change in the future.</p>
<div class="section" id="version-1-22-april-2020">
<h2>version 1.22, April 2020<a class="headerlink" href="#version-1-22-april-2020" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vs-1-based-indexing">
<h3>0- vs. 1-based Indexing<a class="headerlink" href="#vs-1-based-indexing" title="Permalink to this headline">¶</a></h3>
<p>Version 1.22 makes a major breaking change to Chapel with respect to
indexing for cases that involve implicit indices.  Historically,
Chapel has used 1-based indexing for such cases, where it now uses
0-based indexing.</p>
<p>The major types that are affected by this change are tuples, strings,
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>, and lists.  In addition, arrays that don’t have a
well-defined index set also start at 0.  Such cases include array
literals or inferred-type arrays formed by capturing a general
iterator expression.</p>
<p>This change also has a ripple-down effect to features and routines
related to these types.  For example, varargs arguments are equivalent
to tuples in Chapel, so inherit their 0-based indexing.  Similarly,
queries on rectangular domains and arrays are based on tuples,
so their dimensions are now numbered from 0 as well.
Certain library routines such as <code class="docutils literal notranslate"><span class="pre">find()</span></code> on strings used to return 0
when no match was found, but now return -1 in order to avoid returning
a legal string index.</p>
<p>The following sections summarize the rationale for this change and
then provide some tips for updating existing Chapel code.</p>
</div>
<div class="section" id="rationale-for-0-vs-1-based-indexing">
<h3>Rationale for 0- vs. 1-based Indexing<a class="headerlink" href="#rationale-for-0-vs-1-based-indexing" title="Permalink to this headline">¶</a></h3>
<p>In the original design of Chapel, we hoped to make the language as
neutral to 1- vs. 0-based indexing as possible, to avoid running afoul
of the strong emotions that such choices evoke in users when it
doesn’t match their preference.  As a result, Chapel’s primary types
for parallel computation on regular collections of data—namely, its
ranges and rectangular domains, as well as rectangular arrays defined
by ranges or domains—require users to specify both low and high
bounds.  Happily, these core features are not affected by this change
in Chapel 1.22, so codes relying solely on such features will not
require updates.</p>
<p>However, for other types such as tuples and strings, we were forced to
make a decision.  At the time of Chapel’s inception, the main
languages from which we were trying to attract users were C/C++, Java,
Fortran, and Matlab.  Since half of these languages used 0-based
indexing and the other half used 1-based, there didn’t seem to be an
obvious best answer.  In the end, we decided to go with 1-based
indexing on the argument that we were striving to create a productive
language, and that counting from 1 is arguably most natural for most
people.</p>
<p>Over time, however, the vast majority of newer languages that we look
to for users or inspiration—most notably Python, Swift, and Rust—have
been almost exclusively 0-based.  Meanwhile, very few notable new
languages have used 1-based indexing.</p>
<p>Furthermore, when polled, the vast majority of active Chapel users
expressed a strong preference for 0-based programming, given the
choice (though there were also notable outliers, particularly from the
Fortran community).  We also realized (a) that Chapel’s design should
be more concerned with lowering barriers for existing programmers than
for non-programmers; and (b) that even though we had arguably biased
the original design in favor of Fortran programmers, most of Chapel’s
early adopters have come from C/C++ and Python backgrounds.</p>
<p>Based on this, we undertook an experiment to see what it would take to
convert from 1-based to 0-based programming.  Reviewing Chapel’s
~10,000 tests and modules resulted in changes to ~1,000 of them.  We
also updated some significant applications such as Arkouda and Cray
HPO.  While the overall effort of making the change was not
insignificant, it also wasn’t particularly difficult for the most
part.  Overall, our finding was that in cases where the changes
weren’t simply neutral in their impact on style, it almost always
benefitted the code in terms of clarity, because there tended to
be fewer adjustments of +/- 1 in the code.</p>
<p>For these reasons, we decided to bite the bullet and make the switch
now, while we felt we still could, rather than later when it would
clearly be too late to do so and cause more of a revolt among our
users.</p>
</div>
<div class="section" id="index-neutral-features">
<h3>Index-neutral Features<a class="headerlink" href="#index-neutral-features" title="Permalink to this headline">¶</a></h3>
<p>This experience also led to a number of new programming features in
Chapel 1.21 designed to help write code in more of an index-neutral
style.  Chief among these are new <code class="docutils literal notranslate"><span class="pre">.indices</span></code> queries on most of the
relevant types as well as support for loops over heterogeneous tuples.
We also introduced features that we found to be useful in updating
code, such as support for open-interval ranges and <code class="docutils literal notranslate"><span class="pre">.first</span></code> and
<code class="docutils literal notranslate"><span class="pre">.last</span></code> queries on enumerated types.  To this end, even though Chapel
still has cases that require making this 0- vs. 1-based indexing
decision, we encourage code to be written in an index-neutral style
whenever possible, and believe that most common code patterns can be.</p>
</div>
<div class="section" id="tips-for-updating-existing-chapel-code">
<h3>Tips for Updating Existing Chapel code<a class="headerlink" href="#tips-for-updating-existing-chapel-code" title="Permalink to this headline">¶</a></h3>
<p>The following are some tips for updating codes based on our
experiences:</p>
<ul>
<li><p>First, updating code is easiest when it has some sort of testing
infrastructure that can be used to validate that its behavior is
unchanged.  If you don’t already have such testing for your code, it
may be worthwhile to invest in creating some before attempting this
upgrade.</p></li>
<li><p>Next, when transitioning code to Chapel 1.22, make sure to compile
it with neither <code class="docutils literal notranslate"><span class="pre">--fast</span></code> nor <code class="docutils literal notranslate"><span class="pre">--no-checks</span></code> enabled so that bounds
checks are turned on in the generated code.  In cases where a
program is accessing all of the elements of a collection (as is
common for tuples) this will help identify data structures that
require updates.  When you do get an out-of-bounds error, don’t
simply update the specific access, but use it as a cue to look
through the code for other references to that variable that will
also need updating.</p></li>
<li><p>When possible, try rewriting your updated code to use an
index-neutral style of programming.  For example, given code like
this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">2</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;t(&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="s">&quot;) = &quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</pre></div>
</div>
<p>It would be reasonable to rewrite it like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;t(&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="s">&quot;) = &quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</pre></div>
</div>
<p>But arguably preferable to update it like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="o">..</span><span class="p">.;</span>

<span class="kd">var</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=</span> <span class="nx">t</span><span class="p">;</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indices</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;t(&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="s">&quot;) = &quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</pre></div>
</div>
<p>If you have a pattern that you’re trying to write in an
index-neutral style, but can’t, don’t hesitate to <a class="reference external" href="https://chapel-lang.org/users.html">ask for tips</a>.</p>
</li>
<li><p>Some common pitfalls to check for in your code include:</p>
<ul class="simple">
<li><p>Search for queries on the dimensions of rectangular domains and
arrays.  For example, <code class="docutils literal notranslate"><span class="pre">myDomain.dim(1)</span></code>, <code class="docutils literal notranslate"><span class="pre">myDomain.low(1)</span></code>,
<code class="docutils literal notranslate"><span class="pre">myDomain.high(1)</span></code>, or <code class="docutils literal notranslate"><span class="pre">myDomain.stride(1)</span></code> will need to be
updated to reflect that array dimensions now count from 0 rather
than 1.  These will result in out-of-bounds errors in cases where
you query all dimensions of an array, making them easy to find;
but it can be worthwhile to grep your code for such patterns to
make sure you don’t miss any.</p></li>
<li><p>Also search for instances of <code class="docutils literal notranslate"><span class="pre">find()</span></code> or <code class="docutils literal notranslate"><span class="pre">rfind()</span></code> that are
relying on comparisons to zero/nonzero values, and update them to
compare against -1.  For example, patterns like <code class="docutils literal notranslate"><span class="pre">if</span>
<span class="pre">mystring.find('z')</span></code> need to be updated to <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">mystring.find('z')</span>
<span class="pre">!=</span> <span class="pre">-1</span></code>.</p></li>
<li><p>Search for instances of <code class="docutils literal notranslate"><span class="pre">split()</span></code>.  A common idiom is to write
<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">substrs</span> <span class="pre">=</span> <span class="pre">mystring.split(5);</span></code> and then to index into the
result using <code class="docutils literal notranslate"><span class="pre">substrs[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">substrs[2]</span></code>, etc.  Since this is
an instance of capturing an iterator expression, you’ll either
need to subtract one from the indices, or else declare <cite>substrs</cite>
to have a specific type, like <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">substrs:</span> <span class="pre">[1..5]</span> <span class="pre">string</span> <span class="pre">=</span>
<span class="pre">mystring.split(5);</span></code></p></li>
<li><p>Search for varargs functions and make sure they are updated to use
0-based indexing or index-neutral features.</p></li>
<li><p>Search for any calls to <code class="docutils literal notranslate"><span class="pre">Reflection.getField*()</span></code> and update
those the cases that use integer indices to reflect 0-based
numbering.</p></li>
<li><p>Look for any calls on lists that use explicit offsets, as these
will likely need updates.  For example <code class="docutils literal notranslate"><span class="pre">mylist.pop(1);</span></code> will
need to become <code class="docutils literal notranslate"><span class="pre">mylist.pop(0);</span></code></p></li>
<li><p>Some other common string patterns to look for in your code that
<cite>may</cite> indicate something requiring an update include:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[1]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[2]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(2)</span></code></p></li>
</ul>
</li>
<li><p>Think about whether there are other places in your code that
compute index values numerically yet which don’t have obvious
syntactic cues.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="need-help">
<h3>Need Help?<a class="headerlink" href="#need-help" title="Permalink to this headline">¶</a></h3>
<p>If you are able to share your code with us and would like help
updating it to Chapel 1.22, please don’t hesitate to <a class="reference external" href="https://chapel-lang.org/users.html">ask for help</a>.  Given our experience in
updating the Chapel code base itself, we have found it fairly easy to
update most codes, even when we’re unfamiliar with them.</p>
</div>
</div>
<div class="section" id="version-1-21-april-2020">
<h2>version 1.21, April 2020<a class="headerlink" href="#version-1-21-april-2020" title="Permalink to this headline">¶</a></h2>
<p>Version 1.21 made several improvements related to record initialization,
assignment, and deinitialization.</p>
<p>In summary:</p>
<blockquote>
<div><ul class="simple">
<li><p>Some patterns of default initialization followed by assignment are now
converted to initialization. See <a class="reference internal" href="#readme-evolution-split-init"><span class="std std-ref">split initialization</span></a>.</p></li>
<li><p>Some patterns of copy initialization followed by deinitialization are
converted to move initialization. See <a class="reference internal" href="#readme-evolution-copy-elision"><span class="std std-ref">copy elision</span></a>.</p></li>
<li><p>The result of a nested call expression can now be deinitialized at the end of
the containing statement. See <a class="reference internal" href="#readme-evolution-statement-deinit"><span class="std std-ref">deinitialization point of nested call expressions</span></a>.</p></li>
</ul>
</div></blockquote>
<div class="section" id="split-initialization">
<span id="readme-evolution-split-init"></span><h3>split initialization<a class="headerlink" href="#split-initialization" title="Permalink to this headline">¶</a></h3>
<p>Split initialization a new language feature in 1.21 that is described in
the language specification - see <a class="reference internal" href="spec/variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a>.</p>
<p>Consider the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">myRecord</span><span class="p">;</span>    <span class="c1">// default-initialization in 1.20</span>
<span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myRecord</span><span class="p">();</span> <span class="c1">// assignment in 1.20 -- initialization in 1.21</span>
</pre></div>
</div>
<p>In 1.21, instead of default-initializing <code class="docutils literal notranslate"><span class="pre">x</span></code> and then assigning to it,
<code class="docutils literal notranslate"><span class="pre">x</span></code> will be initialized on the second line.</p>
<p>Note that split initialization also changes the copy and assignment
behavior of <code class="docutils literal notranslate"><span class="pre">out</span></code> intent formal arguments.</p>
<p>Occasionally programs that are written to test assignment (separately
from copy initialization) need to avoid split initialization. One way to
do so is to add a mention of the variable immediately after it is
declared, as in the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">myRecord</span><span class="p">;</span>
<span class="nx">x</span><span class="p">;</span> <span class="c1">// adding this mention prevents split-initialization</span>
   <span class="c1">// instead, x is default-initialized at its declaration point above</span>
<span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myRecord</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="copy-elision">
<span id="readme-evolution-copy-elision"></span><h3>copy elision<a class="headerlink" href="#copy-elision" title="Permalink to this headline">¶</a></h3>
<p>Copy elision a new language feature in 1.21.
When the last mention of a variable is the source of a copy-initialization,
the copy-initialization is replaced by move-initialization.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">field</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="kd">in</span> <span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">field</span> <span class="o">=</span> <span class="nx">arg</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">copyElisionExample</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myRecord</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>             <span class="c1">// now move-initializes `b` from `a`</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// now move-initializes the field from `b`</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="deinitialization-point-of-nested-call-expressions">
<span id="readme-evolution-statement-deinit"></span><h3>deinitialization point of nested call expressions<a class="headerlink" href="#deinitialization-point-of-nested-call-expressions" title="Permalink to this headline">¶</a></h3>
<p>In 1.20, all variables are deinitialized at the end of the enclosing
block. That changed in 1.21. Compiler-introduced temporary
variables storing the result of a nested call expression can now be
deinitialized at the end of a statement. In particular, results of nested
call expressions are now deinitialized at the end of the statement unless the
statement is initializing a user variable.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">makeRecord</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">myRecord</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">deinitExample</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">makeRecord</span><span class="p">());</span>
  <span class="c1">// Compiler converts the above statement into</span>
  <span class="c1">//   var tmp = makeRecord();</span>
  <span class="c1">//   f(tmp);</span>
  <span class="c1">// In 1.20, tmp is destroyed at the end of the block.</span>
  <span class="c1">// In 1.21, tmp is destroyed at the end of the above statement.</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">makeRecord</span><span class="p">());</span>
  <span class="c1">// In both 1.20 and 1.21, the temporary storing the result of</span>
  <span class="c1">// `makeRecord()` is deinitialized at the end of the block.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="version-1-20-september-2019">
<h2>version 1.20, September 2019<a class="headerlink" href="#version-1-20-september-2019" title="Permalink to this headline">¶</a></h2>
<p>Version 1.20 made language changes that address problems with classes.</p>
<p>In summary:</p>
<blockquote>
<div><ul class="simple">
<li><p>variables of class type can no longer store <cite>nil</cite> by default but can
opt-in to possibly being <cite>nil</cite> with <cite>?</cite>.
See <a class="reference internal" href="#readme-evolution-nilability-changes"><span class="std std-ref">nilability changes</span></a></p></li>
<li><p>certain casts have changed behavior to support nilability changes
See <a class="reference internal" href="#readme-evolution-nilability-and-casts"><span class="std std-ref">nilability and casts</span></a></p></li>
<li><p>un-decorated class types such as <cite>MyClass</cite> (as opposed to <cite>borrowed
MyClass</cite>) now have generic management
See <a class="reference internal" href="#readme-evolution-undecorated-classes-generic-management"><span class="std std-ref">undecorated classes have generic management</span></a></p></li>
<li><p>arguments with <cite>owned</cite> or <cite>shared</cite> declared type now use <cite>const ref</cite>
default intent rather than <cite>in</cite> intent.
See <a class="reference internal" href="#readme-evolution-new-default-intent-for-owned-and-shared"><span class="std std-ref">new default intent for owned and shared</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C</span></code> now creates an <cite>owned C</cite> rather than a <cite>borrowed C</cite>
See <a class="reference internal" href="#readme-evolution-new-c-is-owned"><span class="std std-ref">new C is owned</span></a></p></li>
</ul>
</div></blockquote>
<div class="section" id="nilability-changes">
<span id="readme-evolution-nilability-changes"></span><h3>nilability changes<a class="headerlink" href="#nilability-changes" title="Permalink to this headline">¶</a></h3>
<p>Previous to 1.20, variables of class type could always store <code class="docutils literal notranslate"><span class="pre">nil</span></code>.  In
1.20, only nilable class types can store <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Non-nilable class types
and nilable class types are different types. A class type expression
such as <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> indicates a non-nilable class type.</p>
<p>As an aid in migrating code to this change, the flag <code class="docutils literal notranslate"><span class="pre">--legacy-classes</span></code>
will disable this new behavior.</p>
<p>Consider the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">()).</span><span class="nx">borrow</span><span class="p">();</span>
</pre></div>
</div>
<p>In 1.19, variables of type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> could store <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
</pre></div>
</div>
<p>The 1.20 compiler will report errors for all 3 of these lines. To resolve
the errors, it is necessary to use a nilable class type. Nilable class
types are written with <code class="docutils literal notranslate"><span class="pre">?</span></code> at the end of the type. In this example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">()).</span><span class="nx">borrow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">?;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span>
</pre></div>
</div>
<p>Implicit conversions are allowed from non-nilable class types to nilable
class types.</p>
<p>When converting variables to nilable types to migrate code, there will be
situations in which it is known by the developer that a variable cannot
be <code class="docutils literal notranslate"><span class="pre">nil</span></code> at a particular point in the code. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">proc</span> <span class="nf">C.method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">config</span> <span class="kd">const</span> <span class="nx">choice</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span>
<span class="k">if</span> <span class="nx">choice</span> <span class="k">then</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">else</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
</pre></div>
</div>
<p>Errors on the last two lines can be resolved by writing</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="o">!</span><span class="p">);</span>
<span class="nx">a</span><span class="o">!</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
</pre></div>
</div>
<p>where here the <code class="docutils literal notranslate"><span class="pre">!</span></code> asserts that the value is not <code class="docutils literal notranslate"><span class="pre">nil</span></code> and it can
halt if the value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>Note that in <code class="docutils literal notranslate"><span class="pre">prototype</span></code> and implicit file-level modules, the compiler
will automatically add <code class="docutils literal notranslate"><span class="pre">!</span></code> on method calls with nilable receivers
(i.e. in the <code class="docutils literal notranslate"><span class="pre">a.method()</span></code> case above).</p>
<p>In the above case, a cleaner way to write the conditional would be to
create a function that always returns a value or throws if there is a
problem. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">makeC</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span>
  <span class="k">if</span> <span class="nx">choice</span> <span class="k">then</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span><span class="p">;</span> <span class="c1">// this cast throws if a stores nil</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">makeC</span><span class="p">();</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">method</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="nilability-and-casts">
<span id="readme-evolution-nilability-and-casts"></span><h3>nilability and casts<a class="headerlink" href="#nilability-and-casts" title="Permalink to this headline">¶</a></h3>
<p>Because casts to class types should necessarily return something of the
requested type, and because many class types now cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code>,
certain patterns involving casts will need to change to work with 1.20.</p>
<div class="section" id="class-downcasts">
<h4>class downcasts<a class="headerlink" href="#class-downcasts" title="Permalink to this headline">¶</a></h4>
<p>In a class downcast, a class is casted to a subtype. If the dynamic type
of the variable does not match the requested subtype, the downcast fails.
In 1.19, a failed downcast would result in <code class="docutils literal notranslate"><span class="pre">nil</span></code>. In 1.20, a failed
downcast will result in <code class="docutils literal notranslate"><span class="pre">nil</span></code> only if the target type is nilable and
will throw an error otherwise.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="nx">Parent</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">p</span><span class="p">:</span><span class="k">borrowed</span> <span class="nx">Parent</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">Parent</span><span class="p">()).</span><span class="nx">borrow</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span><span class="k">borrowed</span> <span class="nx">Parent</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">Child</span><span class="p">()).</span><span class="nx">borrow</span><span class="p">();</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span><span class="nx">Child</span><span class="p">?);</span> <span class="c1">// downcast succeeds</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">c</span><span class="p">:</span><span class="nx">Child</span><span class="p">);</span>  <span class="c1">// downcast succeeds</span>

<span class="nx">writeln</span><span class="p">(</span><span class="nx">p</span><span class="p">:</span><span class="nx">Child</span><span class="p">?);</span> <span class="c1">// this downcast fails and results in `nil`</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">p</span><span class="p">:</span><span class="nx">Child</span><span class="p">);</span> <span class="c1">// this downcast fails and will throw a ClassCastError</span>
</pre></div>
</div>
</div>
<div class="section" id="casting-c-pointers-to-classes">
<h4>casting C pointers to classes<a class="headerlink" href="#casting-c-pointers-to-classes" title="Permalink to this headline">¶</a></h4>
<p>Casts from <code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code> to class types were previously allowed. However,
since <code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code> can store <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, this case needs adjustment
following the nilability changes. Additionally, since <code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code>
refers to a C pointer, and C pointers are manually managed (i.e. you call
<code class="docutils literal notranslate"><span class="pre">free</span></code> on them at the appropriate time), it makes the most sense
for casts from <code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code> to end up with an unmanaged type.</p>
<p>Consider the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myC</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">ptr</span><span class="p">:</span><span class="nx">c_void_ptr</span> <span class="o">=</span> <span class="nx">myC</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span> <span class="c1">// store the instance in a C ptr</span>
</pre></div>
</div>
<p>Now we can cast from <code class="docutils literal notranslate"><span class="pre">ptr</span></code> to the class type:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">ptr</span><span class="p">:</span><span class="nx">C</span><span class="p">;</span> <span class="c1">// cast from a C pointer to the borrowed type</span>
</pre></div>
</div>
<p>This example would work in 1.19. In 1.20, it needs to be updated to
cast to <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C?</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">ptr</span><span class="p">:</span><span class="k">unmanaged</span> <span class="nx">C</span><span class="p">?;</span>
</pre></div>
</div>
<p>As with other values of type <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C?</span></code>, from there it can:</p>
<blockquote>
<div><ul class="simple">
<li><p>be borrowed, e.g. <code class="docutils literal notranslate"><span class="pre">c.borrow()</span></code></p></li>
<li><p>have <code class="docutils literal notranslate"><span class="pre">!</span></code> applied to convert to a non-nilable value or halt, e.g. <code class="docutils literal notranslate"><span class="pre">c!</span></code></p></li>
<li><p>be cast to a non-nilable type, throwing if it is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, e.g.
<code class="docutils literal notranslate"><span class="pre">c:borrowed</span> <span class="pre">C</span></code></p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="undecorated-classes-have-generic-management">
<span id="readme-evolution-undecorated-classes-generic-management"></span><h3>undecorated classes have generic management<a class="headerlink" href="#undecorated-classes-have-generic-management" title="Permalink to this headline">¶</a></h3>
<p>Undecorated classes now have generic management. As an aid in migrating
code to this change, the flag <code class="docutils literal notranslate"><span class="pre">--legacy-classes</span></code> will disable this
new behavior.</p>
<p>Supposing that we have a <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">C</span></code> declaration as in the following:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Code using <code class="docutils literal notranslate"><span class="pre">C</span></code> might refer to the type <code class="docutils literal notranslate"><span class="pre">C</span></code> on its own or it might use
a decorator to specify memory management strategy, as in <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>.</p>
<p>The type expression <code class="docutils literal notranslate"><span class="pre">C</span></code> was the same as <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> in 1.18 and
1.19 but now means generic management. For example, in the following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">myC</span><span class="p">:</span><span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">myC</span></code> previously had type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>, and was initialized using
including an implicit conversion from <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> to <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>. In 1.20,
<code class="docutils literal notranslate"><span class="pre">myC</span></code> has type <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>. Since the variable’s type expression is
generic management, it takes its management from the initializing
expression.</p>
<p>This change combines with the nilability changes described above
to prevent compilation of existing code like the following:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="nx">C</span><span class="p">;</span>
</pre></div>
</div>
<p>Knowing that <code class="docutils literal notranslate"><span class="pre">C</span></code> now cannot store <code class="docutils literal notranslate"><span class="pre">nil</span></code>, one might try to update this
program to:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="nx">C</span><span class="p">?;</span>
</pre></div>
</div>
<p>However this does not work either. <code class="docutils literal notranslate"><span class="pre">C?</span></code> indicates a nilable class type
with generic management, and a variable with generic type cannot be
default-initialized.</p>
<p>To update such a variable declaration to 1.20, it is necessary to include
a memory management decorator as well as <code class="docutils literal notranslate"><span class="pre">?</span></code>. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="k">borrowed</span> <span class="nx">C</span><span class="p">?;</span>
</pre></div>
</div>
<p>The resulting variable will initially store <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
</div>
<div class="section" id="new-default-intent-for-owned-and-shared">
<span id="readme-evolution-new-default-intent-for-owned-and-shared"></span><h3>new default intent for owned and shared<a class="headerlink" href="#new-default-intent-for-owned-and-shared" title="Permalink to this headline">¶</a></h3>
<p>The default intent for <cite>owned</cite> and <cite>shared</cite> arguments is now
<cite>const ref</cite> where it was previously <cite>in</cite>. Cases where such arguments
will be interpreted differently can be reported with the <code class="docutils literal notranslate"><span class="pre">--warn-unstable</span></code>
compilation flag.</p>
<p>Consider the following example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">global</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">?;</span>
<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">global</span> <span class="o">=</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>This program used to compile and run, performing ownership transfer
once when passing the result of <code class="docutils literal notranslate"><span class="pre">new</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span></code> and a second time
in the assignment statement <code class="docutils literal notranslate"><span class="pre">global</span> <span class="pre">=</span> <span class="pre">arg</span></code>.</p>
<p>This program does not work in 1.20. The compiler will issue an error for
the statement <code class="docutils literal notranslate"><span class="pre">global</span> <span class="pre">=</span> <span class="pre">arg</span></code> because the ownership transfer requires
modifying <code class="docutils literal notranslate"><span class="pre">arg</span></code> but it is not modifiable because it was passed with
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent.</p>
<p>To continue working, this program needs to be updated to add the <cite>in</cite>
intent to <code class="docutils literal notranslate"><span class="pre">f</span></code>, as in <code class="docutils literal notranslate"><span class="pre">proc</span> <span class="pre">f(in</span> <span class="pre">arg:</span> <span class="pre">owned</span> <span class="pre">C)</span></code>.</p>
<p>Note that for totally generic arguments, the 1.18 and 1.19 compiler
would instantiate the argument with the borrow type when passed
<code class="docutils literal notranslate"><span class="pre">owned</span></code> or <code class="docutils literal notranslate"><span class="pre">shared</span></code> classes. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">myC</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nx">f</span><span class="p">(</span><span class="nx">myC</span><span class="p">);</span>       <span class="c1">// does this call transfer ownership out of myC?</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">myC</span><span class="p">);</span> <span class="c1">// prints `nil` if ownership transfer occurred</span>
</pre></div>
</div>
<p>This example functions the same in 1.18 and 1.20, but for different
reasons. In 1.18, <code class="docutils literal notranslate"><span class="pre">f</span></code> is instantiated as accepting an argument of type
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>. In the call <code class="docutils literal notranslate"><span class="pre">f(myC)</span></code>, the compiler applies a coercion
from <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> to <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>, so ownership transfer does not occur.
In 1.20, <code class="docutils literal notranslate"><span class="pre">f</span></code> is instantiated as accepting an argument of type <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>
but this type uses the default intent (<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>). As a result,
ownership transfer does not occur.</p>
</div>
<div class="section" id="new-c-is-owned">
<span id="readme-evolution-new-c-is-owned"></span><h3>new C is owned<a class="headerlink" href="#new-c-is-owned" title="Permalink to this headline">¶</a></h3>
<p>Supposing that <cite>C</cite> is a class type, <cite>new C()</cite> was equivalent to
<cite>new borrowed C()</cite> before this release - meaning that it resulted in
something of type <cite>borrowed C</cite>. However, it is now equivalent to <cite>new
owned C()</cite> which produces something of type <cite>owned C</cite>.</p>
</div>
</div>
<div class="section" id="version-1-18-september-2018">
<h2>version 1.18, September 2018<a class="headerlink" href="#version-1-18-september-2018" title="Permalink to this headline">¶</a></h2>
<p>Version 1.18 includes many language changes that address problems with
classes.</p>
<p>In summary:</p>
<blockquote>
<div><ul class="simple">
<li><p>constructors are deprecated and replaced with initializers
See <a class="reference internal" href="#readme-evolution-initializers-replace-constructors"><span class="std std-ref">initializers replace constructors</span></a></p></li>
<li><p>memory management for class types has changed
See <a class="reference internal" href="#readme-evolution-class-memory-management"><span class="std std-ref">class memory management</span></a></p></li>
<li><p><cite>override</cite> is now required on overriding methods
See <a class="reference internal" href="#readme-evolution-mark-overriding"><span class="std std-ref">overriding methods must be marked</span></a></p></li>
</ul>
</div></blockquote>
<div class="section" id="initializers-replace-constructors">
<span id="readme-evolution-initializers-replace-constructors"></span><h3>initializers replace constructors<a class="headerlink" href="#initializers-replace-constructors" title="Permalink to this headline">¶</a></h3>
<p>Code that contained user-defined constructors will need to be updated
to use an initializer. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">Point</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In Point()&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">Point</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In Point(x,y)&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span><span class="nx">Point</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>will now compile with deprecation warnings. Here is the same program
updated to use initializers:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In Point.init()&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">proc</span> <span class="nf">init</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;In Point.init(x,y)&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">:</span><span class="nx">Point</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The change to initializers is much more than a change in the name of the
method. See the language specification for further details.</p>
</div>
<div class="section" id="class-memory-management">
<span id="readme-evolution-class-memory-management"></span><h3>class memory management<a class="headerlink" href="#class-memory-management" title="Permalink to this headline">¶</a></h3>
<p>Before 1.18, if <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class type, a variable of type <code class="docutils literal notranslate"><span class="pre">C</span></code> needed
to be deleted in order to prevent a memory leak. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">instance</span><span class="p">:</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Version 1.18 introduced four memory management strategies that form part
of a class type and are used with <cite>new</cite> expressions:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">owned</span></code> classes will be deleted automatically when the <code class="docutils literal notranslate"><span class="pre">owned</span></code>
variable goes out of scope, but only one <code class="docutils literal notranslate"><span class="pre">owned</span></code> variable can refer to
the instance at a time.
Such instances can be created with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">owned</span> <span class="pre">C()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">shared</span></code> classes will be deleted when all of the <code class="docutils literal notranslate"><span class="pre">shared</span></code> variables
referring to the instance go out of scope.
Such instances can be created with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">shared</span> <span class="pre">C()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code></dt><dd><p>refers to a class instance that has a lifetime managed by
another variable.
Values of type <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code> can be created with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span>
<span class="pre">C()</span></code>, by coercion from the other class <code class="docutils literal notranslate"><span class="pre">C</span></code> types, or by explicitly
calling the <code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method on one of the other class <code class="docutils literal notranslate"><span class="pre">C</span></code>
types.
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span> <span class="pre">C()</span></code> creates a temporary instance that will automatically
be deleted at the end of the current block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C</span></code></dt><dd><p>the instance must have <cite>delete</cite> called on it explicitly to
reclaim its memory.
Such instances can be created with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">unmanaged</span> <span class="pre">C()</span></code>.</p>
</dd>
</dl>
<p>Further note that the default is <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, that is:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code></dt><dd><p>is now the same as <code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code></dt><dd><p>is now the same as <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span> <span class="pre">C()</span></code></p>
</dd>
</dl>
<p>Now, back to the example above. There are several ways to translate this
program.</p>
<p>First, the most semantically similar option is to replace uses of <code class="docutils literal notranslate"><span class="pre">C</span></code>
with <code class="docutils literal notranslate"><span class="pre">unmanaged</span> <span class="pre">C</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">instance</span><span class="p">:</span> <span class="k">unmanaged</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">unmanaged</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> allows a Chapel programmer to opt in to manually
managing the memory of the instances.</p>
<p>A reasonable alternative would be to translate the program to use
<code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">instance</span><span class="p">:</span> <span class="k">owned</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// instance will now be automatically deleted at the end of this block</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the program does not explicitly use <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code>, it can rely on
<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">C()</span></code> being equivalent to <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">borrowed</span> <span class="pre">C()</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">instance</span><span class="p">:</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// instance will now be automatically deleted at the end of this block</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See the <em>Class New</em> section in the <em>Classes</em> chapter of the language
specification for more details.</p>
</div>
<div class="section" id="overriding-methods-must-be-marked">
<span id="readme-evolution-mark-overriding"></span><h3>overriding methods must be marked<a class="headerlink" href="#overriding-methods-must-be-marked" title="Permalink to this headline">¶</a></h3>
<p>Before 1.18, a class inheriting from another class can create an
overriding method that is a candidate for virtual dispatch:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&quot;!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">grade</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&quot;, welcome to grade &quot;</span><span class="p">,</span> <span class="nx">grade</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Student</span><span class="p">(</span><span class="s">&quot;Jeannie&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="nx">person</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span> <span class="c1">// uses the run-time type of person (Student)</span>
                  <span class="c1">// and virtually dispatches to Student.greet()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now such overriding methods must be marked with the <cite>override</cite> keyword:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span><span class="p">:</span> <span class="kt">string</span><span class="p">;</span>
  <span class="k">proc</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&quot;!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">grade</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">override</span> <span class="k">proc</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="s">&quot;, welcome to grade &quot;</span><span class="p">,</span> <span class="nx">grade</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Student</span><span class="p">(</span><span class="s">&quot;Jeannie&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="nx">person</span><span class="p">.</span><span class="nx">greet</span><span class="p">();</span> <span class="c1">// uses the run-time type of person (Student)</span>
                  <span class="c1">// and virtually dispatches to Student.greet()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="version-1-15-april-2017">
<h2>version 1.15, April 2017<a class="headerlink" href="#version-1-15-april-2017" title="Permalink to this headline">¶</a></h2>
<p>Version 1.15 includes several language changes to improve array semantics.</p>
<p>In summary:</p>
<blockquote>
<div><ul class="simple">
<li><p>arrays are always destroyed when they go out of scope and
in particular will not be preserved by use in <cite>begin</cite>.
See <a class="reference internal" href="#readme-evolution-array-lexical-scoping"><span class="std std-ref">array lexical scoping</span></a>.</p></li>
<li><p>the array alias operator <cite>=&gt;</cite> has been deprecated in favor of creating
references to an array or a slice of an array with <cite>ref</cite> or <cite>const ref</cite>.
See <a class="reference internal" href="#readme-evolution-alias-operator-deprecated"><span class="std std-ref">array alias operator deprecated</span></a>.</p></li>
<li><p>arrays now return by value by default instead of by <cite>ref</cite>.
See <a class="reference internal" href="#readme-evolution-arrays-return-by-value"><span class="std std-ref">arrays return by value by default</span></a>.</p></li>
<li><p>arrays now pass by <cite>ref</cite> or <cite>const ref</cite> by default, depending on
whether or not the formal argument is modified.
See <a class="reference internal" href="#readme-evolution-array-default-intent"><span class="std std-ref">array default intent</span></a>.</p></li>
</ul>
</div></blockquote>
<p>Additionally, the default intent for record method receivers has changed:</p>
<blockquote>
<div><ul class="simple">
<li><p>the method receiver for records is passed by <cite>ref</cite> or <cite>const ref</cite> by
default, depending on whether or not the formal argument is modified.
See <a class="reference internal" href="#readme-evolution-record-this-default-intent"><span class="std std-ref">record this default intent</span></a>.</p></li>
</ul>
</div></blockquote>
<div class="section" id="array-lexical-scoping">
<span id="readme-evolution-array-lexical-scoping"></span><h3>array lexical scoping<a class="headerlink" href="#array-lexical-scoping" title="Permalink to this headline">¶</a></h3>
<p>As described in the language changes for 1.12 in
<a class="reference internal" href="#readme-evolution-lexical-scoping"><span class="std std-ref">lexical scoping</span></a>, using arrays beyond their scope
is a user error. While such a program was in error starting with Chapel
1.12, such a pattern worked until Chapel 1.15.</p>
<p>For example, this program will probably crash in Chapel 1.15:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">badBegin</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
  <span class="k">begin</span> <span class="p">{</span>
    <span class="nx">A</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Error: A destroyed here at function end, but the begin could still</span>
  <span class="c1">// be using it!</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, using a slice after an array has been destroyed is an error:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">badBeginSlice</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
  <span class="c1">// slice1 sets up a slice using the =&gt; operator</span>
  <span class="c1">// note that the =&gt; operator is deprecated (see below)</span>
  <span class="kd">var</span> <span class="nx">slice1</span> <span class="o">=&gt;</span> <span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="p">];</span>
  <span class="c1">// slice2 sets up a slice by creating a reference to it</span>
  <span class="kd">ref</span> <span class="nx">slice2</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="p">];</span>
  <span class="c1">// either way, using the slice in a begin that can continue</span>
  <span class="c1">// after the function declaring the array exits is an error</span>
  <span class="k">begin</span> <span class="p">{</span>
    <span class="nx">slice1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">slice2</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Error: A destroyed here at function end, but the begin tries to</span>
  <span class="c1">// use it through the slices!</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="array-alias-operator-deprecated">
<span id="readme-evolution-alias-operator-deprecated"></span><h3>array alias operator deprecated<a class="headerlink" href="#array-alias-operator-deprecated" title="Permalink to this headline">¶</a></h3>
<p>The array alias operator, <cite>=&gt;</cite>, has been deprecated in Chapel 1.15.
Previously, the supported way to declare one array that aliases another
(or a slice of another) was to use <cite>=&gt;</cite>. Now, the supported way to do
that is to use a <cite>ref</cite> or <cite>const ref</cite> variable:</p>
<p>For example, before Chapel 1.15 you might have written:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// pre-1.15</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="c1">// set up a const alias of A</span>
<span class="kd">const</span> <span class="nx">alias</span> <span class="o">=&gt;</span> <span class="nx">A</span><span class="p">;</span>
<span class="c1">// set up a mutable slice of A</span>
<span class="kd">var</span> <span class="nx">slice</span> <span class="o">=&gt;</span> <span class="nx">A</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span>
<span class="c1">// set up a re-indexing slice of A</span>
<span class="kd">var</span> <span class="nx">reindex</span><span class="p">:[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="nx">A</span><span class="p">;</span>
</pre></div>
</div>
<p>In Chapel 1.15, use <cite>ref</cite> or <cite>const ref</cite> to create the same pattern:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="c1">// set up a const alias of A</span>
<span class="kd">const</span> <span class="kd">ref</span> <span class="nx">alias</span> <span class="o">=</span> <span class="nx">A</span><span class="p">;</span>
<span class="c1">// set up a mutable slice of A</span>
<span class="kd">ref</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span>
<span class="c1">// set up a re-indexing slice of A</span>
<span class="kd">ref</span> <span class="nx">reindex</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">reindex</span><span class="p">({</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays-return-by-value-by-default">
<span id="readme-evolution-arrays-return-by-value"></span><h3>arrays return by value by default<a class="headerlink" href="#arrays-return-by-value-by-default" title="Permalink to this headline">¶</a></h3>
<p>Before Chapel 1.15, returning an array would return the array by
reference. Now arrays return by value by default. That is, the act of
returning an array can make a copy:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="k">proc</span> <span class="nf">returnsArray</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">ref</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">returnsArray</span><span class="p">();</span>
<span class="nx">B</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
<span class="c1">// outputs 1 1 1 1 historically</span>
<span class="c1">// outputs 0 0 0 0 after Chapel 1.15</span>
</pre></div>
</div>
<p>This behavior applies to array slices as well.</p>
<p>The old behavior is available with the <cite>ref</cite> return intent. Note though that
returning a <cite>ref</cite> to a local array is an error just like it is an error to
return a local <cite>int</cite> variable by <cite>ref</cite>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">returnsArrayReference</span><span class="p">()</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="array-default-intent">
<span id="readme-evolution-array-default-intent"></span><h3>array default intent<a class="headerlink" href="#array-default-intent" title="Permalink to this headline">¶</a></h3>
<p>Before 1.15, the default intent for arrays was <cite>ref</cite>. The rationale for
this feature was that it was a convenience for programmers who are used
to modifying array formal arguments in their functions. Unfortunately, it
interacted poorly with return intent overloading.
Additionally, the implementation had several bugs in this area.</p>
<p>The following example shows how it might be surprising that return intent
overloading behaves very differently for arrays than for other types. As
the example shows, this issue affects program behavior and not just
const-checking error messages from the compiler.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// First, let&#39;s try some of these things with an</span>
<span class="c1">// associative array of ints:</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">D</span><span class="p">:</span><span class="k">domain</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">A</span><span class="p">:[</span><span class="nx">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>

  <span class="c1">// This adds index 1 to the domain, implicitly</span>
  <span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">D</span><span class="p">.</span><span class="nx">member</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// outputs `true`</span>

  <span class="c1">// This will halt, because index 2 is not in the domain</span>
  <span class="c1">//var tmp = A[2];</span>

  <span class="c1">// This will also halt, for the same reason</span>
  <span class="c1">//writeln(A[3]);</span>
<span class="p">}</span>

<span class="c1">// Now, let&#39;s try the same things with an array of arrays:</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">D</span><span class="p">:</span><span class="k">domain</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">AA</span><span class="p">:[</span><span class="nx">D</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">:[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">];</span>

  <span class="c1">// This adds index 4 to the domain, implicitly</span>
  <span class="nx">AA</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">D</span><span class="p">.</span><span class="nx">member</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="c1">// outputs `true`</span>

  <span class="c1">// This will halt, because index 5 is not in the domain</span>
  <span class="c1">//var tmp = AA[5];</span>

  <span class="c1">// It seems that this *should* halt, but it does not (pre 1.15)</span>
  <span class="c1">// Instead, it adds index 6 to the domain</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">AA</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">D</span><span class="p">.</span><span class="nx">member</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="c1">// outputs `true` !</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/chapel-lang/chapel/issues/5217">GitHub issue #5217</a>
for more examples and discussion.</p>
<p>In order to make such programs less surprising, version 1.15 changes the default
intent for arrays to <cite>ref</cite> if the formal argument is modified in the function
and <cite>const ref</cite> if not. As a result, the above example behaves similarly for an
associative array of integers and an associative array of dense arrays.</p>
<p>For example, in the following program, the default intent for the formal
argument <cite>x</cite> is <cite>ref</cite>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">setElementOne</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// x is modified, so x has ref intent</span>
  <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">A</span><span class="p">:[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">setElementOne</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</pre></div>
</div>
<p>In contrast, in the following program, the default intent for the formal argument <cite>y</cite> is <cite>const ref</cite>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">getElementOne</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// y is not modified, so y has const ref intent</span>
  <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">B</span><span class="p">:[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="nx">getElementOne</span><span class="p">(</span><span class="nx">B</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="record-this-default-intent">
<span id="readme-evolution-record-this-default-intent"></span><h3>record <cite>this</cite> default intent<a class="headerlink" href="#record-this-default-intent" title="Permalink to this headline">¶</a></h3>
<p>Before 1.15, the default intent for the implicit <cite>this</cite> argument for
record methods was implemented as <cite>ref</cite> but specified as <cite>const ref</cite>. In
1.15, this changed to <cite>ref</cite> if the formal <cite>this</cite> argument is modified in
the body of the function and <cite>const ref</cite> if not.</p>
<p>See <a class="reference external" href="https://github.com/chapel-lang/chapel/issues/5266">GitHub issue #5266</a>
for more details and discussion.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">R</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">field</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

  <span class="k">proc</span> <span class="nf">setFieldToOne</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this is modified, so this-intent is ref</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">field</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">proc</span> <span class="nf">printField</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this is not modified, so this-intent is const ref</span>
    <span class="nx">writeln</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="version-1-13-april-2016">
<h2>version 1.13, April 2016<a class="headerlink" href="#version-1-13-april-2016" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ref-return-intent">
<h3>ref return intent<a class="headerlink" href="#ref-return-intent" title="Permalink to this headline">¶</a></h3>
<p>Previous versions of Chapel included an implicit <cite>setter</cite> param of
type <cite>bool</cite> for <cite>ref</cite> return intent functions. In addition, the compiler
created a getter and setter version of each ref return intent function.
The getter version would return an rvalue, and the setter version would
return an lvalue by ref. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">proc</span> <span class="nf">refToX</span><span class="p">()</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">setter</span> <span class="k">then</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// setter version</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// getter version</span>
<span class="p">}</span>

<span class="nx">refToX</span><span class="p">()</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1">// uses the setter version</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>         <span class="c1">// prints 3</span>
<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">refToX</span><span class="p">();</span> <span class="c1">// uses the getter version</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>       <span class="c1">// prints 0</span>
</pre></div>
</div>
<p>This functionality has changed with version 1.13. It is still possible to
write a getter and a setter, but these must be written as pair of
related functions:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// setter version</span>
<span class="k">proc</span> <span class="nf">refToX</span><span class="p">()</span> <span class="kd">ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// getter version</span>
<span class="k">proc</span> <span class="nf">refToX</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">refToX</span><span class="p">()</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1">// uses the setter version</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>         <span class="c1">// prints 3</span>
<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">refToX</span><span class="p">();</span> <span class="c1">// uses the getter version</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>       <span class="c1">// prints 0</span>
</pre></div>
</div>
<p>In some cases, when migrating code over to the new functionality,
it is useful to put the old ref return intent function into a
helper function with an explicit param <cite>setter</cite> argument, and then to
call that function from the getter or setter.</p>
</div>
</div>
<div class="section" id="version-1-12-october-2015">
<h2>version 1.12, October 2015<a class="headerlink" href="#version-1-12-october-2015" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lexical-scoping">
<span id="readme-evolution-lexical-scoping"></span><h3>lexical scoping<a class="headerlink" href="#lexical-scoping" title="Permalink to this headline">¶</a></h3>
<p>Prior to version 1.12 of Chapel, variables could be kept alive past
their lexical scopes. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">count$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">begin</span> <span class="k">with</span> <span class="p">(</span><span class="kd">ref</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">..</span><span class="p">.</span> <span class="nx">A</span> <span class="o">..</span><span class="p">.;</span>
    <span class="o">..</span><span class="p">.</span> <span class="nx">count$</span> <span class="o">..</span><span class="p">.;</span>
    <span class="o">..</span><span class="p">.</span> <span class="nx">x</span> <span class="o">..</span><span class="p">.;</span>
  <span class="p">}</span>
  <span class="c1">// ^^^ this task and its references to A, count$, and x could outlive</span>
  <span class="c1">// the scope in which those variables are declared.</span>
<span class="p">}</span> <span class="c1">// So, previously, Chapel kept these variables alive past their</span>
  <span class="c1">// logical scope.</span>
</pre></div>
</div>
<p>Disadvantages of this approach included:</p>
<blockquote>
<div><ul class="simple">
<li><p>It moves logical stack variables (like <cite>x</cite> and <cite>count$</cite> above) to
the heap.</p></li>
<li><p>It complicates memory management by incurring reference counting
overhead—or causing memory leaks in cases where reference
counting hadn’t been added.</p></li>
<li><p>It was not particularly valued or utilized by users.</p></li>
<li><p>It was arguably surprising (“x still exists even though it left
scope?”).</p></li>
</ul>
</div></blockquote>
<p>As of Chapel 1.12 (and moreso in subsequent releases), the
implementation no longer provides this property. Instead, it is a user
error to refer to a variable after it has left scope. For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">flag$</span><span class="p">:</span> <span class="k">sync</span> <span class="kt">bool</span><span class="p">;</span> <span class="c1">// flag$ starts empty</span>
<span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">;</span>
  <span class="k">begin</span> <span class="k">with</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// create task referring to x</span>
    <span class="nx">flag$</span><span class="p">;</span>            <span class="c1">// block task until flag$ is full</span>
    <span class="o">..</span><span class="p">.</span> <span class="nx">x</span> <span class="o">..</span><span class="p">.</span>         <span class="c1">// user error: access to x occurs after it leaves scope</span>
  <span class="p">}</span>                   <span class="c1">// end task</span>
<span class="p">}</span>                     <span class="c1">// x`s scope ends</span>
<span class="nx">flag$</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>         <span class="c1">// fill flag$ only after x&#39;s scope closes</span>
</pre></div>
</div>
<p>Code that refers to lexically scoped variables within tasks in this manner
should use <cite>sync</cite> variables or blocks in order to guarantee the
tasks’s completion before the enclosing block exits. Note that the
more commonly used <cite>cobegin</cite>, <cite>coforall</cite>, and <cite>forall</cite> statements
already guarantee that the tasks they create will complete before the
enclosing block exits.</p>
</div>
</div>
<div class="section" id="version-1-11-april-2015">
<h2>version 1.11, April 2015<a class="headerlink" href="#version-1-11-april-2015" title="Permalink to this headline">¶</a></h2>
<div class="section" id="forall-intents">
<h3>forall intents<a class="headerlink" href="#forall-intents" title="Permalink to this headline">¶</a></h3>
<p>In previous versions of Chapel, the bodies of forall-loops have referred to
all lexically visible variables by reference. In this release of Chapel, such
variables are treated more consistently with the task intent semantics and
syntax introduced in versions 1.8 and 1.10 respectively (described below).</p>
<p>Specifically, prior to this release, a loop like the following would
represent a data race:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">forall</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">do</span> <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">a</span><span class="p">;</span>
</pre></div>
</div>
<p>since multiple iterations of the loop could execute simultaneously, read
the identical value from the shared variable <code class="docutils literal notranslate"><span class="pre">sum</span></code>, update it, and write the
result back in a way that could overwrite other simultaneous updates.</p>
<p>Under the new forall intent semantics, such variables are treated as though
they are passed by “blank intent” to the loop body (so <code class="docutils literal notranslate"><span class="pre">const</span></code> for variables of
scalar type like <code class="docutils literal notranslate"><span class="pre">sum</span></code>, preventing races in such cases). This mirrors the task
intent semantics for variables referenced within begin, <code class="docutils literal notranslate"><span class="pre">cobegin</span></code>, and <code class="docutils literal notranslate"><span class="pre">coforall</span></code>
constructs. As in those cases, a user can specify semantics other than the
default via a <em>with-clause</em>. For example, to restore the previous race-y
semantics, one could write:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">forall</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">with</span> <span class="p">(</span><span class="kd">ref</span> <span class="nx">sum</span><span class="p">)</span> <span class="k">do</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">a</span><span class="p">;</span>
</pre></div>
</div>
<p>(Of course, the safe way to write such an idiom would be to use a
reduction, or a synchronization type like <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">atomic</span></code>).</p>
</div>
<div class="section" id="type-select-statement">
<h3>type select statement<a class="headerlink" href="#type-select-statement" title="Permalink to this headline">¶</a></h3>
<p>Chapel has traditionally supported a <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">select</span></code> statement that was
like a <code class="docutils literal notranslate"><span class="pre">select</span></code> statement for types. However, this seemed inconsistent with the
fact that other constructs like <code class="docutils literal notranslate"><span class="pre">if...then</span></code> operate on types directly. For that
reason, this release removed support for <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">select</span> <span class="pre">x</span></code>. Instead, use the
equivalent <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">x.type</span></code>.</p>
</div>
</div>
<div class="section" id="version-1-10-october-2014">
<h2>version 1.10, October 2014<a class="headerlink" href="#version-1-10-october-2014" title="Permalink to this headline">¶</a></h2>
<div class="section" id="task-intents-syntax">
<h3>task intents syntax<a class="headerlink" href="#task-intents-syntax" title="Permalink to this headline">¶</a></h3>
<p>Task intent clauses were added to Chapel in version 1.8 to
support passing variables by reference into tasks. Since then, the need to pass
variables by other intents and into other parallel constructs has arisen. But,
the previous syntax was problematic to extend to other intents, while also
generating syntactic ambiguities for other additions we wished to make to the
language.</p>
<p>For these reasons, a new task intent syntax was designed to cleanly support
intents other than <code class="docutils literal notranslate"><span class="pre">ref</span></code> (particularly in looping contexts), to address the
pending ambiguity, and to better reflect the similarity of task intents to
formal argument lists. Where previously, task constructs could be followed by a
<code class="docutils literal notranslate"><span class="pre">ref</span></code> clause, they can now be followed by a <code class="docutils literal notranslate"><span class="pre">with</span></code> clause that takes a list of
intents and variables, specifying how to pass them into the task.</p>
<p>Thus, where one would have previously written:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span> <span class="kd">ref</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="nx">update</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="k">cobegin</span> <span class="kd">ref</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">coforall</span> <span class="nx">x</span> <span class="kd">in</span> <span class="nx">A</span> <span class="kd">ref</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>you would now write:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span> <span class="k">with</span> <span class="p">(</span><span class="kd">ref</span> <span class="nx">x</span><span class="p">)</span> <span class="nx">update</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="k">cobegin</span> <span class="k">with</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">x</span><span class="p">,</span> <span class="kd">ref</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">coforall</span> <span class="nx">x</span> <span class="kd">in</span> <span class="nx">A</span> <span class="k">with</span> <span class="p">(</span><span class="kd">ref</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As of the 1.10 release, only <code class="docutils literal notranslate"><span class="pre">ref</span></code> intents are supported, though we plan to
expand this set of intents for the 1.11 release while also extending
forall-loops to support task intents.</p>
</div>
<div class="section" id="var-function-return-intents-changed-to-ref">
<h3>‘var’ function return intents changed to ‘ref’<a class="headerlink" href="#var-function-return-intents-changed-to-ref" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">var</span></code> function return intent has traditionally been used to indicate that
a call to the function (referred to as a <em>var function</em>) could appear in either
an r-value or l-value context. The <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword was chosen since the function
could be used in the same contexts as a variable could.</p>
<p>Since that time, the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword has been introduced into Chapel to
support passing variables by reference to functions. Since returning an
expression by reference supports similar capabilities as <code class="docutils literal notranslate"><span class="pre">var</span></code> functions require,
while also being less unusual/more orthogonal, this release replaces <code class="docutils literal notranslate"><span class="pre">var</span></code>
function return intents with <code class="docutils literal notranslate"><span class="pre">ref</span></code> intents.</p>
<p>Thus, where one would previously write:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">getFoo</span><span class="p">()</span> <span class="kd">var</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p>now you would write:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">getFoo</span><span class="p">()</span> <span class="kd">ref</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">var</span></code> as a return intent is deprecated and generates a warning for the
current release, after which it will be removed.</p>
</div>
</div>
<div class="section" id="version-1-9-april-2014">
<h2>version 1.9, April 2014<a class="headerlink" href="#version-1-9-april-2014" title="Permalink to this headline">¶</a></h2>
<div class="section" id="operator-precedence-changes-to-benefit-common-cases">
<h3>operator precedence changes to benefit common cases<a class="headerlink" href="#operator-precedence-changes-to-benefit-common-cases" title="Permalink to this headline">¶</a></h3>
<p>Historically, Chapel’s operator precedence choices have tended to follow the
lead of C for operators that are common to both languages, figuring that
following an established convention would be better than forging our own path.</p>
<p>With this change, we modified the precedence of bitwise operators to better
reflect what we think it intuitive to users and correct what is viewed in many
circles to be a regrettable mistake in C. At the same time, we changed the
binding of <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">..</span></code> to support some other Chapel idioms more naturally,
like <code class="docutils literal notranslate"><span class="pre">1..10</span> <span class="pre">==</span> <span class="pre">1..10</span></code>. To see the current operator precedence, refer to the
<a class="reference external" href="https://chapel-lang.org/spec/quickReference.pdf">Quick Reference sheet</a>.</p>
</div>
<div class="section" id="improved-interpretation-of-d">
<h3>improved interpretation of {D}<a class="headerlink" href="#improved-interpretation-of-d" title="Permalink to this headline">¶</a></h3>
<p>Historically, for a domain D, Chapel has interpreted <code class="docutils literal notranslate"><span class="pre">{D}</span></code> as being equivalent to
<code class="docutils literal notranslate"><span class="pre">D</span></code>, inheriting a precedent of sorts set by the ZPL language, and dating from a
time when we used square brackets for both domain literals and array types.</p>
<p>With this change, we began interpreting <code class="docutils literal notranslate"><span class="pre">{D}</span></code> as a domain literal with a
single index, <code class="docutils literal notranslate"><span class="pre">D</span></code> (i.e., an associative domain of domains). Associative domains
of domains are not yet implemented in the language, so the new syntax is not
yet useful, but at least the incongruity of ignoring the curly brackets has
been removed.</p>
</div>
</div>
<div class="section" id="version-1-8-october-2013">
<h2>version 1.8, October 2013<a class="headerlink" href="#version-1-8-october-2013" title="Permalink to this headline">¶</a></h2>
<p>task functions and intents; ref-clauses Chapel has three constructs for
creating tasks: <code class="docutils literal notranslate"><span class="pre">begin</span></code>, <code class="docutils literal notranslate"><span class="pre">cobegin</span></code>, and <code class="docutils literal notranslate"><span class="pre">coforall</span></code>. Historically, variable references
within tasks followed standard lexical scoping rules. For example, the
following code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">begin</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>could print either the value 0 or 1, depending on whether the <code class="docutils literal notranslate"><span class="pre">writeln()</span></code>
task was executed before or after the increment of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>With this change, we view the creation of a task as an invocation of a <em>task function</em>
— a compiler-created function that implements the task. Any references
to variables outside of the task’s scope (like <code class="docutils literal notranslate"><span class="pre">x</span></code> in the example above) are
treated as implicit arguments to the task function, passed by blank intent.</p>
<p>Thus, when <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer, as in the above code, the task will always
print the value of 0, even if the increment of <code class="docutils literal notranslate"><span class="pre">x</span></code> is executed before the
<code class="docutils literal notranslate"><span class="pre">writeln()</span></code> task, since the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> will have been passed to the task function
by blank intent (implying a <code class="docutils literal notranslate"><span class="pre">const</span></code> copy for integer arguments). In contrast, if
x were a sync variable in the example above, the blank intent would cause it to
be passed by reference to the task, permitting the task to see either of the
values 0 or 1.</p>
<p>To return to the previous behavior, a <em>ref-clause</em> can be added to the
tasking construct to indicate that a variable should be passed to the task
function by reference rather than blank intent. For example, the following
code:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">begin</span> <span class="kd">ref</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>would revert to the previous behavior, even if <code class="docutils literal notranslate"><span class="pre">x</span></code> were an integer.</p>
<p>For more information on this feature, please refer to the <em>Task Intents</em>
section of the <em>Task Parallelism</em> and <em>Synchronization</em> chapter of the language
specification.</p>
</div>
<div class="section" id="version-1-6-october-2012">
<h2>version 1.6, October 2012<a class="headerlink" href="#version-1-6-october-2012" title="Permalink to this headline">¶</a></h2>
<div class="section" id="domain-literals">
<h3>domain literals<a class="headerlink" href="#domain-literals" title="Permalink to this headline">¶</a></h3>
<p>Chapel’s domain literals were historically specified using
square brackets, based on ZPL’s region syntax. Thus <code class="docutils literal notranslate"><span class="pre">[1..m,</span> <span class="pre">1..n]</span></code> represented an
<em>m × n</em> index set.</p>
<p>In this change, we made domain literals use curly brackets in order to
reflect their role as sets of indices, and also to make square brackets
available for supporting array literals. Thus, <code class="docutils literal notranslate"><span class="pre">{1..m,</span> <span class="pre">1..n}</span></code> is an <em>m × n</em> index
set, <code class="docutils literal notranslate"><span class="pre">[1.2,</span> <span class="pre">3.4,</span> <span class="pre">5.6]</span></code> is a 3-element array of reals and <code class="docutils literal notranslate"><span class="pre">[1..m,</span> <span class="pre">1..n]</span></code> is a
2-element array of ranges.</p>
<p>Emacs users working on updating existing code can use the following recipe
to update old-style domain literals to the new syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>M-x query-replace-regexp: \([=|,] *\)\[\(.*?\)\]\([;|)]\)
with: \1{\2}\3
</pre></div>
</div>
</div>
<div class="section" id="zippered-iteration">
<h3>zippered iteration<a class="headerlink" href="#zippered-iteration" title="Permalink to this headline">¶</a></h3>
<p>Zippered iteration in Chapel was traditionally supported
simply by iterating over a tuple of values. For example, forall <code class="docutils literal notranslate"><span class="pre">(i,a)</span></code> in
<code class="docutils literal notranslate"><span class="pre">(1..n,</span> <span class="pre">A)</span></code> would iterate over the range <code class="docutils literal notranslate"><span class="pre">1..n</span></code> and the n-element array
<code class="docutils literal notranslate"><span class="pre">A</span></code> in a zippered manner.</p>
<p>In this change, we introduced the zip keyword to make these zippered
iterations more explicit and to permit iteration over a tuple’s values
directly. Thus, the zippered iteration above would now be written:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span> <span class="kd">in</span> <span class="k">zip</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ignoring-tuple-components-underscore">
<h3>ignoring tuple components/underscore<a class="headerlink" href="#ignoring-tuple-components-underscore" title="Permalink to this headline">¶</a></h3>
<p>Overtime, the mechanism used to ignore a tuple component when destructuring a tuple
has changed.
Originally, an underscore was used to drop a value on the floor. For example,
given a 3-tuple <code class="docutils literal notranslate"><span class="pre">t</span></code>, the first and last components could be stored in <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>,
dropping the second component on the floor using: <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">(x,</span> <span class="pre">_,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">t;</span></code>.
In version 1.1 (Apr 2010), we changed this to use a blank space instead of an
underscore, for simplicity and to permit underscore to be used as an identifier
name. Thus, the example above would have been written as <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">(x,</span> <span class="pre">,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">t;</span></code>
during this time period.</p>
<p>However, in 2012, we changed back to using the underscore again in order to
support the specification of 1-tuples using a dangling comma, similar to
Python. Thus, dropping a tuple component is expressed as <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">(x,</span> <span class="pre">_,</span> <span class="pre">z)</span> <span class="pre">=</span> <span class="pre">t;</span></code>
again while <code class="docutils literal notranslate"><span class="pre">(1.2,</span> <span class="pre">)</span></code> is a 1-tuple of reals.</p>
</div>
</div>
<div class="section" id="version-1-4-october-2011">
<h2>version 1.4, October 2011<a class="headerlink" href="#version-1-4-october-2011" title="Permalink to this headline">¶</a></h2>
<div class="section" id="function-declaration-keywords">
<h3>function declaration keywords<a class="headerlink" href="#function-declaration-keywords" title="Permalink to this headline">¶</a></h3>
<p>Prior to this change, the keyword <code class="docutils literal notranslate"><span class="pre">def</span></code> was used to
define both procedures and iterators; the compiler inspected the body of the
function for yield statements to determine whether it was a procedure or an
iterator.</p>
<p>In this change, we introduced the <code class="docutils literal notranslate"><span class="pre">proc</span></code> and <code class="docutils literal notranslate"><span class="pre">iter</span></code> keywords to distinguish
between these two cases for the sake of clarity, to avoid mistakes, to support
semantics that clearly distinguish between these cases, and to better support
specifying interfaces.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="archivedSpecs.html" class="btn btn-neutral float-right" title="Documentation Archives" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../users-guide/locality/onClauses.html" class="btn btn-neutral float-left" title="on-clauses: controlling locality/affinity" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>