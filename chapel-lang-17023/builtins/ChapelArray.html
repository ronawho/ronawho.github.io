

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Domain and Array Operations &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Complex" href="ChapelComplex_forDocs.html" />
    <link rel="prev" title="Bytes" href="Bytes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "builtins/ChapelArray";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Built-in Types and Functions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Atomics.html">Atomics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Bytes.html">Bytes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Domain and Array Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#distribution-domain-and-array-equality-operators">Distribution, Domain and Array Equality operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-domain-and-array-operators">Miscellaneous Domain and Array Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-domain-count-operator">The domain count operator <code class="docutils literal notranslate"><span class="pre">#</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-array-count-operator">The array count operator <code class="docutils literal notranslate"><span class="pre">#</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-array-swap-operator">The array swap operator <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#set-operations-on-associative-domains-and-arrays">Set Operations on Associative Domains and Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel-safety-with-respect-to-arrays-and-domains">Parallel Safety with respect to Arrays and Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions-and-methods-on-arrays-and-domains">Functions and Methods on Arrays and Domains</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ChapelComplex_forDocs.html">Complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="ChapelError.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="ChapelLocale.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="ChapelRange.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="ChapelSyncvar.html">Synchronization Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ChapelTuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="OwnedObject.html">owned</a></li>
<li class="toctree-l2"><a class="reference internal" href="SharedObject.html">shared</a></li>
<li class="toctree-l2"><a class="reference internal" href="String.html">Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Built-in Types and Functions</a> &raquo;</li>
        
      <li>Domain and Array Operations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/builtins/ChapelArray.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-ChapelArray"></span><div class="section" id="domain-and-array-operations">
<h1>Domain and Array Operations<a class="headerlink" href="#domain-and-array-operations" title="Permalink to this headline">¶</a></h1>
<p>Operations on Domains and Arrays.</p>
<div class="section" id="distribution-domain-and-array-equality-operators">
<h2>Distribution, Domain and Array Equality operators<a class="headerlink" href="#distribution-domain-and-array-equality-operators" title="Permalink to this headline">¶</a></h2>
<p>Equality operators are defined to test if two distributions
are equivalent or not:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">dist1</span> <span class="o">==</span> <span class="nx">dist2</span>
<span class="nx">dist1</span> <span class="o">!=</span> <span class="nx">dist2</span>
</pre></div>
</div>
<p>Or to test if two domains are equivalent or not:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">dom1</span> <span class="o">==</span> <span class="nx">dom2</span>
<span class="nx">dom1</span> <span class="o">!=</span> <span class="nx">dom2</span>
</pre></div>
</div>
<p>Arrays are promoted, so the result of the equality operators is
an array of booleans.  To get a single result use the <code class="docutils literal notranslate"><span class="pre">equals</span></code>
method instead.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">arr1</span> <span class="o">==</span> <span class="nx">arr2</span> <span class="c1">// compare each element resulting in an array of booleans</span>
<span class="nx">arr1</span> <span class="o">!=</span> <span class="nx">arr2</span> <span class="c1">// compare each element resulting in an array of booleans</span>
<span class="nx">arr1</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">arr2</span><span class="p">)</span> <span class="c1">// compare entire arrays resulting in a single boolean</span>
</pre></div>
</div>
</div>
<div class="section" id="miscellaneous-domain-and-array-operators">
<h2>Miscellaneous Domain and Array Operators<a class="headerlink" href="#miscellaneous-domain-and-array-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-domain-count-operator">
<h3>The domain count operator <code class="docutils literal notranslate"><span class="pre">#</span></code><a class="headerlink" href="#the-domain-count-operator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> operator can be applied to dense rectangular domains
with a tuple argument whose size matches the rank of the domain
(or optionally an integer in the case of a 1D domain). The operator
is equivalent to applying the <code class="docutils literal notranslate"><span class="pre">#</span></code> operator to the component
ranges of the domain and then using them to slice the domain.</p>
</div>
<div class="section" id="the-array-count-operator">
<h3>The array count operator <code class="docutils literal notranslate"><span class="pre">#</span></code><a class="headerlink" href="#the-array-count-operator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> operator can be applied to dense rectangular arrays
with a tuple argument whose size matches the rank of the array
(or optionally an integer in the case of a 1D array). The operator
is equivalent to applying the <code class="docutils literal notranslate"><span class="pre">#</span></code> operator to the array’s domain
and using the result to slice the array.</p>
</div>
<div class="section" id="the-array-swap-operator">
<h3>The array swap operator <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code><a class="headerlink" href="#the-array-swap-operator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code> operator can be used to swap the contents of two arrays
with the same shape.</p>
</div>
</div>
<div class="section" id="set-operations-on-associative-domains-and-arrays">
<h2>Set Operations on Associative Domains and Arrays<a class="headerlink" href="#set-operations-on-associative-domains-and-arrays" title="Permalink to this headline">¶</a></h2>
<p>Associative domains and arrays support a number of operators for
set manipulations.  The supported set operators are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>+ , |</p></td>
<td><p>Union</p></td>
</tr>
<tr class="row-even"><td><p>&amp;</p></td>
<td><p>Intersection</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Difference</p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>Symmetric Difference</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Consider the following code where <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are associative arrays:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">A</span> <span class="nx">op</span> <span class="nx">B</span><span class="p">;</span>
</pre></div>
</div>
<p>The result <code class="docutils literal notranslate"><span class="pre">C</span></code> is a new associative array backed by a new associative
domain. The domains of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not modified by <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
<p>There are also <code class="docutils literal notranslate"><span class="pre">op=</span></code> variants that store the result into the first operand.</p>
<p>Consider the following code where <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are associative arrays:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">A</span> <span class="nx">op</span><span class="o">=</span> <span class="nx">B</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> must not share its domain with another array, otherwise the program
will halt with an error message.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">+=</span></code> and <code class="docutils literal notranslate"><span class="pre">|=</span></code> operators, the value from <code class="docutils literal notranslate"><span class="pre">B</span></code> will overwrite
the existing value in <code class="docutils literal notranslate"><span class="pre">A</span></code> when indices overlap.</p>
</div>
<div class="section" id="parallel-safety-with-respect-to-arrays-and-domains">
<h2>Parallel Safety with respect to Arrays and Domains<a class="headerlink" href="#parallel-safety-with-respect-to-arrays-and-domains" title="Permalink to this headline">¶</a></h2>
<p>Users must take care when applying operations to arrays and domains
concurrently from distinct tasks.  For instance, if one task is
modifying the index set of a domain while another task is operating
on either the domain itself or an array declared over that domain,
this represents a race and could have arbitrary consequences
including incorrect results and program crashes.  While making
domains and arrays safe with respect to such concurrent operations
would be appealing, Chapel’s current position is that such safety
guarantees would be prohibitively expensive.</p>
<p>Chapel arrays do support concurrent reads, writes, iterations, and
operations as long as their domains are not being modified
simultaneously.  Such operations are subject to Chapel’s memory
consistency model like any other memory accesses.  Similarly, tasks
may make concurrent queries and iterations on a domain as long as
another task is not simultaneously modifying the domain’s index
set.</p>
<p>By default, associative domains permit multiple tasks
to modify their index sets concurrently.  This adds some amount of
overhead to these operations.  If the user knows that all such
modifications will be done serially or in a parallel-safe context,
the overheads can be avoided by setting <code class="docutils literal notranslate"><span class="pre">parSafe</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code> in
the domain’s type declaration.  For example, the following
declaration creates an associative domain of strings where the
implementation will do nothing to ensure that simultaneous
modifications to the domain are parallel-safe:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">D</span><span class="p">:</span> <span class="k">domain</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">parSafe</span><span class="o">=</span><span class="kc">false</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>As with any other domain type, it is not safe to access an
associative array while its domain is changing, regardless of
whether <code class="docutils literal notranslate"><span class="pre">parSafe</span></code> is set to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="section" id="functions-and-methods-on-arrays-and-domains">
<h2>Functions and Methods on Arrays and Domains<a class="headerlink" href="#functions-and-methods-on-arrays-and-domains" title="Permalink to this headline">¶</a></h2>
<dl class="chpl function">
<dt id="ChapelArray.isRectangularDom">
<em class="property">proc </em><code class="sig-name descname">isRectangularDom</code><span class="sig-paren">(</span><em class="sig-param">d: domain</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isRectangularDom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the argument <code class="docutils literal notranslate"><span class="pre">d</span></code> is a rectangular domain.
Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isRectangularArr">
<em class="property">proc </em><code class="sig-name descname">isRectangularArr</code><span class="sig-paren">(</span><em class="sig-param">a: []</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isRectangularArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the argument <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with a rectangular
domain.  Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isIrregularDom">
<em class="property">proc </em><code class="sig-name descname">isIrregularDom</code><span class="sig-paren">(</span><em class="sig-param">d: domain</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isIrregularDom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is an irregular domain; e.g. is not rectangular.
Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isIrregularArr">
<em class="property">proc </em><code class="sig-name descname">isIrregularArr</code><span class="sig-paren">(</span><em class="sig-param">a: []</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isIrregularArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with an irregular domain; e.g. not
rectangular. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isAssociativeDom">
<em class="property">proc </em><code class="sig-name descname">isAssociativeDom</code><span class="sig-paren">(</span><em class="sig-param">d: domain</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isAssociativeDom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is an associative domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isAssociativeArr">
<em class="property">proc </em><code class="sig-name descname">isAssociativeArr</code><span class="sig-paren">(</span><em class="sig-param">a: []</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isAssociativeArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with an associative domain. Otherwise
return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isSparseDom">
<em class="property">proc </em><code class="sig-name descname">isSparseDom</code><span class="sig-paren">(</span><em class="sig-param">d: domain</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isSparseDom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">d</span></code> is a sparse domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isSparseArr">
<em class="property">proc </em><code class="sig-name descname">isSparseArr</code><span class="sig-paren">(</span><em class="sig-param">a: []</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isSparseArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array with a sparse domain. Otherwise
return false.</p>
</dd></dl>

<dl class="chpl type">
<dt id="ChapelArray.domain">
<em class="property">type </em><code class="sig-name descname">domain</code><a class="headerlink" href="#ChapelArray.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The domain type</p>
<dl class="chpl method">
<dt id="ChapelArray.init">
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">_pid: int</em>, <em class="sig-param">_instance</em>, <em class="sig-param">_unowned: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">d: _distribution</em>, <em class="sig-param">param rank: int</em>, <em class="sig-param">type idxType = int</em>, <em class="sig-param">param stridable: bool = false</em>, <em class="sig-param">definedConst: bool = false</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">d: _distribution</em>, <em class="sig-param">param rank: int</em>, <em class="sig-param">type idxType = int</em>, <em class="sig-param">param stridable: bool = false</em>, <em class="sig-param">ranges: rank*(range(idxType</em>, <em class="sig-param">BoundedRangeType.bounded</em>, <em class="sig-param">stridable))</em>, <em class="sig-param">definedConst: bool = false</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">d: _distribution</em>, <em class="sig-param">type idxType</em>, <em class="sig-param">param parSafe: bool = true</em>, <em class="sig-param">definedConst: bool = false</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">d: _distribution</em>, <em class="sig-param">dom: domain</em>, <em class="sig-param">definedConst: bool = false</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.init=">
<em class="property">proc </em><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">const ref other: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.init=" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">const ref other: domain</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.dist">
<em class="property">proc </em><code class="sig-name descname">dist</code><a class="headerlink" href="#ChapelArray.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain map that implements this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.rank">
<em class="property">proc </em><code class="sig-name descname">rank</code> param<a class="headerlink" href="#ChapelArray.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dimensions in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.idxType">
<em class="property">proc </em><code class="sig-name descname">idxType</code> type<a class="headerlink" href="#ChapelArray.idxType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the type of the indices of this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.intIdxType">
<em class="property">proc </em><code class="sig-name descname">intIdxType</code> type<a class="headerlink" href="#ChapelArray.intIdxType" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">idxType</span></code> as represented by an integer type.  When
<code class="docutils literal notranslate"><span class="pre">idxType</span></code> is an enum type, this evaluates to <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Otherwise, it evaluates to <code class="docutils literal notranslate"><span class="pre">idxType</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.stridable">
<em class="property">proc </em><code class="sig-name descname">stridable</code> param<a class="headerlink" href="#ChapelArray.stridable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if this is a stridable domain</p>
</dd></dl>

<dl class="chpl itermethod">
<dt id="ChapelArray.these">
<em class="property">iter </em><code class="sig-name descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.these" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the domain indices</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.this">
<em class="property">proc </em><code class="sig-name descname">this</code><span class="sig-paren">(</span><em class="sig-param">i: integral ...rank</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.this" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.dims">
<em class="property">proc </em><code class="sig-name descname">dims</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of ranges describing the bounds of a rectangular domain.
For a sparse domain, return the bounds of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.dim">
<em class="property">proc </em><code class="sig-name descname">dim</code><span class="sig-paren">(</span><em class="sig-param">d: int</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a range representing the boundary of this
domain in a particular dimension.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.shape">
<em class="property">proc </em><code class="sig-name descname">shape</code><a class="headerlink" href="#ChapelArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of <a class="reference internal" href="#ChapelArray.intIdxType" title="ChapelArray.intIdxType"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">intIdxType</span></code></a> describing the size of each dimension.
For a sparse domain, return the shape of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.clear">
<em class="property">proc </em><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all indices from this domain, leaving it empty</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.add">
<em class="property">proc </em><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">in i</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add index <code class="docutils literal notranslate"><span class="pre">i</span></code> to this domain. This method is also available
as the <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator.</p>
<p>The domain must be irregular.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.makeIndexBuffer">
<em class="property">proc </em><code class="sig-name descname">makeIndexBuffer</code><span class="sig-paren">(</span><em class="sig-param">size: int</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.makeIndexBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an index buffer which can be used for faster index addition.</p>
<p>For example, instead of:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsDom</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">someIndexIterator</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">spsDom</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>You can use <cite>SparseIndexBuffer</cite> for better performance:</p>
<blockquote>
<div><div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsDom</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">idxBuf</span> <span class="o">=</span> <span class="nx">spsDom</span><span class="p">.</span><span class="nx">makeIndexBuffer</span><span class="p">(</span><span class="nx">size</span><span class="o">=</span><span class="nx">N</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="nx">someIndexIterator</span><span class="p">()</span> <span class="k">do</span>
  <span class="nx">idxBuf</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="nx">idxBuf</span><span class="p">.</span><span class="nx">commit</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
<p>The above snippet will create a buffer of size N indices, and will
automatically commit indices to the sparse domain as the buffer fills up.
Indices are also committed when the buffer goes out of scope.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The interface and implementation is not stable and may change in the
future.</p>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>size</strong> : <em>int</em> – Size of the buffer in number of indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.bulkAdd">
<em class="property">proc </em><code class="sig-name descname">bulkAdd</code><span class="sig-paren">(</span><em class="sig-param">inds: [] _value.rank*(_value.idxType)</em>, <em class="sig-param">dataSorted = false</em>, <em class="sig-param">isUnique = false</em>, <em class="sig-param">preserveInds = true</em>, <em class="sig-param">addOn = nilLocale</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.bulkAdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds indices in <code class="docutils literal notranslate"><span class="pre">inds</span></code> to this domain in bulk.</p>
<p>For sparse domains, an operation equivalent to this method is available
with the <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator, where the right-hand-side is an array. However,
in that case, default values will be used for the flags <code class="docutils literal notranslate"><span class="pre">dataSorted</span></code>,
<code class="docutils literal notranslate"><span class="pre">isUnique</span></code>, and <code class="docutils literal notranslate"><span class="pre">preserveInds</span></code>. This method is available because in
some cases, expensive operations can be avoided by setting those flags.
To do so, <code class="docutils literal notranslate"><span class="pre">bulkAdd</span></code> must be called explicitly (instead of <code class="docutils literal notranslate"><span class="pre">+=</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Right now, this method and the corresponding <code class="docutils literal notranslate"><span class="pre">+=</span></code> operator are
only available for sparse domains. In the future, we expect that
these methods will be available for all irregular domains.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">nilLocale</span></code> is a sentinel value to denote that the locale where this
addition should occur is unknown. We expect this to change in the
future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inds</strong> – Indices to be added. <code class="docutils literal notranslate"><span class="pre">inds</span></code> can be an array of
<code class="docutils literal notranslate"><span class="pre">rank*idxType</span></code> or an array of <code class="docutils literal notranslate"><span class="pre">idxType</span></code> for
1-D domains.</p></li>
<li><p><strong>dataSorted</strong> : <em>bool</em> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> is sorted.</p></li>
<li><p><strong>isUnique</strong> : <em>bool</em> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> has no duplicates.</p></li>
<li><p><strong>preserveInds</strong> : <em>bool</em> – <code class="docutils literal notranslate"><span class="pre">true</span></code> if data in <code class="docutils literal notranslate"><span class="pre">inds</span></code> needs to be preserved.</p></li>
<li><p><strong>addOn</strong> : <em>locale</em> – The locale where the indices should be added. Default value
is <code class="docutils literal notranslate"><span class="pre">nil</span></code> which indicates that locale is unknown or there
are more than one.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of indices added to the domain</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.remove">
<em class="property">proc </em><code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove index <code class="docutils literal notranslate"><span class="pre">i</span></code> from this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.requestCapacity">
<em class="property">proc </em><code class="sig-name descname">requestCapacity</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.requestCapacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Request space for a particular number of values in an
domain.</p>
<p>Currently only applies to associative domains.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.size">
<em class="property">proc </em><code class="sig-name descname">size</code><a class="headerlink" href="#ChapelArray.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of indices in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.low">
<em class="property">proc </em><code class="sig-name descname">low</code><a class="headerlink" href="#ChapelArray.low" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lowest index in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.high">
<em class="property">proc </em><code class="sig-name descname">high</code><a class="headerlink" href="#ChapelArray.high" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest index in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.stride">
<em class="property">proc </em><code class="sig-name descname">stride</code><a class="headerlink" href="#ChapelArray.stride" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the stride of the indices in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.alignment">
<em class="property">proc </em><code class="sig-name descname">alignment</code><a class="headerlink" href="#ChapelArray.alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alignment of the indices in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.first">
<em class="property">proc </em><code class="sig-name descname">first</code><a class="headerlink" href="#ChapelArray.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first index in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.last">
<em class="property">proc </em><code class="sig-name descname">last</code><a class="headerlink" href="#ChapelArray.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last index in this domain</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.alignedLow">
<em class="property">proc </em><code class="sig-name descname">alignedLow</code><a class="headerlink" href="#ChapelArray.alignedLow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the low index in this domain factoring in alignment</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.alignedHigh">
<em class="property">proc </em><code class="sig-name descname">alignedHigh</code><a class="headerlink" href="#ChapelArray.alignedHigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the high index in this domain factoring in alignment</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.contains">
<em class="property">proc </em><code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">i: _value.idxType ...rank</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if this domain contains <code class="docutils literal notranslate"><span class="pre">i</span></code>. Otherwise return false.
For sparse domains, only indices with a value are considered
to be contained in the domain.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.isSubset">
<em class="property">proc </em><code class="sig-name descname">isSubset</code><span class="sig-paren">(</span><em class="sig-param">super: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.isSubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if this domain is a subset of <code class="docutils literal notranslate"><span class="pre">super</span></code>. Otherwise
returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.isSuper">
<em class="property">proc </em><code class="sig-name descname">isSuper</code><span class="sig-paren">(</span><em class="sig-param">sub: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.isSuper" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if this domain is a superset of <code class="docutils literal notranslate"><span class="pre">sub</span></code>. Otherwise
returns false.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.orderToIndex">
<em class="property">proc </em><code class="sig-name descname">orderToIndex</code><span class="sig-paren">(</span><em class="sig-param">order: int</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.orderToIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <cite>ith</cite> index in the domain counting from 0.
For example, <code class="docutils literal notranslate"><span class="pre">{2..10</span> <span class="pre">by</span> <span class="pre">2}.orderToIndex(2)</span></code> would return <code class="docutils literal notranslate"><span class="pre">6</span></code>.</p>
<p>The order of a multidimensional domain follows its serial iterator.
For example, <code class="docutils literal notranslate"><span class="pre">{1..3,</span> <span class="pre">1..2}.orderToIndex(3)</span></code> would return <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Right now, this method supports only dense rectangular domains with
numeric indices</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>order</strong> – Order for which the corresponding index in the domain
has to be found.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Domain index for a given order in the domain.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.expand">
<em class="property">proc </em><code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param">off: rank*(intIdxType)</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new domain that is the current domain expanded by
<code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in dimension <code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is positive or
contracted by <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in dimension <code class="docutils literal notranslate"><span class="pre">d</span></code> if <code class="docutils literal notranslate"><span class="pre">off(d)</span></code>
is negative.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param">off: intIdxType</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new domain that is the current domain expanded by
<code class="docutils literal notranslate"><span class="pre">off</span></code> in all dimensions if <code class="docutils literal notranslate"><span class="pre">off</span></code> is positive or contracted
by <code class="docutils literal notranslate"><span class="pre">off</span></code> in all dimensions if <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.exterior">
<em class="property">proc </em><code class="sig-name descname">exterior</code><span class="sig-paren">(</span><em class="sig-param">off: rank*(intIdxType)</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.exterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new domain that is the exterior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>.
If <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the exterior from the low
bound of the dimension; if positive, compute the exterior
from the high bound.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">exterior</code><span class="sig-paren">(</span><em class="sig-param">off: intIdxType</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new domain that is the exterior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off</span></code> indices for each dimension.
If <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative, compute the exterior from the low
bound of the dimension; if positive, compute the exterior
from the high bound.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.interior">
<em class="property">proc </em><code class="sig-name descname">interior</code><span class="sig-paren">(</span><em class="sig-param">off: rank*(intIdxType)</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.interior" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new domain that is the interior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> indices for each dimension
<code class="docutils literal notranslate"><span class="pre">d</span></code>. If <code class="docutils literal notranslate"><span class="pre">off(d)</span></code> is negative, compute the interior from
the low bound of the dimension; if positive, compute the
interior from the high bound.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">interior</code><span class="sig-paren">(</span><em class="sig-param">off: intIdxType</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new domain that is the interior portion of the
current domain with <code class="docutils literal notranslate"><span class="pre">off</span></code> indices for each dimension.
If <code class="docutils literal notranslate"><span class="pre">off</span></code> is negative, compute the interior from the low
bound of the dimension; if positive, compute the interior
from the high bound.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.translate">
<em class="property">proc </em><code class="sig-name descname">translate</code><span class="sig-paren">(</span><em class="sig-param">off</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new domain that is the current domain translated by
<code class="docutils literal notranslate"><span class="pre">off(d)</span></code> in each dimension <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">translate</code><span class="sig-paren">(</span><em class="sig-param">off</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new domain that is the current domain translated by
<code class="docutils literal notranslate"><span class="pre">off</span></code> in each dimension.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.isEmpty">
<em class="property">proc </em><code class="sig-name descname">isEmpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#ChapelArray.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the domain has no indices</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.localSlice">
<em class="property">proc </em><code class="sig-name descname">localSlice</code><span class="sig-paren">(</span><em class="sig-param">r ...rank</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.localSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a local view of the sub-array (slice) defined by the provided
range(s), halting if the slice contains elements that are not local.</p>
<p>Indexing into this local view is cheaper, because the indices are known
to be local.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">localSlice</code><span class="sig-paren">(</span><em class="sig-param">d: domain</em><span class="sig-paren">)</span></dt>
<dd><p>Return a local view of the sub-array (slice) defined by the provided
domain, halting if the slice contains elements that are not local.</p>
<p>Indexing into this local view is cheaper, because the indices are known
to be local.</p>
</dd></dl>

<dl class="chpl itermethod">
<dt id="ChapelArray.sorted">
<em class="property">iter </em><code class="sig-name descname">sorted</code><span class="sig-paren">(</span><em class="sig-param">comparator: ?t = chpl_defaultComparator()</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the domain indices in sorted order</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.safeCast">
<em class="property">proc </em><code class="sig-name descname">safeCast</code><span class="sig-paren">(</span><em class="sig-param">type t: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.safeCast" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast a rectangular domain to another rectangular domain type.
If the old type is stridable and the new type is not stridable,
ensure that the stride was 1.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.targetLocales">
<em class="property">proc </em><code class="sig-name descname">targetLocales</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const ref<a class="headerlink" href="#ChapelArray.targetLocales" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of locales over which this domain has been distributed.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.hasSingleLocalSubdomain">
<em class="property">proc </em><code class="sig-name descname">hasSingleLocalSubdomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.hasSingleLocalSubdomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the local subdomain can be represented as a single
domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.localSubdomain">
<em class="property">proc </em><code class="sig-name descname">localSubdomain</code><span class="sig-paren">(</span><em class="sig-param">loc: locale = here</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.localSubdomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the subdomain that is local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <em>locale</em> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt id="ChapelArray.localSubdomains">
<em class="property">iter </em><code class="sig-name descname">localSubdomains</code><span class="sig-paren">(</span><em class="sig-param">loc: locale = here</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.localSubdomains" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the subdomains that are local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <em>locale</em> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.supportsAutoLocalAccess">
<em class="property">proc </em><code class="sig-name descname">supportsAutoLocalAccess</code><span class="sig-paren">(</span><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.supportsAutoLocalAccess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl type">
<dt id="ChapelArray.array">
<em class="property">type </em><code class="sig-name descname">array</code><a class="headerlink" href="#ChapelArray.array" title="Permalink to this definition">¶</a></dt>
<dd><p>The array type</p>
<dl class="chpl method">
<dt id="ChapelArray.eltType">
<em class="property">proc </em><code class="sig-name descname">eltType</code> type<a class="headerlink" href="#ChapelArray.eltType" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of elements contained in the array</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">idxType</code> type</dt>
<dd><p>The type of indices used in the array’s domain</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">rank</code> param</dt>
<dd><p>The number of dimensions in the array</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.indices">
<em class="property">proc </em><code class="sig-name descname">indices</code><a class="headerlink" href="#ChapelArray.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>return the array’s indices as its domain</p>
</dd></dl>

<dl class="chpl itermethod">
<dt>
<em class="property">iter </em><code class="sig-name descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span> ref</dt>
<dd><p>Yield the array elements</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">size</code></dt>
<dd><p>Return the number of elements in the array</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.reindex">
<em class="property">proc </em><code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">newDomain: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array view over a new domain. The new domain must be
of the same rank and size as the original array’s domain.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">D</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="o">..</span><span class="mi">15</span><span class="p">};</span>
<span class="kd">ref</span> <span class="nx">reA</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">reindex</span><span class="p">(</span><span class="nx">D</span><span class="p">);</span>
<span class="nx">reA</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// updates A[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">newDims ...</em><span class="sig-paren">)</span></dt>
<dd><p>Return an array view over a new domain defined implicitly
by one or more <cite>newDims</cite>, which must be ranges. The new domain must be
of the same rank and size as the original array’s domain.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">A</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="kd">ref</span> <span class="nx">reA</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">reindex</span><span class="p">(</span><span class="mi">13</span><span class="o">..</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="o">..</span><span class="mi">16</span><span class="p">);</span>
<span class="nx">reA</span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// updates A[3,5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.IRV">
<em class="property">proc </em><code class="sig-name descname">IRV</code><a class="headerlink" href="#ChapelArray.IRV" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Implicitly Represented Value for sparse arrays</p>
</dd></dl>

<dl class="chpl itermethod">
<dt>
<em class="property">iter </em><code class="sig-name descname">sorted</code><span class="sig-paren">(</span><em class="sig-param">comparator: ?t = chpl_defaultComparator()</em><span class="sig-paren">)</span></dt>
<dd><p>Yield the array elements in sorted order.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">targetLocales</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const ref</dt>
<dd><p>Return an array of locales over which this array has been distributed.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">hasSingleLocalSubdomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span> param</dt>
<dd><p>Return true if the local subdomain can be represented as a single
domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">localSubdomain</code><span class="sig-paren">(</span><em class="sig-param">loc: locale = here</em><span class="sig-paren">)</span></dt>
<dd><p>Return the subdomain that is local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <em>locale</em> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt>
<em class="property">iter </em><code class="sig-name descname">localSubdomains</code><span class="sig-paren">(</span><em class="sig-param">loc: locale = here</em><span class="sig-paren">)</span></dt>
<dd><p>Yield the subdomains that are local to <cite>loc</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>loc</strong> : <em>locale</em> – indicates the locale for which the query should take
place (defaults to <cite>here</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">isEmpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool</dt>
<dd><p>Return true if the array has no elements</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.back">
<em class="property">proc </em><code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.back" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last element in the array. The array must be a
rectangular 1-D array.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.front">
<em class="property">proc </em><code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.front" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first element in the array. The array must be a
rectangular 1-D array.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.reverse">
<em class="property">proc </em><code class="sig-name descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of the values in the array.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.find">
<em class="property">proc </em><code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">val: this.eltType</em><span class="sig-paren">)</span>: (bool, index(this.domain))<a class="headerlink" href="#ChapelArray.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple containing <code class="docutils literal notranslate"><span class="pre">true</span></code> and the index of the first
instance of <code class="docutils literal notranslate"><span class="pre">val</span></code> in the array, or if <code class="docutils literal notranslate"><span class="pre">val</span></code> is not found, a
tuple containing <code class="docutils literal notranslate"><span class="pre">false</span></code> and an unspecified value is returned.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.count">
<em class="property">proc </em><code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">val: this.eltType</em><span class="sig-paren">)</span>: int<a class="headerlink" href="#ChapelArray.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal notranslate"><span class="pre">val</span></code> occurs in the array.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">shape</code></dt>
<dd><p>Return a tuple of integers describing the size of each dimension.
For a sparse array, returns the shape of the parent domain.</p>
</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.iteratorYieldsLocalElements">
<em class="property">proc </em><code class="sig-name descname">iteratorYieldsLocalElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.iteratorYieldsLocalElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="ChapelArray.array.equals">
<em class="property">proc </em><code class="sig-prename descclassname">array.</code><code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param">that: []</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#ChapelArray.array.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if all this array is the same size and shape
as argument <code class="docutils literal notranslate"><span class="pre">that</span></code> and all elements of this array are
equal to the corresponding element in <code class="docutils literal notranslate"><span class="pre">that</span></code>. Otherwise
return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isDmapType">
<em class="property">proc </em><code class="sig-name descname">isDmapType</code><span class="sig-paren">(</span><em class="sig-param">type t</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isDmapType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a domain map type. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isDmapValue">
<em class="property">proc </em><code class="sig-name descname">isDmapValue</code><span class="sig-paren">(</span><em class="sig-param">e</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isDmapValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a domain map. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isDomainType">
<em class="property">proc </em><code class="sig-name descname">isDomainType</code><span class="sig-paren">(</span><em class="sig-param">type t</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isDomainType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a domain type. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isDomainValue">
<em class="property">proc </em><code class="sig-name descname">isDomainValue</code><span class="sig-paren">(</span><em class="sig-param">e</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isDomainValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a domain. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isArrayType">
<em class="property">proc </em><code class="sig-name descname">isArrayType</code><span class="sig-paren">(</span><em class="sig-param">type t</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isArrayType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">t</span></code> is an array type. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.isArrayValue">
<em class="property">proc </em><code class="sig-name descname">isArrayValue</code><span class="sig-paren">(</span><em class="sig-param">e</em><span class="sig-paren">)</span> param<a class="headerlink" href="#ChapelArray.isArrayValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is an array. Otherwise return false.</p>
</dd></dl>

<dl class="chpl function">
<dt id="ChapelArray.reshape">
<em class="property">proc </em><code class="sig-name descname">reshape</code><span class="sig-paren">(</span><em class="sig-param">A: []</em>, <em class="sig-param">D: domain</em><span class="sig-paren">)</span><a class="headerlink" href="#ChapelArray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array <code class="docutils literal notranslate"><span class="pre">A</span></code> containing the same values but
in the shape of the domain <code class="docutils literal notranslate"><span class="pre">D</span></code>. The number of indices in the
domain must equal the number of elements in the array. The
elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> are copied into the new array using the
default iteration orders over <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ChapelComplex_forDocs.html" class="btn btn-neutral float-right" title="Complex" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Bytes.html" class="btn btn-neutral float-left" title="Bytes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>