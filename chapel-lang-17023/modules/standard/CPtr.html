

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>CPtr &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Spawn" href="Spawn.html" />
    <link rel="prev" title="DynamicIters" href="DynamicIters.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "modules/standard/CPtr";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#files-io">Files/IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">CPtr</a></li>
<li class="toctree-l3"><a class="reference internal" href="Spawn.html">Spawn</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sys.html">Sys</a></li>
<li class="toctree-l3"><a class="reference internal" href="SysBasic.html">SysBasic</a></li>
<li class="toctree-l3"><a class="reference internal" href="SysCTypes.html">SysCTypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="SysError.html">SysError</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#deprecated-modules">Deprecated Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
        
      <li>CPtr</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/standard/CPtr.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-CPtr"></span><div class="section" id="cptr">
<h1>CPtr<a class="headerlink" href="#cptr" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">CPtr</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">CPtr</span><span class="p">;</span>
</pre></div>
</div>
<p>This module contains Chapel types that can serve as C pointer
types for the purposes of interoperability and methods to work
with them.</p>
<p>See also <a class="reference internal" href="../../technotes/extern.html#readme-extern"><span class="std std-ref">C Interoperability</span></a>.</p>
<dl class="chpl type">
<dt id="CPtr.c_void_ptr">
<em class="property">type </em><code class="sig-name descname">c_void_ptr</code> = chpl__c_void_ptr<a class="headerlink" href="#CPtr.c_void_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>A Chapel type alias for ‘void*’ in C.</p>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_nil">
<em class="property">proc </em><code class="sig-name descname">c_nil</code>: c_void_ptr<a class="headerlink" href="#CPtr.c_nil" title="Permalink to this definition">¶</a></dt>
<dd><p>A Chapel version of a C NULL pointer.</p>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.is_c_nil">
<em class="property">proc </em><code class="sig-name descname">is_c_nil</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#CPtr.is_c_nil" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if the passed value is a NULL pointer (ie 0).</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl class">
<dt id="CPtr.c_ptr">
<em class="property">class </em><code class="sig-name descname">c_ptr</code><a class="headerlink" href="#CPtr.c_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a local C pointer for the purpose of C integration. This class
represents the equivalent to a C language pointer. Instances of this class
support assignment to other instances or nil, == or != comparison with a
<code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code> or with <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and casting to another <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code> type or to
the <code class="docutils literal notranslate"><span class="pre">c_void_ptr</span></code> type.</p>
<p>As with a Chapel class, a <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code> can be tested non-nil simply
by including it in an if statement conditional, like so:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">c_ptr</span> <span class="o">=</span> <span class="nx">c_ptrTo</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
<span class="k">if</span> <span class="nx">x</span> <span class="k">then</span> <span class="k">do</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;x is not nil&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="o">!</span><span class="nx">x</span> <span class="k">then</span> <span class="k">do</span> <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;x is nil&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Additionally, a <code class="docutils literal notranslate"><span class="pre">c_ptr</span></code> can be output like so:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">c_ptr</span> <span class="o">=</span> <span class="nx">c_ptrTo</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// outputs nil or e.g. 0xabc123000000</span>
</pre></div>
</div>
<dl class="chpl attribute">
<dt id="CPtr.c_ptr.eltType">
<em class="property">type </em><code class="sig-name descname">eltType</code><a class="headerlink" href="#CPtr.c_ptr.eltType" title="Permalink to this definition">¶</a></dt>
<dd><p>The type that this pointer points to</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_ptr.this">
<em class="property">proc </em><code class="sig-name descname">this</code><span class="sig-paren">(</span><em class="sig-param">i: integral</em><span class="sig-paren">)</span> ref<a class="headerlink" href="#CPtr.c_ptr.this" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the i’th element (zero based) from a pointer to an array.
Does the equivalent of ptr[i] in C.</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_ptr.deref">
<em class="property">proc </em><code class="sig-name descname">deref</code><span class="sig-paren">(</span><span class="sig-paren">)</span> ref<a class="headerlink" href="#CPtr.c_ptr.deref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get element pointed to directly by this pointer. If the pointer
refers to an array, this will return ptr[0].</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_ptr.writeThis">
<em class="property">proc </em><code class="sig-name descname">writeThis</code><span class="sig-paren">(</span><em class="sig-param">ch</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#CPtr.c_ptr.writeThis" title="Permalink to this definition">¶</a></dt>
<dd><p>Print this pointer</p>
</dd></dl>

</dd></dl>

<dl class="chpl record">
<dt id="CPtr.c_array">
<em class="property">record </em><code class="sig-name descname">c_array</code><a class="headerlink" href="#CPtr.c_array" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a C array with fixed size.  A variable of type c_array
can coerce to a c_ptr with the same element type.  In that event, the
pointer will be equivalent to <cite>c_ptrTo(array[0])</cite>.  A c_array behaves
similarly to a homogeneous tuple except that its indices start at 0 and it is
guaranteed to be stored in contiguous memory.  A c_array variable has value
semantics. Declaring one as a function local variable will create the array
elements in the function’s stack. Assigning or copy initializing will result
in copying the elements (vs resulting in two pointers that refer to the same
elements).  A <cite>nil</cite> c_array is not representable in Chapel.</p>
<dl class="chpl attribute">
<dt id="CPtr.c_array.eltType">
<em class="property">type </em><code class="sig-name descname">eltType</code><a class="headerlink" href="#CPtr.c_array.eltType" title="Permalink to this definition">¶</a></dt>
<dd><p>The array element type</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="CPtr.c_array.size">
<em class="property">param </em><code class="sig-name descname">size</code><a class="headerlink" href="#CPtr.c_array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The fixed number of elements</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_array.init">
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">param size</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_array.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_array.deinit">
<em class="property">proc </em><code class="sig-name descname">deinit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_array.deinit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt>
<code class="sig-name descname">proc ref this(i: integral) ref: eltType</code></dt>
<dd><p>Retrieve the i’th element (zero based) from the array.
Does the equivalent of arr[i] in C.
Includes bounds checking when such checks are enabled.</p>
</dd></dl>

<dl class="chpl method">
<dt>
<code class="sig-name descname">proc ref this(param i: integral) ref: eltType</code></dt>
<dd><p>As with the previous function, returns the i’th element (zero based)
from the array. This one emits a compilation error if i is out of bounds.</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_array.writeThis">
<em class="property">proc </em><code class="sig-name descname">writeThis</code><span class="sig-paren">(</span><em class="sig-param">ch</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#CPtr.c_array.writeThis" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the elements</p>
</dd></dl>

<dl class="chpl method">
<dt id="CPtr.c_array.init=">
<em class="property">proc </em><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">other: c_array</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_array.init=" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl function">
<dt id="CPtr.=">
<em class="property">proc </em><code class="sig-name descname">=</code><span class="sig-paren">(</span><em class="sig-param">ref lhs: c_array</em>, <em class="sig-param">rhs: c_array</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.=" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the elements from one c_array to another.
Raises an error at compile time if the array sizes or
element types do not match.</p>
</dd></dl>

<dl class="chpl function">
<dt>
<em class="property">proc </em><code class="sig-name descname">=</code><span class="sig-paren">(</span><em class="sig-param">ref lhs: c_ptr</em>, <em class="sig-param">ref rhs: c_array</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_ptrTo">
<em class="property">proc </em><code class="sig-name descname">c_ptrTo</code><span class="sig-paren">(</span><em class="sig-param">arr: []</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_ptrTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to the elements of a non-distributed
Chapel rectangular array.  Note that the existence of this
<a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a> has no impact on the lifetime of the array.  The
returned pointer will be invalid if the original array is freed or
even reallocated. Domain assignment could make this <a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a>
invalid.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>arr</strong> – the array for which a pointer should be returned</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pointer to the array’s elements</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<em class="property">proc </em><code class="sig-name descname">c_ptrTo</code><span class="sig-paren">(</span><em class="sig-param">ref x: ?t</em><span class="sig-paren">)</span>: c_ptr(t)</dt>
<dd><p>Returns a <a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a> to any Chapel object.
Note that the existence of the <a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a> has no impact of the lifetime
of the object. In many cases the object will be stack allocated and
could go out of scope even if this <a class="reference internal" href="#CPtr.c_ptr" title="CPtr.c_ptr"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">c_ptr</span></code></a> remains.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>x</strong> – the by-reference argument to get a pointer to. The argument should
not be an array or domain (there is a different overload for arrays).
Records, class instances, integral, real, imag, and complex types are
supported.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a pointer to the argument passed by reference</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_sizeof">
<em class="property">proc </em><code class="sig-name descname">c_sizeof</code><span class="sig-paren">(</span><em class="sig-param">type x</em><span class="sig-paren">)</span>: size_t<a class="headerlink" href="#CPtr.c_sizeof" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size in bytes of a type, as with the C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> built-in.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is intended for C interoperability. To enhance
flexibility, it is possible to request the sizes of Chapel types.
However, be aware:</p>
<blockquote>
<div><ul class="simple">
<li><p>Chapel types are not necessarily stored in contiguous memory</p></li>
<li><p>Behavior of <code class="docutils literal notranslate"><span class="pre">c_sizeof</span></code> with Chapel types may change</p></li>
<li><p>Behavior given a Chapel class type is not well-defined</p></li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_offsetof">
<em class="property">proc </em><code class="sig-name descname">c_offsetof</code><span class="sig-paren">(</span><em class="sig-param">type t</em>, <em class="sig-param">param fieldname: string</em><span class="sig-paren">)</span>: size_t<a class="headerlink" href="#CPtr.c_offsetof" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offset of a field in a record.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is intended for C interoperability.  To enhance flexibility,
it is possible to request the offset of elements within a Chapel record.
However, be aware:</p>
<ul class="simple">
<li><p>Chapel types are not necessary stored in contiguous memory</p></li>
<li><p>Behavior of <code class="docutils literal notranslate"><span class="pre">c_offsetof</span></code> may change</p></li>
<li><p>Behavior given a Chapel class type field is not well-defined</p></li>
</ul>
</div>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_calloc">
<em class="property">proc </em><code class="sig-name descname">c_calloc</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">size: integral</em><span class="sig-paren">)</span>: c_ptr(eltType)<a class="headerlink" href="#CPtr.c_calloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory and initialize all bits to 0. Note that this simply zeros
memory, it does not call Chapel initializers (it is meant for primitive
types and C interoperability only.) This memory should eventually be freed
with <a class="reference internal" href="#CPtr.c_free" title="CPtr.c_free"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_free</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eltType</strong> – the type of the elements to allocate</p></li>
<li><p><strong>size</strong> – the number of elements to allocate space for</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a c_ptr(eltType) to allocated memory</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_malloc">
<em class="property">proc </em><code class="sig-name descname">c_malloc</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">size: integral</em><span class="sig-paren">)</span>: c_ptr(eltType)<a class="headerlink" href="#CPtr.c_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory that is not initialized. This memory should eventually be
freed with <a class="reference internal" href="#CPtr.c_free" title="CPtr.c_free"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_free</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eltType</strong> – the type of the elements to allocate</p></li>
<li><p><strong>size</strong> – the number of elements to allocate space for</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a c_ptr(eltType) to allocated memory</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_aligned_alloc">
<em class="property">proc </em><code class="sig-name descname">c_aligned_alloc</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">alignment: integral</em>, <em class="sig-param">size: integral</em><span class="sig-paren">)</span>: c_ptr(eltType)<a class="headerlink" href="#CPtr.c_aligned_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate aligned memory that is not initialized. This memory
should be eventually freed with <a class="reference internal" href="#CPtr.c_free" title="CPtr.c_free"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_free</span></code></a>.</p>
<p>This function is intended to behave similarly to the C17
function aligned_alloc.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eltType</strong> – the type of the elements to allocate</p></li>
<li><p><strong>alignment</strong> – the memory alignment of the allocation
which must be a power of two and a multiple
of <code class="docutils literal notranslate"><span class="pre">c_sizeof(c_void_ptr)</span></code>.</p></li>
<li><p><strong>size</strong> – the number of elements to allocate space for</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <code class="docutils literal notranslate"><span class="pre">c_ptr(eltType)</span></code> to allocated memory</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_free">
<em class="property">proc </em><code class="sig-name descname">c_free</code><span class="sig-paren">(</span><em class="sig-param">data: c_void_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free memory that was allocated with <a class="reference internal" href="#CPtr.c_calloc" title="CPtr.c_calloc"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_calloc</span></code></a> or <a class="reference internal" href="#CPtr.c_malloc" title="CPtr.c_malloc"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_malloc</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>data</strong> – the c_ptr to memory that was allocated. Note that both
<cite>c_ptr(t)</cite> and <cite>c_void_ptr</cite> can be passed to this argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.isAnyCPtr">
<em class="property">proc </em><code class="sig-name descname">isAnyCPtr</code><span class="sig-paren">(</span><em class="sig-param">type t: c_ptr</em><span class="sig-paren">)</span> param<a class="headerlink" href="#CPtr.isAnyCPtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if t is a c_ptr type or c_void_ptr.</p>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_memmove">
<em class="property">proc </em><code class="sig-name descname">c_memmove</code><span class="sig-paren">(</span><em class="sig-param">dest: c_void_ptr</em>, <em class="sig-param">const src: c_void_ptr</em>, <em class="sig-param">n: integral</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_memmove" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies n potentially overlapping bytes from memory area src to memory
area dest.</p>
<p>This is a simple wrapper over the C <code class="docutils literal notranslate"><span class="pre">memmove()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dest</strong> – the destination memory area to copy to</p></li>
<li><p><strong>src</strong> – the source memory area to copy from</p></li>
<li><p><strong>n</strong> – the number of bytes from src to copy to dest</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_memcpy">
<em class="property">proc </em><code class="sig-name descname">c_memcpy</code><span class="sig-paren">(</span><em class="sig-param">dest: c_void_ptr</em>, <em class="sig-param">const src: c_void_ptr</em>, <em class="sig-param">n: integral</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies n non-overlapping bytes from memory area src to memory
area dest. Use <a class="reference internal" href="#CPtr.c_memmove" title="CPtr.c_memmove"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">c_memmove</span></code></a> if memory areas do overlap.</p>
<p>This is a simple wrapper over the C memcpy() function.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dest</strong> – the destination memory area to copy to</p></li>
<li><p><strong>src</strong> – the source memory area to copy from</p></li>
<li><p><strong>n</strong> – the number of bytes from src to copy to dest</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_memcmp">
<em class="property">proc </em><code class="sig-name descname">c_memcmp</code><span class="sig-paren">(</span><em class="sig-param">const s1: c_void_ptr</em>, <em class="sig-param">const s2: c_void_ptr</em>, <em class="sig-param">n: integral</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_memcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the first n bytes of memory areas s1 and s2</p>
<p>This is a simple wrapper over the C <code class="docutils literal notranslate"><span class="pre">memcmp()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>returns an integer less than, equal to, or greater than zero if
the first n bytes of s1 are found, respectively, to be less than,
to match, or be greater than the first n bytes of s2.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="CPtr.c_memset">
<em class="property">proc </em><code class="sig-name descname">c_memset</code><span class="sig-paren">(</span><em class="sig-param">s: c_void_ptr</em>, <em class="sig-param">c: integral</em>, <em class="sig-param">n: integral</em><span class="sig-paren">)</span><a class="headerlink" href="#CPtr.c_memset" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill bytes of memory with a particular byte value.</p>
<p>This is a simple wrapper over the C <code class="docutils literal notranslate"><span class="pre">memset()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – the destination memory area to fill</p></li>
<li><p><strong>c</strong> – the byte value to use</p></li>
<li><p><strong>n</strong> – the number of bytes of s to fill</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>s</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Spawn.html" class="btn btn-neutral float-right" title="Spawn" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="DynamicIters.html" class="btn btn-neutral float-left" title="DynamicIters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>