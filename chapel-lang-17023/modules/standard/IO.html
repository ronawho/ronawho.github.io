

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IO &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FormattedIO" href="IO/FormattedIO.html" />
    <link rel="prev" title="FileSystem" href="FileSystem.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "modules/standard/IO";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#files-io">Files/IO</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="FileSystem.html">FileSystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">IO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-overview">I/O Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-rationale">Design Rationale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-styles">I/O Styles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-channel-creation">Functions for Channel Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-of-channel-data-and-avoiding-data-races">Synchronization of Channel Data and Avoiding Data Races</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performing-i-o-with-channels">Performing I/O with Channels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-for-closing-channels">Functions for Closing Channels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-stdin-stdout-and-stderr-channels">The <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">stdout</span></code>, and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> Channels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ensuring-successful-i-o">Ensuring Successful I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correspondence-to-c-i-o">Correspondence to C I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#io-functions-and-types">IO Functions and Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Path.html">Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#deprecated-modules">Deprecated Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
        
      <li>IO</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/standard/IO.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-IO"></span><div class="section" id="io">
<h1>IO<a class="headerlink" href="#io" title="Permalink to this headline">Â¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">IO</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Submodules</strong></p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="IO/FormattedIO.html">FormattedIO</a></li>
</ul>
</div>
<p>Support for a variety of kinds of input and output.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All Chapel programs automatically include <a class="reference internal" href="ChapelIO.html#ChapelIO.write" title="ChapelIO.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">write</span></code></a>,
<a class="reference internal" href="ChapelIO.html#ChapelIO.writeln" title="ChapelIO.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writeln</span></code></a> and <a class="reference internal" href="ChapelIO.html#ChapelIO.writef" title="ChapelIO.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">writef</span></code></a>.</p>
</div>
<p>Input/output (I/O) facilities in Chapel include the types <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> and
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a>; the constants <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdin</span></code></a>, <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stdout</span></code></a> and
<a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">stderr</span></code></a>; the functions <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a>,
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a>, <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a>, <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a>,
<a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a>, and many others.</p>
<div class="section" id="i-o-overview">
<span id="about-io-overview"></span><h2>I/O Overview<a class="headerlink" href="#i-o-overview" title="Permalink to this headline">Â¶</a></h2>
<p>A <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> in Chapel identifies a file in the underlying operating
system.  Reads and writes to a file are done via one or more channels
associated with the file.  Each <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> uses a buffer to provide
sequential read or write access to its file, optionally starting at an offset.</p>
<p>For example, the following program opens a file and writes an integer to it:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// open the file &quot;test-file.txt&quot; for writing, creating it if</span>
<span class="c1">// it does not exist yet.</span>
<span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">iomode</span><span class="p">.</span><span class="nx">cw</span><span class="p">);</span>

<span class="c1">// create a writing channel starting at file offset 0</span>
<span class="c1">// (start and end offsets can be specified when creating the</span>
<span class="c1">// channel)</span>
<span class="kd">var</span> <span class="nx">myWritingChannel</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">writer</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

<span class="c1">// This function will write the human-readable text version of x;</span>
<span class="c1">// binary I/O is also possible.</span>
<span class="nx">myWritingChannel</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="c1">// Now test-file.txt contains:</span>
<span class="c1">// 17</span>
</pre></div>
</div>
<p>Then, the following program can be used to read the integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="c1">// open the file &quot;test-file.txt&quot; for reading only</span>
<span class="kd">var</span> <span class="nx">myFile</span> <span class="o">=</span> <span class="nx">open</span><span class="p">(</span><span class="s">&quot;test-file.txt&quot;</span><span class="p">,</span> <span class="nx">iomode</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span>

<span class="c1">// create a reading channel starting at file offset 0</span>
<span class="c1">// (start and end offsets can be specified when creating the</span>
<span class="c1">// channel)</span>
<span class="kd">var</span> <span class="nx">myReadingChannel</span> <span class="o">=</span> <span class="nx">myFile</span><span class="p">.</span><span class="nx">reader</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// Now read a textual integer. Note that the</span>
<span class="c1">// channel.read function returns a bool to indicate</span>
<span class="c1">// if it read something or if the end of the file</span>
<span class="c1">// was reached before something could be read.</span>
<span class="kd">var</span> <span class="nx">readSomething</span> <span class="o">=</span> <span class="nx">myReadingChannel</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Read integer &quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// prints out:</span>
<span class="c1">// 17</span>
</pre></div>
</div>
</div>
<div class="section" id="design-rationale">
<h2>Design Rationale<a class="headerlink" href="#design-rationale" title="Permalink to this headline">Â¶</a></h2>
<p>Since channels operate independently, concurrent I/O to the same open file is
possible without contending for locks.  Furthermore, since the channel (and not
the file) stores the current file offset, it is straightforward to create
programs that access the same open file in parallel. Note that such parallel
access is not possible in C when multiple threads are using the same <code class="docutils literal notranslate"><span class="pre">FILE*</span></code>
to write to different regions of a file because of the race condition between
<code class="docutils literal notranslate"><span class="pre">fseek</span></code> and <code class="docutils literal notranslate"><span class="pre">fwrite</span></code>. Because of these issues, Chapel programmers wishing
to perform I/O will need to know how to open files as well as create channels.</p>
</div>
<div class="section" id="i-o-styles">
<span id="about-io-styles"></span><h2>I/O Styles<a class="headerlink" href="#i-o-styles" title="Permalink to this headline">Â¶</a></h2>
<p>Reading and writing of Chapelâs basic types is regulated by an applicable
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.  In particular, the I/O style controls whether binary or
text I/O should be performed. For binary I/O it specifies, for example, byte
order and string encoding. For text I/O it specifies string representation; the
base, field width and precision for numeric types; and so on.  Each channel has
an associated I/O style.  It applies to all read/write operations on that
channel, except when the program specifies explicitly an I/O style for a
particular read or write.</p>
<p>See the definition for the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> type. This type represents I/O
styles and provides details on formatting and other representation choices.</p>
<p>The default value of the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> type is undefined.  However, the
compiler-generated constructor is available.  It can be used to generate the
default I/O style, with or without modifications. In addition, the function
<a class="reference internal" href="#IO.defaultIOStyle" title="IO.defaultIOStyle"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">defaultIOStyle</span></code></a> will return the default I/O style just as <code class="docutils literal notranslate"><span class="pre">new</span>
<span class="pre">iostyle()</span></code> will.</p>
<p>The I/O style for an I/O operation can be provided through an optional
<code class="docutils literal notranslate"><span class="pre">style=</span></code> argument in a variety of places:</p>
<blockquote>
<div><ul class="simple">
<li><p>when performing the I/O, e.g. in calls to <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a> or
<a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a></p></li>
<li><p>when creating the channel with <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a></p></li>
<li><p>or when creating the file with e.g. <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Note that <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a>, or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> will copy the fileâs I/O
style if a <code class="docutils literal notranslate"><span class="pre">style=</span></code> argument is not provided. Also note that I/O functions on
channels will by default use the I/O style stored with that channel.</p>
<p>A channelâs I/O style may be retrieved using <a class="reference internal" href="#IO.channel._style" title="IO.channel._style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._style</span></code></a> and set
using <a class="reference internal" href="#IO.channel._set_style" title="IO.channel._set_style"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._set_style</span></code></a>. These functions should only be called while
the channel lock is held, however. See <a class="reference internal" href="#about-io-channel-synchronization"><span class="std std-ref">Synchronization of Channel Data and Avoiding Data Races</span></a>
for more information on channel locks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> is work in progress: the fields and/or their types may
change. Among other changes, we expect to be replacing the types of some
multiple-choice fields from integral to enums.</p>
</div>
<p>As an example for specifying an I/O style, the code below specifies the minimum width for writing numbers so array elements are aligned in the output:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">stdout</span><span class="p">.</span><span class="nx">writeln</span><span class="p">(</span><span class="nx">MyArray</span><span class="p">,</span> <span class="k">new</span> <span class="nx">iostyle</span><span class="p">(</span><span class="nx">min_width</span><span class="o">=</span><span class="mi">10</span><span class="p">));</span>
</pre></div>
</div>
<p>I/O facilities in Chapel also include several other ways to control I/O
formatting. There is support for <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">formatted I/O</span></a>
with <a class="reference internal" href="IO/FormattedIO.html#FormattedIO.channel.readf" title="FormattedIO.channel.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.channel.readf</span></code></a> and <a class="reference internal" href="IO/FormattedIO.html#FormattedIO.channel.writef" title="FormattedIO.channel.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.channel.writef</span></code></a>.
Also note that record or class implementations can provide custom functions
implementing read or write operations for that type (see
<a class="reference internal" href="ChapelIO.html#readthis-writethis-readwritethis"><span class="std std-ref">The readThis(), writeThis(), and readWriteThis() Methods</span></a>).</p>
</div>
<div class="section" id="files">
<span id="about-io-files"></span><h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">Â¶</a></h2>
<p>There are several functions that open a file and return a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> including <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a>, <a class="reference internal" href="#IO.opentmp" title="IO.opentmp"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">opentmp</span></code></a>, <a class="reference internal" href="#IO.openmem" title="IO.openmem"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openmem</span></code></a>, <a class="reference internal" href="#IO.openfd" title="IO.openfd"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openfd</span></code></a>, and <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openfp</span></code></a>.</p>
<p>Once a file is open, it is necessary to create associated channel(s) - see
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> and <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> - to write to and/or read from the
file.</p>
<p>Use the <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> function to explicitly synchronize the file to
ensure that file data is committed to the fileâs underlying device for
persistence.</p>
<p>To release any resources associated with a file, it is necessary to first close
any channels using that file (with <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.close</span></code></a>) and then the file
itself (with <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a>).</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../../builtins/String.html#string-nonunicode"><span class="std std-ref">Escaped strings</span></a> can be used for paths on systems
where UTF-8 file names are not enforced.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="functions-for-channel-creation">
<span id="about-io-channel-creation"></span><h2>Functions for Channel Creation<a class="headerlink" href="#functions-for-channel-creation" title="Permalink to this headline">Â¶</a></h2>
<p><a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> creates a channel for writing to a file, and
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> create a channel for reading from a file.</p>
</div>
<div class="section" id="synchronization-of-channel-data-and-avoiding-data-races">
<span id="about-io-channel-synchronization"></span><h2>Synchronization of Channel Data and Avoiding Data Races<a class="headerlink" href="#synchronization-of-channel-data-and-avoiding-data-races" title="Permalink to this headline">Â¶</a></h2>
<p>Channels (and files) contain locks in order to keep their operation safe for
multiple tasks. When creating a channel, it is possible to disable the lock
(for performance reasons) by passing <code class="docutils literal notranslate"><span class="pre">locking=false</span></code> to e.g.  file.writer().
Some channel methods - in particular those beginning with the underscore -
should only be called on locked channels.  With these methods, it is possible
to get or set the channel style, or perform I/O âtransactionsâ (see
<a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a> and <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._mark</span></code></a>). To use these methods,
first lock the channel with <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.lock</span></code></a>, call the methods you need,
then unlock the channel with <a class="reference internal" href="#IO.channel.unlock" title="IO.channel.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.unlock</span></code></a>.
Note that in the future, we may move to alternative ways of calling
these functions that guarantee that they are not called on a channel
without the appropriate locking.</p>
<p>Besides data races that can occur if locking is not used in channels when it
should be, it is also possible for there to be data races on file data that is
buffered simultaneously in multiple channels.  The main way to avoid such data
races is the <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> synchronization operation.
<a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> will make all writes to the channel, if any, available to
concurrent viewers of its associated file, such as other channels or other
applications accessing this file concurrently. See the note below for
more details on the situation in which this kind of data race can occur.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since channels can buffer data until <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> is called, it is
possible to write programs that have undefined behaviour because of race
conditions on channel buffers. In particular, the problem comes up for
programs that make:</p>
<blockquote>
<div><ul class="simple">
<li><p>concurrent operations on multiple channels that operate on overlapping
regions of a file</p></li>
<li><p>where at least one of the overlapping channels is a writing channel</p></li>
<li><p>and where data could be stored more than one of the overlapping channelâs
buffers at the same time (ie, write and read ordering are not enforced
through <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> and other mean such as sync variables).</p></li>
</ul>
</div></blockquote>
<p>Note that it is possible in some cases to create a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that does
not allow multiple channels at different offsets. Channels created on such
files will not change the fileâs position based on a <code class="docutils literal notranslate"><span class="pre">start=</span></code> offset
arguments. Instead, each read or write operation will use the file
descriptorâs current position. Therefore, only one channel should be created
for files created in the following situations:</p>
<blockquote>
<div><ul class="simple">
<li><p>with <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openfp</span></code></a></p></li>
<li><p>with <a class="reference internal" href="#IO.openfd" title="IO.openfd"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openfd</span></code></a> when provided a non-seekable system file descriptor</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="performing-i-o-with-channels">
<h2>Performing I/O with Channels<a class="headerlink" href="#performing-i-o-with-channels" title="Permalink to this headline">Â¶</a></h2>
<p>Channels contain read and write methods, which are generic methods that can
read or write anything, and can also take optional arguments such as I/O style
or. These functions generally take any number of arguments and <cite>throw</cite>
if there was an error. See:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.channel.writeln" title="IO.channel.writeln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.writeln</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.channel.writebits" title="IO.channel.writebits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.writebits</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.channel.writef" title="FormattedIO.channel.writef"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.channel.writef</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
<li><p><a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readln</span></code></a></p></li>
<li><p><a class="reference internal" href="#IO.channel.readbits" title="IO.channel.readbits"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readbits</span></code></a></p></li>
<li><p><a class="reference internal" href="IO/FormattedIO.html#FormattedIO.channel.readf" title="FormattedIO.channel.readf"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FormattedIO.channel.readf</span></code></a> (see also <a class="reference internal" href="IO/FormattedIO.html#about-io-formatted-io"><span class="std std-ref">Formatted I/O</span></a>)</p></li>
</ul>
</div></blockquote>
<p>In addition, there are several convenient synonyms for <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a> and
<a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.channel.readwrite" title="IO.channel.readwrite"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readwrite</span></code></a></p></li>
<li><p>the <a class="reference internal" href="#operator">&lt;~&gt; operator</a></p></li>
</ul>
</div></blockquote>
<p>Sometimes itâs important to flush the buffer in a channel - to do that, use the
.flush() method. Flushing the buffer will make all writes available to other
applications or other views of the file (ie, it will call e.g. the OS call
pwrite).  It is also possible to close a channel, which will implicitly
flush it and release any buffer memory used by the channel.  Note that if you
need to ensure that data from a channel is on disk, youâll have to call
<a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> or <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.close</span></code></a> and then <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> on
the related file.</p>
</div>
<div class="section" id="functions-for-closing-channels">
<span id="about-io-closing-channels"></span><h2>Functions for Closing Channels<a class="headerlink" href="#functions-for-closing-channels" title="Permalink to this headline">Â¶</a></h2>
<p>A channel must be closed in order to free the resources allocated for it,
to ensure that data written to it is visible to other channels,
or to allow the associated file to be closed.</p>
<p>See <a class="reference internal" href="#IO.channel.close" title="IO.channel.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.close</span></code></a>.</p>
<p>It is an error to perform any I/O operations on a channel
that has been closed.
It is an error to close a file when it has channels that
have not been closed.</p>
<p>Files and channels are reference counted. Each file and channel is
closed automatically when no references to it remain. For example, if
a local variable is the only reference to a channel, the channel will
be closed when that variable goes out of scope.  Programs may also
close a file or channel explicitly.</p>
</div>
<div class="section" id="the-stdin-stdout-and-stderr-channels">
<span id="about-io-style"></span><h2>The <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">stdout</span></code>, and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> Channels<a class="headerlink" href="#the-stdin-stdout-and-stderr-channels" title="Permalink to this headline">Â¶</a></h2>
<p>Chapel provides the predefined channels <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a>, <a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a>, and
<a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> to access the corresponding operating system streams standard
input, standard output, and standard error.</p>
<p><a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> supports reading;
<a class="reference internal" href="#IO.stdout" title="IO.stdout"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference internal" href="#IO.stderr" title="IO.stderr"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stderr</span></code></a> support writing.</p>
<p>All three channels are safe to use concurrently.
Their typesâ <code class="docutils literal notranslate"><span class="pre">kind</span></code> argument is <code class="docutils literal notranslate"><span class="pre">dynamic</span></code></p>
</div>
<div class="section" id="error-handling">
<span id="about-io-error-handling"></span><h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">Â¶</a></h2>
<p>Most I/O routines throw a <a class="reference internal" href="SysError.html#SysError.SystemError" title="SysError.SystemError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SysError.SystemError</span></code></a>, and can be handled
appropriately with <code class="docutils literal notranslate"><span class="pre">try</span></code> and <code class="docutils literal notranslate"><span class="pre">catch</span></code>. For legacy reasons most I/O routines
can also can accept an optional <cite>error=</cite> argument.
In this documentation, <cite>SystemError</cite> may include both the
<a class="reference internal" href="SysError.html#SysError.SystemError" title="SysError.SystemError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SysError.SystemError</span></code></a> class proper and its subclasses.</p>
<p>Some of these subclasses commonly used within the I/O implementation include:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="SysError.html#SysError.EOFError" title="SysError.EOFError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SysError.EOFError</span></code></a> - the end of file was reached</p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="SysError.html#SysError.UnexpectedEOFError" title="SysError.UnexpectedEOFError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SysError.UnexpectedEOFError</span></code></a> - a read or write only returned</dt><dd><p>part of the requested data</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="SysError.html#SysError.BadFormatError" title="SysError.BadFormatError"><code class="xref chpl chpl-class docutils literal notranslate"><span class="pre">SysError.BadFormatError</span></code></a> - data read did not adhere to the</dt><dd><p>requested format</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Some of the legacy error codes used include:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="SysBasic.html#SysBasic.EILSEQ" title="SysBasic.EILSEQ"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">SysBasic.EILSEQ</span></code></a> - illegal multibyte sequence (e.g. there was a
UTF-8 format error)</p></li>
<li><p><a class="reference internal" href="SysBasic.html#SysBasic.EOVERFLOW" title="SysBasic.EOVERFLOW"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">SysBasic.EOVERFLOW</span></code></a> - data read did not fit into requested type
(e.g. reading 1000 into a <cite>uint(8)</cite>).</p></li>
</ul>
</div></blockquote>
<p>An error code can be converted to a string using the function
<a class="reference internal" href="SysError.html#SysError.errorToString" title="SysError.errorToString"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">errorToString</span></code></a>.</p>
</div>
<div class="section" id="ensuring-successful-i-o">
<span id="about-io-ensuring-successful-io"></span><h2>Ensuring Successful I/O<a class="headerlink" href="#ensuring-successful-i-o" title="Permalink to this headline">Â¶</a></h2>
<p>It is possible - in some situations - for I/O to fail without returning an
error. In cases where a programmer wants to be sure that there was no error
writing the data to disk, it is important to call <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> to make
sure that data has arrived on disk without an error. Many errors can be
reported with typical operation, but some errors can only be reported by the
system during <a class="reference internal" href="#IO.file.close" title="IO.file.close"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.close</span></code></a> or even <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>.</p>
<p>When a file (or channel) is closed, data written to that file will be written
to disk eventually by the operating system. If an application needs to be sure
that the data is immediately written to persistent storage, it should use
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> prior to closing the file.</p>
</div>
<div class="section" id="correspondence-to-c-i-o">
<h2>Correspondence to C I/O<a class="headerlink" href="#correspondence-to-c-i-o" title="Permalink to this headline">Â¶</a></h2>
<p>It is not possible to seek, read, or write to a file directly.
Create a channel to proceed.</p>
<p><a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> in Chapel has the same conceptual meaning as fflush() in
C.  However, fflush() is not necessarily called in channel.flush().  Unlike
fsync(), which is actually called in file.fsync() in Chapel.</p>
<p>The iomode constants in Chapel have the same meaning as the following
strings passed to fopen() in C:</p>
<blockquote>
<div><ul class="simple">
<li><p>iomode.r   ârâ</p></li>
<li><p>iomode.rw  âr+â</p></li>
<li><p>iomode.cw  âwâ</p></li>
<li><p>iomode.cwr âw+â</p></li>
</ul>
</div></blockquote>
<p>However, open() in Chapel does not necessarily invoke fopen().</p>
</div>
<div class="section" id="io-functions-and-types">
<h2>IO Functions and Types<a class="headerlink" href="#io-functions-and-types" title="Permalink to this headline">Â¶</a></h2>
<dl class="chpl enum">
<dt id="IO.iomode">
<em class="property">enum </em><code class="sig-name descname">iomode</code> { r = 1, cw = 2, rw = 3, cwr = 4 }<a class="headerlink" href="#IO.iomode" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iomode</span></code></a> type is an enum.
When used as arguments when opening files,
its constants have the following meaning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iomode.r</span></code> - open an existing file for reading.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomode.rw</span></code> - open an existing file for reading and writing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomode.cw</span></code> - create a new file for writing.
If the file already exists, its contents are removed
when the file is opened in this mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomode.cwr</span></code> - as with <code class="docutils literal notranslate"><span class="pre">iomode.cw</span></code> but reading from the
file is also allowed.</p></li>
</ul>
</dd></dl>

<dl class="chpl enum">
<dt id="IO.iokind">
<em class="property">enum </em><code class="sig-name descname">iokind</code> { dynamic = 0, native = 1, big = 2, little = 3 }<a class="headerlink" href="#IO.iokind" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> type is an enum. When used as arguments to the
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type, its constants have the following meaning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> means binary I/O with big-endian byte order is performed
when writing/reading basic types from the channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.little</span></code> means binary I/O with little-endian byte order
(similar to <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> but with little-endian byte order).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.native</span></code> means binary I/O in native byte order
(similar to <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code> but with the byte order that is native
to the target platform).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code> means that the applicable I/O style has full effect
and as a result the kind varies at runtime.</p></li>
</ul>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code>, <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code>, and
<code class="docutils literal notranslate"><span class="pre">iokind.native</span></code> the applicable <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> is consulted when
writing/reading strings, but not for other basic types.</p>
<p>There are synonyms available for these values:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#IO.iodynamic" title="IO.iodynamic"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iodynamic</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code></p></li>
<li><p><a class="reference internal" href="#IO.ionative" title="IO.ionative"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">ionative</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.native</span></code></p></li>
<li><p><a class="reference internal" href="#IO.iobig" title="IO.iobig"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iobig</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code></p></li>
<li><p><a class="reference internal" href="#IO.iolittle" title="IO.iolittle"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">iolittle</span></code></a> = <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code></p></li>
</ul>
</dd></dl>

<dl class="chpl data">
<dt id="IO.iodynamic">
<em class="property">param </em><code class="sig-name descname">iodynamic</code> = iokind.dynamic<a class="headerlink" href="#IO.iodynamic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.ionative">
<em class="property">param </em><code class="sig-name descname">ionative</code> = iokind.native<a class="headerlink" href="#IO.ionative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.native</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.iobig">
<em class="property">param </em><code class="sig-name descname">iobig</code> = iokind.big<a class="headerlink" href="#IO.iobig" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.big</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.iolittle">
<em class="property">param </em><code class="sig-name descname">iolittle</code> = iokind.little<a class="headerlink" href="#IO.iolittle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A synonym for <code class="docutils literal notranslate"><span class="pre">iokind.little</span></code>; see <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a></p>
</dd></dl>

<dl class="chpl enum">
<dt id="IO.iostringstyle">
<em class="property">enum </em><code class="sig-name descname">iostringstyle</code> { len1b_data = -1, len2b_data = -2, len4b_data = -4, len8b_data = -8, lenVb_data = -10, data_toeof = -65280, data_null = -256 }<a class="headerlink" href="#IO.iostringstyle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This enum contains values used to control binary I/O with strings
via the <code class="docutils literal notranslate"><span class="pre">str_style</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len1b_data</span></code> indicates a string format of 1 byte of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len2b_data</span></code> indicates a string format of 2 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len4b_data</span></code> indicates a string format of 4 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.len8b_data</span></code> indicates a string format of 8 bytes of
length followed by length bytes of string data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.lenVb_data</span></code> indicates a string format of a variable
number of bytes of length, encoded with high-bit meaning more bytes
of length follow, and where the 7-bits of length from each byte store
the 7-bit portions of the length in order from least-significant to
most-significant. This way of encoding a variable-byte length  matches
<a class="reference external" href="https://github.com/protocolbuffers/protobuf">Google Protocol Buffers</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.data_toeof</span></code> indicates a string format that contains
only the string data without any length or terminator. When reading,
this format will read a string until the end of the file is reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringstyle.data_null</span></code> indicates a string that is terminated
by a zero byte. It can be combined with other numeric
values to indicate a string terminated by a particular byte. For example,
to indicate a string terminated by <code class="docutils literal notranslate"><span class="pre">$</span></code> (which in ASCII has byte value 0x24),
one would use the value <code class="docutils literal notranslate"><span class="pre">iostringstyle.data_null|0x24</span></code>.</p></li>
<li><p>A positive and nonzero value indicates that a string of exactly that many
bytes should be read or written.</p></li>
</ul>
</dd></dl>

<dl class="chpl enum">
<dt id="IO.iostringformat">
<em class="property">enum </em><code class="sig-name descname">iostringformat</code> { word = 0, basic = 1, chpl = 2, json = 3, toend = 4, toeof = 5 }<a class="headerlink" href="#IO.iostringformat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This enum contains values used to control text I/O with strings
via the <code class="docutils literal notranslate"><span class="pre">string_format</span></code> field in <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.word</span></code> means string is as-is;
reading reads until whitespace. This is the default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.basic</span></code> means only escape <em>string_end</em> and <code class="docutils literal notranslate"><span class="pre">\</span></code>
with <code class="docutils literal notranslate"><span class="pre">\</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.chpl</span></code> means  escape <em>string_end</em>
<code class="docutils literal notranslate"><span class="pre">\</span></code> <code class="docutils literal notranslate"><span class="pre">'</span></code> <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> <code class="docutils literal notranslate"><span class="pre">\n</span></code> with <code class="docutils literal notranslate"><span class="pre">\</span></code> and
nonprinting characters <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">0xXY</span></code> with <code class="docutils literal notranslate"><span class="pre">\xXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.json</span></code> means  escape <em>string_end</em> <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">\</span></code>
with <code class="docutils literal notranslate"><span class="pre">\</span></code>, and nonprinting characters <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">\uABCD</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.toend</span></code> means string is as-is; reading reads until
<em>string_end</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iostringformat.toeof</span></code> means string is as-is; reading reads until
end of file</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="chpl function">
<dt id="IO.stringStyleTerminated">
<em class="property">proc </em><code class="sig-name descname">stringStyleTerminated</code><span class="sig-paren">(</span><em class="sig-param">terminator: uint(8)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleTerminated" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
particular byte.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>terminator</strong> â a byte value that the strings will be terminated by</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a value that indicates a string format where strings
are terminated by the terminator byte. This value is appropriate
to store in <a class="reference internal" href="#IO.iostyle.str_style" title="IO.iostyle.str_style"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">iostyle.str_style</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.stringStyleNullTerminated">
<em class="property">proc </em><code class="sig-name descname">stringStyleNullTerminated</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.stringStyleNullTerminated" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This method returns the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where strings are terminated by a
zero byte.</p>
</dd></dl>

<dl class="chpl function">
<dt id="IO.stringStyleWithLength">
<em class="property">proc </em><code class="sig-name descname">stringStyleWithLength</code><span class="sig-paren">(</span><em class="sig-param">lengthBytes: int</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.stringStyleWithLength" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the appropriate <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> <code class="docutils literal notranslate"><span class="pre">str_style</span></code> value
to indicate a string format where string data is preceded by a
<cite>lengthBytes</cite> of length. Only lengths of 1, 2, 4, or 8 are supported.
When <cite>lengthBytes</cite> is 0, the returned value indicates variable-byte length.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown for an unsupported value of <cite>lengthBytes</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl data">
<dt id="IO.IOHINT_NONE">
<em class="property">const </em><code class="sig-name descname">IOHINT_NONE</code> = 0: c_int<a class="headerlink" href="#IO.IOHINT_NONE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOHINT_NONE means normal operation, nothing special
to hint. Expect to use NONE most of the time.
The other hints can be bitwise-ORed in.</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.IOHINT_RANDOM">
<em class="property">const </em><code class="sig-name descname">IOHINT_RANDOM</code> = QIO_HINT_RANDOM<a class="headerlink" href="#IO.IOHINT_RANDOM" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOHINT_RANDOM means we expect random access to a file</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.IOHINT_SEQUENTIAL">
<em class="property">const </em><code class="sig-name descname">IOHINT_SEQUENTIAL</code> = QIO_HINT_SEQUENTIAL<a class="headerlink" href="#IO.IOHINT_SEQUENTIAL" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOHINT_SEQUENTIAL means expect sequential access. On
Linux, this should double the readahead.</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.IOHINT_CACHED">
<em class="property">const </em><code class="sig-name descname">IOHINT_CACHED</code> = QIO_HINT_CACHED<a class="headerlink" href="#IO.IOHINT_CACHED" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOHINT_CACHED means we expect the entire file
to be cached and/or we pull it in all at
once. May request readahead on the entire file.</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.IOHINT_PARALLEL">
<em class="property">const </em><code class="sig-name descname">IOHINT_PARALLEL</code> = QIO_HINT_PARALLEL<a class="headerlink" href="#IO.IOHINT_PARALLEL" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOHINT_PARALLEL means that we expect to have many
channels working with this file in parallel.
It might change the reading/writing implementation
to something more efficient in that scenario.</p>
</dd></dl>

<dl class="chpl record">
<dt id="IO.iostyle">
<em class="property">record </em><code class="sig-name descname">iostyle</code><a class="headerlink" href="#IO.iostyle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> type represents I/O styles
defining how Chapelâs basic types should be read or written.</p>
<p>See <a class="reference internal" href="#about-io-style"><span class="std std-ref">The stdin, stdout, and stderr Channels</span></a>.</p>
<dl class="chpl attribute">
<dt id="IO.iostyle.binary">
<em class="property">var </em><code class="sig-name descname">binary</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.binary" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Perform binary I/O? 1 - yes, 0 - no.
This field is ignored for <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> values other than <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.byteorder">
<em class="property">var </em><code class="sig-name descname">byteorder</code>: uint(8) = iokind.native: uint(8)<a class="headerlink" href="#IO.iostyle.byteorder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What byte order should we use when performing binary I/O?
This field is ignored for <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> values other than <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.
It should be set to a value in <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a>.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.str_style">
<em class="property">var </em><code class="sig-name descname">str_style</code>: int(64) = iostringstyle.data_toeof: int(64)<a class="headerlink" href="#IO.iostyle.str_style" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What string format should we use when writing strings
in binary mode? See <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostringstyle</span></code></a> for more information
on what the values of <code class="docutils literal notranslate"><span class="pre">str_style</span></code> mean.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.min_width_columns">
<em class="property">var </em><code class="sig-name descname">min_width_columns</code>: uint(32) = 0<a class="headerlink" href="#IO.iostyle.min_width_columns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When performing text I/O, pad out to this many columns</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.max_width_columns">
<em class="property">var </em><code class="sig-name descname">max_width_columns</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_columns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many columns</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.max_width_characters">
<em class="property">var </em><code class="sig-name descname">max_width_characters</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_characters" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many characters</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.max_width_bytes">
<em class="property">var </em><code class="sig-name descname">max_width_bytes</code>: uint(32) = max(uint(32))<a class="headerlink" href="#IO.iostyle.max_width_bytes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When performing text I/O, do not use more than this many bytes</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.string_start">
<em class="property">var </em><code class="sig-name descname">string_start</code>: style_char_t = 34<a class="headerlink" href="#IO.iostyle.string_start" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character do we start strings with, when appropriate? Default is â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.string_end">
<em class="property">var </em><code class="sig-name descname">string_end</code>: style_char_t = 34<a class="headerlink" href="#IO.iostyle.string_end" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character do we end strings with, when appropriate? Default is â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.string_format">
<em class="property">var </em><code class="sig-name descname">string_format</code>: uint(8) = iostringformat.word: uint(8)<a class="headerlink" href="#IO.iostyle.string_format" title="Permalink to this definition">Â¶</a></dt>
<dd><p>How should we format strings when performing text I/O?
See <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostringstyle</span></code></a> for more information
on what the values of <code class="docutils literal notranslate"><span class="pre">str_style</span></code> mean.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.bytes_prefix">
<em class="property">var </em><code class="sig-name descname">bytes_prefix</code>: style_char_t = 98<a class="headerlink" href="#IO.iostyle.bytes_prefix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character do we start bytes with, when appropriate? Default is â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.base">
<em class="property">var </em><code class="sig-name descname">base</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.base" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
what base should be used for the number? Default of 0 means decimal.
Bases 2, 8, 10, 16 are supported for integers. Bases 10 and 16
are supported for real values.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.point_char">
<em class="property">var </em><code class="sig-name descname">point_char</code>: style_char_t = 46<a class="headerlink" href="#IO.iostyle.point_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
how is the integer portion separated from the fractional portion?
Default is â.â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.exponent_char">
<em class="property">var </em><code class="sig-name descname">exponent_char</code>: style_char_t = 101<a class="headerlink" href="#IO.iostyle.exponent_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
how is the exponent written? Default is âeâ</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.other_exponent_char">
<em class="property">var </em><code class="sig-name descname">other_exponent_char</code>: style_char_t = 112<a class="headerlink" href="#IO.iostyle.other_exponent_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When reading or writing a numeric value in a text mode channel,
when base is &gt; 10, how is the exponent written? Default is âeâ</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.positive_char">
<em class="property">var </em><code class="sig-name descname">positive_char</code>: style_char_t = 43<a class="headerlink" href="#IO.iostyle.positive_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character denotes a positive number? Default is â+â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.negative_char">
<em class="property">var </em><code class="sig-name descname">negative_char</code>: style_char_t = 45<a class="headerlink" href="#IO.iostyle.negative_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character denotes a negative number? Default is â-â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.i_char">
<em class="property">var </em><code class="sig-name descname">i_char</code>: style_char_t = 105<a class="headerlink" href="#IO.iostyle.i_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What character follows an the imaginary number? Default is âiâ</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.prefix_base">
<em class="property">var </em><code class="sig-name descname">prefix_base</code>: uint(8) = 1<a class="headerlink" href="#IO.iostyle.prefix_base" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When writing in a base other than 10, should the prefix be used?
(e.g. hexadecimal numbers are prefixed with 0x)</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.pad_char">
<em class="property">var </em><code class="sig-name descname">pad_char</code>: style_char_t = 32<a class="headerlink" href="#IO.iostyle.pad_char" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When padding with spaces, which pad character to use? Default is â â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.showplus">
<em class="property">var </em><code class="sig-name descname">showplus</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.showplus" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When printing a positive numeric value, should the + be shown?</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.uppercase">
<em class="property">var </em><code class="sig-name descname">uppercase</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.uppercase" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When printing a numeric value in hexadecimal, should it be
uppercase?</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.leftjustify">
<em class="property">var </em><code class="sig-name descname">leftjustify</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.leftjustify" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When printing a numeric value in a field of specified width, should
the number be on the left (that is padded on the right?). The default
is to right-justify the number.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.showpoint">
<em class="property">var </em><code class="sig-name descname">showpoint</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.showpoint" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When printing an integral value using a real format, should a trailing
decimal point be included? If so, the value 0 will be written as â0.â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.showpointzero">
<em class="property">var </em><code class="sig-name descname">showpointzero</code>: uint(8) = 1<a class="headerlink" href="#IO.iostyle.showpointzero" title="Permalink to this definition">Â¶</a></dt>
<dd><p>When printing an integral value using a real format, should a trailing
decimal point and zero be included? If so, the value 0 will be written
as â0.0â</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.precision">
<em class="property">var </em><code class="sig-name descname">precision</code>: int(32) = -1<a class="headerlink" href="#IO.iostyle.precision" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Specifies the precision for real format conversions. See the description
of realfmt below.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.realfmt">
<em class="property">var </em><code class="sig-name descname">realfmt</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.realfmt" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Formatting of real numbers:</p>
<blockquote>
<div><ul class="simple">
<li><p>0 means  print out âprecisionâ number of significant digits
(%g in printf)</p></li>
<li><p>1 means  print out âprecisionâ number of digits after the decimal point
(%f)</p></li>
<li><p>2 means  always use exponential and âprecisionâ number of digits (%e)</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.complex_style">
<em class="property">var </em><code class="sig-name descname">complex_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.complex_style" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.array_style">
<em class="property">var </em><code class="sig-name descname">array_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.array_style" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.aggregate_style">
<em class="property">var </em><code class="sig-name descname">aggregate_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.aggregate_style" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="chpl attribute">
<dt id="IO.iostyle.tuple_style">
<em class="property">var </em><code class="sig-name descname">tuple_style</code>: uint(8) = 0<a class="headerlink" href="#IO.iostyle.tuple_style" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl function">
<dt id="IO.defaultIOStyle">
<em class="property">proc </em><code class="sig-name descname">defaultIOStyle</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.defaultIOStyle" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the default I/O style. See <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a>
and <a class="reference internal" href="#about-io-styles"><span class="std std-ref">I/O Styles</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.iostyle.native">
<em class="property">proc </em><code class="sig-prename descclassname">iostyle.</code><code class="sig-name descname">native</code><span class="sig-paren">(</span><em class="sig-param">str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.native" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in native byte order.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>str_style</strong> â see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.iostyle.big">
<em class="property">proc </em><code class="sig-prename descclassname">iostyle.</code><code class="sig-name descname">big</code><span class="sig-paren">(</span><em class="sig-param">str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.big" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in big-endian byte order.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>str_style</strong> â see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.iostyle.little">
<em class="property">proc </em><code class="sig-prename descclassname">iostyle.</code><code class="sig-name descname">little</code><span class="sig-paren">(</span><em class="sig-param">str_style: int(64) = stringStyleWithVariableLength()</em><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.little" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get an I/O style indicating binary I/O in little-endian byte order.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>str_style</strong> â see <a class="reference internal" href="#IO.iostringstyle" title="IO.iostringstyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostringstyle</span></code></a> - which format to use when reading
or writing strings. Defaults to variable-byte length.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.iostyle.text">
<em class="property">proc </em><code class="sig-prename descclassname">iostyle.</code><code class="sig-name descname">text</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.iostyle.text" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get an I/O style indicating text I/O.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the requested <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl type">
<dt id="IO.iohints">
<em class="property">type </em><code class="sig-name descname">iohints</code> = c_int<a class="headerlink" href="#IO.iohints" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A value of the <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a> type defines a set of hints about the I/O that
the file or channel will perform.  These hints may be used by the
implementation to select optimized versions of the I/O operations.</p>
<p>The <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a> type is implementation-defined.
The following <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a> constants are provided:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_NONE</span></code></a> defines an empty set, which provides no hints.</p></li>
<li><p><a class="reference internal" href="#IO.IOHINT_RANDOM" title="IO.IOHINT_RANDOM"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_RANDOM</span></code></a> suggests to expect random access.</p></li>
<li><p><a class="reference internal" href="#IO.IOHINT_SEQUENTIAL" title="IO.IOHINT_SEQUENTIAL"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_SEQUENTIAL</span></code></a> suggests to expect sequential access.</p></li>
<li><p><a class="reference internal" href="#IO.IOHINT_CACHED" title="IO.IOHINT_CACHED"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_CACHED</span></code></a> suggests that the file data is or should be
cached in memory, possibly all at once.</p></li>
<li><p><a class="reference internal" href="#IO.IOHINT_PARALLEL" title="IO.IOHINT_PARALLEL"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_PARALLEL</span></code></a> suggests to expect many channels
working with this file in parallel.</p></li>
</ul>
</div></blockquote>
<p>Other hints might be added in the future.</p>
<p>The following binary operators are defined on <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">|</span></code> for set union</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> for set intersection</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">==</span></code> for set equality</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1=</span></code> for set inequality</p></li>
</ul>
<p>When an <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a> formal has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a> type is undefined.</p>
</dd></dl>

<dl class="chpl record">
<dt id="IO.file">
<em class="property">record </em><code class="sig-name descname">file</code><a class="headerlink" href="#IO.file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type is implementation-defined.  A value of the
<a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type refers to the state that is used by the implementation to
identify and interact with the OS file.</p>
<p>When a <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> formal argument has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> type does not represent any OS file.
It is illegal to perform any I/O operations on the default value.</p>
<dl class="chpl method">
<dt id="IO.file.init">
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.init" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="IO.file.init=">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">x: file</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.init=" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="chpl method">
<dt id="IO.file.check">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">check</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.file.check" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Throw an error if <cite>this</cite> is not a valid representation of an OS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Indicates that <cite>this</cite> does not represent an OS file.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.close">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.file.close" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Close a file.</p>
<p>In order to free the resources allocated for a file, it
must be closed using this method.</p>
<p>Closing a file does not guarantee immediate persistence of the performed
updates, if any. In cases where immediate persistence is important,
<a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a> should be used for that purpose prior to closing the file.
In particular, even though closing the file might complete without errors,
the data written might not persist in the event of a severe error like
running out of storage space or power loss. See also
<a class="reference internal" href="#about-io-ensuring-successful-io"><span class="std std-ref">Ensuring Successful I/O</span></a>.</p>
<p>Files are automatically closed when the file variable
goes out of scope and all channels using that file are closed. Programs
may also explicitly close a file using this method.</p>
<p>It is an error to perform any I/O operations on a file that has been closed.
It is an error to close a file when it has channels that have not been closed.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the file could not be closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.fsync">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">fsync</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.file.fsync" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sync a file to disk.</p>
<p>Commits file data to the device associated with this file.
Data written to the file by a channel will be committed
only if the channel has been closed or flushed.</p>
<p>This function will typically call the <code class="docutils literal notranslate"><span class="pre">fsync</span></code> system call.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the file could not be synced.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.path">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">path</code>: string throws<a class="headerlink" href="#IO.file.path" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the path to an open file.</p>
<p>Note that not all files have a path (e.g. files opened with <a class="reference internal" href="#IO.openmem" title="IO.openmem"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openmem</span></code></a>),
and that this function may not work on all operating systems.</p>
<p>The function <a class="reference internal" href="Path.html#Path.file.realPath" title="Path.file.realPath"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">Path.file.realPath</span></code></a> is an alternative way
to get the path to a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the path could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.tryGetPath">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">tryGetPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.file.tryGetPath" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the path to an open file, or return âunknownâ if there was
a problem getting the path to the open file.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.size">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">size</code>: int(64) throws<a class="headerlink" href="#IO.file.size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the current size of an open file. Note that the size can always
change if other channels, tasks or programs are writing to the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the current file size</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â Thrown if the size could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.open">
<em class="property">proc </em><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">path: string</em>, <em class="sig-param">mode: iomode</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file throws<a class="headerlink" href="#IO.open" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Open a file on a filesystem. Note that once the
file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a>
to create a channel to actually perform I/O operations</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> â which file to open (for example, âsome/file.txtâ).</p></li>
<li><p><strong>mode</strong> â specify whether to open the file for reading or writing and
whether or not to create the file if it doesnât exist.
See <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iomode</span></code></a>.</p></li>
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
<li><p><strong>style</strong> â optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open file to the requested resource.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.openfd">
<em class="property">proc </em><code class="sig-name descname">openfd</code><span class="sig-paren">(</span><em class="sig-param">fd: fd_t</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file throws<a class="headerlink" href="#IO.openfd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a Chapel file that works with a system file descriptor  Note that once
the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a channel to actually perform I/O operations</p>
<p>The system file descriptor will be closed when the Chapel file is closed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function can be used to create Chapel files that refer to system file
descriptors that do not support the <code class="docutils literal notranslate"><span class="pre">seek</span></code> functionality. For example, file
descriptors that represent pipes or open socket connections have this
property. In that case, the resulting file value should only be used with one
<a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> at a time.
The I/O system will ignore the channel offsets when reading or writing
to files backed by non-seekable file descriptors.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fd</strong> â a system file descriptor (obtained with <a class="reference internal" href="Sys.html#Sys.sys_open" title="Sys.sys_open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">Sys.sys_open</span></code></a> or
<a class="reference internal" href="Sys.html#Sys.sys_connect" title="Sys.sys_connect"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">Sys.sys_connect</span></code></a> for example).</p></li>
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
<li><p><strong>style</strong> â optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> using the specified file descriptor.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the file descriptor could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.openfp">
<em class="property">proc </em><code class="sig-name descname">openfp</code><span class="sig-paren">(</span><em class="sig-param">fp: _file</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file throws<a class="headerlink" href="#IO.openfp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a Chapel file that works with an open C file (ie a <code class="docutils literal notranslate"><span class="pre">FILE*</span></code>).  Note
that once the file is open, you will need to use a <a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a channel to actually perform I/O operations</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The resulting file value should only be used with one <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> at a
time. The I/O system will ignore the channel offsets when reading or writing
to a file opened with <a class="reference internal" href="#IO.openfp" title="IO.openfp"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">openfp</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fp</strong> â a C <code class="docutils literal notranslate"><span class="pre">FILE*</span></code> to work with</p></li>
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
<li><p><strong>style</strong> â optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> that uses the underlying FILE* argument.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the C file could not be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.opentmp">
<em class="property">proc </em><code class="sig-name descname">opentmp</code><span class="sig-paren">(</span><em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file throws<a class="headerlink" href="#IO.opentmp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Open a temporary file. Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a channel to actually
perform I/O operations.</p>
<p>The temporary file will be created in an OS-dependent temporary directory,
for example â/tmpâ is the typical location. The temporary file will be
deleted upon closing.</p>
<p>Temporary files are always opened with <a class="reference internal" href="#IO.iomode" title="IO.iomode"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iomode</span></code></a> <code class="docutils literal notranslate"><span class="pre">iomode.cwr</span></code>;
that is, a new file is created that supports both writing and reading.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
<li><p><strong>style</strong> â optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open temporary file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the temporary file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.openmem">
<em class="property">proc </em><code class="sig-name descname">openmem</code><span class="sig-paren">(</span><em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: file throws<a class="headerlink" href="#IO.openmem" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Open a file that is backed by a buffer in memory that will not persist when the
file is closed.  Note that once the file is open, you will need to use a
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> or <a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> to create a channel to actually
perform I/O operations.</p>
<p>The resulting file supports both reading and writing.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>style</strong> â optional argument to specify I/O style associated with this file.
The provided style will be the default for any channels created for
on this file, and that in turn will be the default for all I/O
operations performed with those channels.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open memory file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the memory buffered file could not be opened.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl record">
<dt id="IO.channel">
<em class="property">record </em><code class="sig-name descname">channel</code><a class="headerlink" href="#IO.channel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A channel supports either sequential reading or sequential writing to an
underlying <a class="reference internal" href="#IO.file" title="IO.file"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">file</span></code></a> object. A channel can buffer data. Read operations
on the channel might return old data. Write operations might not have an
immediate effect. Use <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> to control this buffering.</p>
<p>The <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type is implementation-defined.
A value of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type refers to the state that is used
to implement the channel operations.</p>
<p>When a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> formal has default intent, the
actual is copied to the formal upon a function call and
the formal cannot be assigned within the function.</p>
<p>The default value of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type is not associated
with any file and so cannot be used to perform I/O.</p>
<p>The <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type is generic.</p>
<dl class="chpl attribute">
<dt id="IO.channel.writing">
<em class="property">param </em><code class="sig-name descname">writing</code>: bool<a class="headerlink" href="#IO.channel.writing" title="Permalink to this definition">Â¶</a></dt>
<dd><p>writing is a boolean indicating whether the channels of this type
support writing (when <cite>true</cite>) or reading (when <cite>false</cite>).</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.channel.kind">
<em class="property">param </em><code class="sig-name descname">kind</code>: iokind<a class="headerlink" href="#IO.channel.kind" title="Permalink to this definition">Â¶</a></dt>
<dd><p>kind is an enum <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> that allows narrowing
this channelâs I/O style for more efficient binary I/O.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.channel.locking">
<em class="property">param </em><code class="sig-name descname">locking</code>: bool<a class="headerlink" href="#IO.channel.locking" title="Permalink to this definition">Â¶</a></dt>
<dd><p>locking is a boolean indicating whether it is safe to use this
channel concurrently (when <cite>true</cite>).</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.init=">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">x: channel</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.init=" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="chpl record">
<dt id="IO.ioChar">
<em class="property">record </em><code class="sig-name descname">ioChar</code><a class="headerlink" href="#IO.ioChar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Represents a Unicode codepoint. I/O routines (such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a>
and <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a>) can use arguments of this type in order to read or
write a single Unicode codepoint.</p>
<dl class="chpl attribute">
<dt id="IO.ioChar.ch">
<em class="property">var </em><code class="sig-name descname">ch</code>: int(32)<a class="headerlink" href="#IO.ioChar.ch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The codepoint value</p>
</dd></dl>

</dd></dl>

<dl class="chpl record">
<dt id="IO.ioNewline">
<em class="property">record </em><code class="sig-name descname">ioNewline</code><a class="headerlink" href="#IO.ioNewline" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Represents a newline character or character sequence (ie <code class="docutils literal notranslate"><span class="pre">\n</span></code>). I/O routines
(such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a> and <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a>) can use arguments of
this type in order to read or write a newline. This is different from ânâ
because an ioNewline always produces an actual newline, but in some cases
writing <code class="docutils literal notranslate"><span class="pre">\n</span></code> will produce an escaped string (such as <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>).</p>
<p>When reading an ioNewline, read routines will skip any character sequence
(including e.g. letters and numbers) to get to the newline character unless
<code class="docutils literal notranslate"><span class="pre">skipWhitespaceOnly</span></code> is set to true.</p>
<dl class="chpl attribute">
<dt id="IO.ioNewline.skipWhitespaceOnly">
<em class="property">var </em><code class="sig-name descname">skipWhitespaceOnly</code>: bool = false<a class="headerlink" href="#IO.ioNewline.skipWhitespaceOnly" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Normally, we will skip anything at all to get to a n,
but if skipWhitespaceOnly is set, it will be an error
if we run into non-space characters other than n.</p>
</dd></dl>

</dd></dl>

<dl class="chpl record">
<dt id="IO.ioLiteral">
<em class="property">record </em><code class="sig-name descname">ioLiteral</code><a class="headerlink" href="#IO.ioLiteral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Used to represent a constant string we want to read or write.</p>
<p>When writing, the ioLiteral is output without any quoting or escaping.</p>
<p>When reading, the ioLiteral must be matched exactly - or else the read call
will return an error with code <a class="reference internal" href="SysBasic.html#SysBasic.EFORMAT" title="SysBasic.EFORMAT"><code class="xref chpl chpl-data docutils literal notranslate"><span class="pre">SysBasic.EFORMAT</span></code></a>.</p>
<dl class="chpl attribute">
<dt id="IO.ioLiteral.val">
<em class="property">var </em><code class="sig-name descname">val</code>: string<a class="headerlink" href="#IO.ioLiteral.val" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The value of the literal</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ioLiteral.ignoreWhiteSpace">
<em class="property">var </em><code class="sig-name descname">ignoreWhiteSpace</code>: bool = true<a class="headerlink" href="#IO.ioLiteral.ignoreWhiteSpace" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Should read operations using this literal ignore and consume
whitespace before the literal?</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.ioLiteral.writeThis">
<em class="property">proc </em><code class="sig-name descname">writeThis</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.ioLiteral.writeThis" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="chpl record">
<dt id="IO.ioBits">
<em class="property">record </em><code class="sig-name descname">ioBits</code><a class="headerlink" href="#IO.ioBits" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Represents a value with a particular bit length that we want to read or write.
The I/O will always be done in binary mode.</p>
<dl class="chpl attribute">
<dt id="IO.ioBits.v">
<em class="property">var </em><code class="sig-name descname">v</code>: uint(64)<a class="headerlink" href="#IO.ioBits.v" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The bottom <code class="docutils literal notranslate"><span class="pre">nbits</span></code> of v will be read or written</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ioBits.nbits">
<em class="property">var </em><code class="sig-name descname">nbits</code>: int(8)<a class="headerlink" href="#IO.ioBits.nbits" title="Permalink to this definition">Â¶</a></dt>
<dd><p>How many of the low-order bits of <code class="docutils literal notranslate"><span class="pre">v</span></code> should we read or write?</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.lock">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.lock" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Acquire a channelâs lock.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the lock could not be acquired.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.unlock">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.unlock" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Release a channelâs lock.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.offset">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int(64)<a class="headerlink" href="#IO.channel.offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the current offset of a channel.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the channel can be used by multiple tasks, take care
when doing operations that rely on the channelâs current offset.
To prevent race conditions, first lock the channel with
<a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.lock</span></code></a>, do the operations, then unlock it
with <a class="reference internal" href="#IO.channel.unlock" title="IO.channel.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.unlock</span></code></a>.
While holding the lock, use <a class="reference internal" href="#IO.channel._offset" title="IO.channel._offset"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._offset</span></code></a> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the current offset of the channel</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.advance">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">advance</code><span class="sig-paren">(</span><em class="sig-param">amount: int(64)</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.advance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Move a channel offset forward.</p>
<p>For a reading channel, this function will consume the next <code class="docutils literal notranslate"><span class="pre">amount</span></code>
bytes. If EOF is reached, the channel position may be left at the
EOF.</p>
<p>For a writing channel, this function will write <code class="docutils literal notranslate"><span class="pre">amount</span></code> zeros - or some
other data if it is stored in the channelâs buffer, for example with
<a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._mark</span></code></a> and <a class="reference internal" href="#IO.channel._revert" title="IO.channel._revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._revert</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Throws if the channel offset was not moved.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.advancePastByte">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">advancePastByte</code><span class="sig-paren">(</span><em class="sig-param">byte: uint(8)</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.advancePastByte" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reads until <code class="docutils literal notranslate"><span class="pre">byte</span></code> is found and then leave the channel offset
just after it.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EOFError</strong> â if the requested <cite>byte</cite> could not be found.</p></li>
<li><p><strong>SystemError</strong> â if another error occurred.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.mark">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">mark</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.mark" title="Permalink to this definition">Â¶</a></dt>
<dd><blockquote>
<div><p><em>mark</em> a channel - that is, save the current offset of the channel
on its <em>mark stack</em>. This function can only be called on a channel
with <code class="docutils literal notranslate"><span class="pre">locking==false</span></code>.</p>
<p>The <em>mark stack</em> stores several channel offsets. For any channel offset that
is between the minimum and maximum value in the <em>mark stack</em>, I/O operations
on the channel will keep that region of the file buffered in memory so that
those operations can be un-done. As a result, it is possible to perform <em>I/O
transactions</em> on a channel. The basic steps for an <em>I/O transaction</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>mark</em> the current position with <a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a></p></li>
<li><p>do something speculative (e.g. try to read 200 bytes of anything followed
by a âBâ)</p></li>
<li><p>if the speculative operation was successful,  commit the changes by
calling <a class="reference internal" href="#IO.channel.commit" title="IO.channel.commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.commit</span></code></a></p></li>
<li><p>if the speculative operation was not successful, go back to the <em>mark</em> by
calling <a class="reference internal" href="#IO.channel.revert" title="IO.channel.revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.revert</span></code></a>. Subsequent I/O operations will work
as though nothing happened.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that it is possible to request an entire file be buffered in memory
using this feature, for example by <em>marking</em> at offset=0 and then
advancing to the end of the file. It is important to be aware of these
memory space requirements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p>SystemError: if marking the channel failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.revert">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">revert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.revert" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a>. This function
will pop the last element from the <em>mark stack</em> and then leave the
previous channel offset unchanged.  This function can only be
called on a channel with <code class="docutils literal notranslate"><span class="pre">locking==false</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.commit">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.commit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a>.  This
function will pop the last element from the <em>mark stack</em> and then
set the channel offset to the popped offset.  This function can
only be called on a channel with <code class="docutils literal notranslate"><span class="pre">locking==false</span></code>.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.seek">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">seek</code><span class="sig-paren">(</span><em class="sig-param">start: int</em>, <em class="sig-param">end: int = max(int)</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.seek" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reset a channel to point to a new part of a file.
This function allows one to jump to a different part of a
file without creating a new channel. It can only be called
on a channel with <code class="docutils literal notranslate"><span class="pre">locking==false</span></code>.</p>
<p>Besides setting a new start position, this function allows
one to specify a new end position. Specifying the end position
is usually not necessary for correct behavior but it might be
an important performance optimization since the channel will not
try to read data outside of the start..end region.</p>
<p>This function will, in most cases, discard the channelâs buffer.
When writing, the data will be saved to the file before discarding.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> â the new start offset, measured in bytes and counting from 0</p></li>
<li><p><strong>end</strong> â optionally, a new end offset, measured in bytes and counting from 0</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p>SystemError: if seeking failed. Possible reasons include
that the file is not seekable, or that the
channel is marked.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._offset">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: int(64)<a class="headerlink" href="#IO.channel._offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>For a channel locked with <a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.lock</span></code></a>, return the offset
of that channel.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._mark">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_mark</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel._mark" title="Permalink to this definition">Â¶</a></dt>
<dd><blockquote>
<div><p>This routine is identical to <a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a> except that it
can be called on channels with <code class="docutils literal notranslate"><span class="pre">locking==true</span></code> and should be
called only once the channel has been locked with
<a class="reference internal" href="#IO.channel.lock" title="IO.channel.lock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.lock</span></code></a>.  The channel should not be unlocked with
<a class="reference internal" href="#IO.channel.unlock" title="IO.channel.unlock"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.unlock</span></code></a> until after the mark has been committed with
<a class="reference internal" href="#IO.channel._commit" title="IO.channel._commit"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._commit</span></code></a> or reverted with <a class="reference internal" href="#IO.channel._revert" title="IO.channel._revert"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._revert</span></code></a>.</p>
<p>See <a class="reference internal" href="#IO.channel.mark" title="IO.channel.mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.mark</span></code></a> for details other than the locking
discipline.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The offset that was marked</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p>SystemError: if marking the channel failed</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._revert">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_revert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._revert" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Abort an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._mark</span></code></a>.  This
function will pop the last element from the <em>mark stack</em> and then
leave the previous channel offset unchanged.  This function should
only be called on a channel that has already been locked and
marked.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._commit">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._commit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Commit an <em>I/O transaction</em>. See <a class="reference internal" href="#IO.channel._mark" title="IO.channel._mark"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel._mark</span></code></a>.  This
function will pop the last element from the <em>mark stack</em> and then
set the channel offset to the popped offset.  This function should
only be called on a channel that has already been locked and
marked.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._style">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_style</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: iostyle<a class="headerlink" href="#IO.channel._style" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the current style used by a channel. This function should only be
called on a locked channel.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel._set_style">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">_set_style</code><span class="sig-paren">(</span><em class="sig-param">style: iostyle</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel._set_style" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the style associated with a channel. This function should only
be called on a locked channel.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readWriteThisFromLocale">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readWriteThisFromLocale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.readWriteThisFromLocale" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the locale on which an ongoing I/O was started with a channel.
This method will return nil unless it is called on a channel that is
the formal argument to a <cite>readThis</cite>, <cite>writeThis</cite>, or <cite>readWriteThis</cite> method.</p>
</dd></dl>

<dl class="chpl function">
<dt id="IO.openreader">
<em class="property">proc </em><code class="sig-name descname">openreader</code><span class="sig-paren">(</span><em class="sig-param">path: string</em>, <em class="sig-param">param kind = iokind.dynamic</em>, <em class="sig-param">param locking = true</em>, <em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: channel(false, kind, locking) throws<a class="headerlink" href="#IO.openreader" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Open a file at a particular path and return a reading channel for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> and then
<a class="reference internal" href="#IO.file.reader" title="IO.file.reader"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.reader</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> â which file to open (for example, âsome/file.txtâ).</p></li>
<li><p><strong>kind</strong> â <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> controls the formatting choices.</p></li>
<li><p><strong>locking</strong> â compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>start</strong> â zero-based byte offset indicating where in the file the
channel should start reading. Defaults to 0.</p></li>
<li><p><strong>end</strong> â zero-based byte offset indicating where in the file the
channel should no longer be allowed to read. Defaults
to a <code class="docutils literal notranslate"><span class="pre">max(int)</span></code> - meaning no end point.</p></li>
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open reading channel to the requested resource.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if a reading channel could not be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.openwriter">
<em class="property">proc </em><code class="sig-name descname">openwriter</code><span class="sig-paren">(</span><em class="sig-param">path: string</em>, <em class="sig-param">param kind = iokind.dynamic</em>, <em class="sig-param">param locking = true</em>, <em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = defaultIOStyle()</em><span class="sig-paren">)</span>: channel(true, kind, locking) throws<a class="headerlink" href="#IO.openwriter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Open a file at a particular path and return a writing channel for it.
This function is equivalent to calling <a class="reference internal" href="#IO.open" title="IO.open"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">open</span></code></a> with <code class="docutils literal notranslate"><span class="pre">iomode.cwr</span></code> and then
<a class="reference internal" href="#IO.file.writer" title="IO.file.writer"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.writer</span></code></a> on the resulting file.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> â which file to open (for example, âsome/file.txtâ).</p></li>
<li><p><strong>kind</strong> â <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> controls the formatting choices.</p></li>
<li><p><strong>locking</strong> â compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>start</strong> â zero-based byte offset indicating where in the file the
channel should start writing. Defaults to 0.</p></li>
<li><p><strong>end</strong> â zero-based byte offset indicating where in the file the
channel should no longer be allowed to write. Defaults
to a <code class="docutils literal notranslate"><span class="pre">max(int)</span></code> - meaning no end point.</p></li>
<li><p><strong>hints</strong> â optional argument to specify any hints to the I/O system about
this file. See <a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an open writing channel to the requested resource.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if a writing channel could not be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.reader">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">reader</code><span class="sig-paren">(</span><em class="sig-param">param kind = iokind.dynamic</em>, <em class="sig-param">param locking = true</em>, <em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">style: iostyle = this._style</em><span class="sig-paren">)</span>: channel(false, kind, locking) throws<a class="headerlink" href="#IO.file.reader" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> that supports reading from a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">start=</span></code> and <code class="docutils literal notranslate"><span class="pre">end=</span></code> arguments define the region of the file that the
channel will read from.  These are byte offsets; the beginning of the file is
at the offset 0.  The defaults for these arguments enable the channel to
access the entire file.</p>
<p>A channel will never read beyond its maximum end position. In addition,
reading from a channel beyond the end of the underlying file will not extend
that file.  Reading beyond the end of the file or beyond the end offset of
the channel will produce the error <code class="docutils literal notranslate"><span class="pre">EEOF</span></code> (and return <cite>false</cite> in many
cases such as <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a>) to indicate that the end was reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> â <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> controls the formatting choices.</p></li>
<li><p><strong>locking</strong> â compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>start</strong> â zero-based byte offset indicating where in the file the
channel should start reading. Defaults to 0.</p></li>
<li><p><strong>end</strong> â zero-based byte offset indicating where in the file the
channel should no longer be allowed to read. Defaults
to a <code class="docutils literal notranslate"><span class="pre">max(int)</span></code> - meaning no end point.</p></li>
<li><p><strong>hints</strong> â provide hints about the I/O that this channel will perform. See
<a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>. The default value of <a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_NONE</span></code></a>
will cause the channel to use the hints provided when opening
the file.</p></li>
<li><p><strong>style</strong> â provide a <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> to use with this channel. The
default value will be the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> associated with
this file.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â Thrown if a file reader channel could not be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.lines">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">lines</code><span class="sig-paren">(</span><em class="sig-param">param locking: bool = true</em>, <em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em>, <em class="sig-param">hints: iohints = IOHINT_NONE</em>, <em class="sig-param">in local_style: iostyle = this._style</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.file.lines" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Iterate over all of the lines in a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object which yields strings read from the file</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â Thrown if an ItemReader could not be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.writer">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">writer</code><span class="sig-paren">(</span><em class="sig-param">param kind = iokind.dynamic</em>, <em class="sig-param">param locking = true</em>, <em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em>, <em class="sig-param">hints: c_int = 0</em>, <em class="sig-param">style: iostyle = this._style</em><span class="sig-paren">)</span>: channel(true, kind, locking) throws<a class="headerlink" href="#IO.file.writer" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> that supports writing to a file. See
<a class="reference internal" href="#about-io-overview"><span class="std std-ref">I/O Overview</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">start=</span></code> and <code class="docutils literal notranslate"><span class="pre">end=</span></code> arguments define the region of the file that the
channel will write to.  These are byte offsets; the beginning of the file is
at the offset 0.  The defaults for these arguments enable the channel to
access the entire file.</p>
<p>When a channel writes to a file, it will replace file data that was
previously stored at the relevant offset. If the offset is beyond the
end of the file, the file will be extended.</p>
<p>A channel will never write beyond its maximum end position.  It will extend
the file only as necessary to store data written to the channel. In other
words, specifying end here does not impact the file size directly; it
impacts only the section of the file that this channel can write to. After
all channels to a file are closed, that file will have a size equal to the
last position written to by any channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> â <a class="reference internal" href="#IO.iokind" title="IO.iokind"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iokind</span></code></a> compile-time argument to determine the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type. Defaults
to <code class="docutils literal notranslate"><span class="pre">iokind.dynamic</span></code>, meaning that the associated
<a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> controls the formatting choices.</p></li>
<li><p><strong>locking</strong> â compile-time argument to determine whether or not the
channel should use locking; sets the
corresponding parameter of the <a class="reference internal" href="#IO.channel" title="IO.channel"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">channel</span></code></a> type.
Defaults to true, but when safe, setting it to false
can improve performance.</p></li>
<li><p><strong>start</strong> â zero-based byte offset indicating where in the file the
channel should start writing. Defaults to 0.</p></li>
<li><p><strong>end</strong> â zero-based byte offset indicating where in the file the
channel should no longer be allowed to write. Defaults
to a <code class="docutils literal notranslate"><span class="pre">max(int)</span></code> - meaning no end point.</p></li>
<li><p><strong>hints</strong> â provide hints about the I/O that this channel will perform. See
<a class="reference internal" href="#IO.iohints" title="IO.iohints"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iohints</span></code></a>. The default value of <a class="reference internal" href="#IO.IOHINT_NONE" title="IO.IOHINT_NONE"><code class="xref chpl chpl-const docutils literal notranslate"><span class="pre">IOHINT_NONE</span></code></a>
will cause the channel to use the hints provided when opening
the file.</p></li>
<li><p><strong>style</strong> â provide a <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> to use with this channel. The
default value will be the <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">iostyle</span></code></a> associated with
this file.</p></li>
</ul>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â Thrown if a file writer channel could not be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readwrite">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readwrite</code><span class="sig-paren">(</span><em class="sig-param">const x</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.readwrite" title="Permalink to this definition">Â¶</a></dt>
<dd><p>For a writing channel, writes as with <a class="reference internal" href="#IO.channel.write" title="IO.channel.write"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.write</span></code></a>.
For a reading channel, reads as with <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a>.
Stores any error encountered in the channel. Does not return anything.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â When an IO error has occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc &lt;~&gt;(const ref ch: channel, const x) const ref throws</code></dt>
<dd><p>The <span class="target" id="operator">&lt;~&gt; operator</span></p>
<p>This <cite>&lt;~&gt;</cite> operator is the same as calling <a class="reference internal" href="#IO.channel.readwrite" title="IO.channel.readwrite"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readwrite</span></code></a>,
except that it returns the channel so that multiple operator
calls can be chained together.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>ch</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â When an IO error has occurred.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc &lt;~&gt;(const ref r: channel, lit: ioLiteral) const ref throws</code></dt>
<dd><p>Overload to support reading an <a class="reference internal" href="#IO.ioLiteral" title="IO.ioLiteral"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">IO.ioLiteral</span></code></a> without
passing ioLiterals by reference, so that</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">reader</span> <span class="o">&lt;~&gt;</span> <span class="k">new</span> <span class="nx">ioLiteral</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>works without requiring an explicit temporary value to store
the ioLiteral.</p>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc &lt;~&gt;(const ref r: channel, nl: ioNewline) const ref throws</code></dt>
<dd><p>Overload to support reading an <a class="reference internal" href="#IO.ioNewline" title="IO.ioNewline"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">IO.ioNewline</span></code></a> without
passing ioNewline by reference, so that</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">reader</span> <span class="o">&lt;~&gt;</span> <span class="k">new</span> <span class="nx">ioNewline</span><span class="p">()</span>
</pre></div>
</div>
<p>works without requiring an explicit temporary value to store
the ioNewline.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readWriteLiteral">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readWriteLiteral</code><span class="sig-paren">(</span><em class="sig-param">lit: string</em>, <em class="sig-param">ignoreWhiteSpace = true</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.readWriteLiteral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Explicit call for reading or writing a literal as an
alternative to using <a class="reference internal" href="#IO.ioLiteral" title="IO.ioLiteral"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">IO.ioLiteral</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readWriteNewline">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readWriteNewline</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.readWriteNewline" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Explicit call for reading or writing a newline as an
alternative to using <a class="reference internal" href="#IO.ioNewline" title="IO.ioNewline"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">IO.ioNewline</span></code></a>.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.binary">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">binary</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.channel.binary" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns <cite>true</cite> if this channel is configured for binary I/O.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.error">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: syserr<a class="headerlink" href="#IO.channel.error" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return any saved error code.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.setError">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">setError</code><span class="sig-paren">(</span><em class="sig-param">e: syserr</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.setError" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Save an error code.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.clearError">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">clearError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.clearError" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Clear any saved error code.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.writeBytes">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">writeBytes</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">len: ssize_t</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.writeBytes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write a sequence of bytes.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the byte sequence could not be written.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl itermethod">
<dt id="IO.channel.lines">
<em class="property">iter </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">lines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.lines" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Iterate over all of the lines ending in <code class="docutils literal notranslate"><span class="pre">\n</span></code> in a channel - the channel
lock will be held while iterating over the lines.</p>
<p>Only serial iteration is supported.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This iterator executes on the current locale. This may impact multilocale
performance if the current locale is not the same locale on which the
channel was created.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p>lines ending in <code class="docutils literal notranslate"><span class="pre">\n</span></code> in channel</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.stringify">
<em class="property">proc </em><code class="sig-name descname">stringify</code><span class="sig-paren">(</span><em class="sig-param">const args ...?k</em><span class="sig-paren">)</span>: string<a class="headerlink" href="#IO.stringify" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a string representing the result of writing the arguments.</p>
<p>Writes each argument, possibly using a <cite>writeThis</cite> method,
to a string and returns the result.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.read">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">ref args ...?k</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.read" title="Permalink to this definition">Â¶</a></dt>
<dd><p>returns true if read successfully, false if we encountered EOF</p>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">ref args ...?k</em>, <em class="sig-param">style: iostyle</em><span class="sig-paren">)</span>: bool throws</dt>
<dd><p>Read values from a channel. The input will be consumed atomically - the
channel lock will be held while reading all of the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> â a list of arguments to read. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal notranslate"><span class="pre">Reader</span></code> argument as described
in <a class="reference internal" href="ChapelIO.html#readthis-writethis-readwritethis"><span class="std std-ref">The readThis(), writeThis(), and readWriteThis() Methods</span></a>.</p></li>
<li><p><strong>style</strong> â optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostyle</span></code></a> for this read.
If this argument is not provided, use the current style
associated with this channel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> on end of file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the channel could not be read.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readline">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readline</code><span class="sig-paren">(</span><em class="sig-param">arg: [] uint(8)</em>, <em class="sig-param">out numRead: int</em>, <em class="sig-param">start = arg.domain.low</em>, <em class="sig-param">amount = arg.domain.high-start+1</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.readline" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read a line into a Chapel array of bytes. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal notranslate"><span class="pre">\n</span></code> is returned in the array.</p>
<p>Throws a SystemError if a line could not be read from the channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> â A 1D DefaultRectangular array which must have at least 1 element.</p></li>
<li><p><strong>numRead</strong> â The number of bytes read.</p></li>
<li><p><strong>start</strong> â Index to begin reading into.</p></li>
<li><p><strong>amount</strong> â The maximum amount of bytes to read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if the bytes were read without error.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readline</code><span class="sig-paren">(</span><em class="sig-param">ref arg: ?t</em><span class="sig-paren">)</span>: bool throws</dt>
<dd><p>Read a line into a Chapel string or bytes. Reads until a <code class="docutils literal notranslate"><span class="pre">\n</span></code> is reached.
The <code class="docutils literal notranslate"><span class="pre">\n</span></code> is included in the resulting value.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>arg</strong> â a string or bytes to receive the line</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if a line was read without error, <cite>false</cite> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if data could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readstring">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readstring</code><span class="sig-paren">(</span><em class="sig-param">ref str_out: string</em>, <em class="sig-param">len: int(64) = -1</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.readstring" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read a given number of bytes from a channel</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str_out</strong> â The string to be read into</p></li>
<li><p><strong>len</strong> â Read up to len bytes from the channel, up until EOF
(or some kind of I/O error). If the default value of -1
is provided, read until EOF starting from the channelâs
current offset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if we read something, <cite>false</cite> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the bytes could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readbytes">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readbytes</code><span class="sig-paren">(</span><em class="sig-param">ref bytes_out: bytes</em>, <em class="sig-param">len: int(64) = -1</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.readbytes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read a given number of bytes from a channel</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bytes_out</strong> â The bytes to be read into</p></li>
<li><p><strong>len</strong> â Read up to len bytes from the channel, up until EOF
(or some kind of I/O error). If the default value of -1
is provided, read until EOF starting from the channelâs
current offset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if we read something, <cite>false</cite> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the bytes could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readbits">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readbits</code><span class="sig-paren">(</span><em class="sig-param">out v: integral</em>, <em class="sig-param">nbits: integral</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.readbits" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> â where to store the read bits. This value will have its <em>nbits</em>
least-significant bits set.</p></li>
<li><p><strong>nbits</strong> â how many bits to read</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the bits were read without error, <cite>false</cite> upon EOF</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the bits could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.writebits">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">writebits</code><span class="sig-paren">(</span><em class="sig-param">v: integral</em>, <em class="sig-param">nbits: integral</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.writebits" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write bits with binary I/O</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> â a value containing <em>nbits</em> bits to write the least-significant bits</p></li>
<li><p><strong>nbits</strong> â how many bits to write</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the bits were written without error, <cite>false</cite> on error</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IllegalArgumentError</strong> â Thrown if writing more bits than fit into <cite>v</cite>.</p></li>
<li><p><strong>SystemError</strong> â Thrown if the bits could not be written to the channel.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.readln">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readln</code><span class="sig-paren">(</span><em class="sig-param">ref args ...?k</em>, <em class="sig-param">style: iostyle</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.readln" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read values from a channel and then consume any bytes until
newline is reached. The input will be consumed atomically - the
channel lock will be held while reading all of the passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> â a list of arguments to read. This routine can be called
with zero or more such arguments. Basic types are handled
internally, but for other types this function will call
value.readThis() with a <code class="docutils literal notranslate"><span class="pre">Reader</span></code> argument as described
in <a class="reference internal" href="ChapelIO.html#readthis-writethis-readwritethis"><span class="std std-ref">The readThis(), writeThis(), and readWriteThis() Methods</span></a>.</p></li>
<li><p><strong>style</strong> â optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostyle</span></code></a> for this read.
If this argument is not provided, use the current style
associated with this channel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the read succeeded, and <cite>false</cite> upon end of file.</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if a line could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">type t</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Read a value of passed type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is difficult to handle errors or to handle reaching the end of
the file with this function. If such cases are important please use
the <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a> returning the values read in arguments instead.</p>
</div>
<p>For example, the following line of code reads a value of type <cite>int</cite>
from <a class="reference internal" href="#IO.stdin" title="IO.stdin"><code class="xref chpl chpl-var docutils literal notranslate"><span class="pre">stdin</span></code></a> and uses it to initialize a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> â the type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the type could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readln</code><span class="sig-paren">(</span><em class="sig-param">type t</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Read a value of passed type followed by a newline.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is difficult to handle errors or to handle reaching the end of
the file with this function. If such cases are important please use
<a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readln</span></code></a> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> â the type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the value read</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the type could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">readln</code><span class="sig-paren">(</span><em class="sig-param">type t ...?numTypes</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Read values of passed types followed by a newline
and return a tuple containing the read values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> â more than one type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the types could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">type t ...?numTypes</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Read values of passed types and return a tuple containing the read values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>t</strong> â more than one type to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of the read values</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the types could not be read from the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.write">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">const args ...?k</em>, <em class="sig-param">style: iostyle</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.write" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write values to a channel. The output will be produced atomically -
the channel lock will be held while writing all of the passed
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> â a list of arguments to write. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the channel as an argument.</p></li>
<li><p><strong>style</strong> â optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostyle</span></code></a> for this write.
If this argument is not provided, use the current style
associated with this channel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the write succeeded</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the values could not be written to the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.writeln">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">writeln</code><span class="sig-paren">(</span><em class="sig-param">const args ...?k</em>, <em class="sig-param">style: iostyle</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.channel.writeln" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write values to a channel followed by a newline.  The output will be
produced atomically - the channel lock will be held while writing all of the
passed values.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> â a variable number of arguments to write. This method can be
called with zero or more arguments. Basic types are handled
internally, but for other types this function will call
value.writeThis() with the channel as an argument.</p></li>
<li><p><strong>style</strong> â optional argument to provide an <a class="reference internal" href="#IO.iostyle" title="IO.iostyle"><code class="xref chpl chpl-type docutils literal notranslate"><span class="pre">iostyle</span></code></a> for this write.
If this argument is not provided, use the current style
associated with this channel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if the write succeeded</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the values could not be written to the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.flush">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Makes all writes to the channel, if any, available to concurrent viewers
of its associated file, such as other channels or other applications
accessing this file concurrently.
Unlike <a class="reference internal" href="#IO.file.fsync" title="IO.file.fsync"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">file.fsync</span></code></a>, this does not commit the written data
to the fileâs device.</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the flush fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.assertEOF">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">assertEOF</code><span class="sig-paren">(</span><em class="sig-param">errStr: string = &quot;- Not at EOF&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.assertEOF" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Assert that a channel has reached end-of-file and that there was no error
doing the read.</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.close">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.channel.close" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Close a channel. Implicitly performs the <a class="reference internal" href="#IO.channel.flush" title="IO.channel.flush"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.flush</span></code></a> operation
(see <a class="reference internal" href="#about-io-channel-synchronization"><span class="std std-ref">Synchronization of Channel Data and Avoiding Data Races</span></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the channel is not successfully closed.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.isclosed">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">isclosed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.isclosed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <cite>true</cite> if a channel is currently closed.</p>
</dd></dl>

<dl class="chpl record">
<dt id="IO.ItemReader">
<em class="property">record </em><code class="sig-name descname">ItemReader</code><a class="headerlink" href="#IO.ItemReader" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wrapper class on a channel to make it only read values
of a single type. Also supports an iterator yielding
the read values.</p>
<dl class="chpl attribute">
<dt id="IO.ItemReader.ItemType">
<em class="property">type </em><code class="sig-name descname">ItemType</code><a class="headerlink" href="#IO.ItemReader.ItemType" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What type do we read and yield?</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemReader.kind">
<em class="property">param </em><code class="sig-name descname">kind</code>: iokind<a class="headerlink" href="#IO.ItemReader.kind" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the kind field for our channel</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemReader.locking">
<em class="property">param </em><code class="sig-name descname">locking</code>: bool<a class="headerlink" href="#IO.ItemReader.locking" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the locking field for our channel</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemReader.ch">
<em class="property">var </em><code class="sig-name descname">ch</code>: channel(false, kind, locking)<a class="headerlink" href="#IO.ItemReader.ch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>our channel</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.ItemReader.read">
<em class="property">proc </em><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">out arg: ItemType</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.ItemReader.read" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read a single item, throwing on error</p>
</dd></dl>

<dl class="chpl itermethod">
<dt id="IO.ItemReader.these">
<em class="property">iter </em><code class="sig-name descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IO.ItemReader.these" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterate through all items of that type read from the channel</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.itemReader">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">itemReader</code><span class="sig-paren">(</span><em class="sig-param">type ItemType</em>, <em class="sig-param">param kind: iokind = iokind.dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.itemReader" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create and return an <a class="reference internal" href="#IO.ItemReader" title="IO.ItemReader"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ItemReader</span></code></a> that can yield read values of
a single type.</p>
</dd></dl>

<dl class="chpl record">
<dt id="IO.ItemWriter">
<em class="property">record </em><code class="sig-name descname">ItemWriter</code><a class="headerlink" href="#IO.ItemWriter" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="chpl attribute">
<dt id="IO.ItemWriter.ItemType">
<em class="property">type </em><code class="sig-name descname">ItemType</code><a class="headerlink" href="#IO.ItemWriter.ItemType" title="Permalink to this definition">Â¶</a></dt>
<dd><p>What type do we write?</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemWriter.kind">
<em class="property">param </em><code class="sig-name descname">kind</code>: iokind<a class="headerlink" href="#IO.ItemWriter.kind" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the kind field for our channel</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemWriter.locking">
<em class="property">param </em><code class="sig-name descname">locking</code>: bool<a class="headerlink" href="#IO.ItemWriter.locking" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the locking field for our channel</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="IO.ItemWriter.ch">
<em class="property">var </em><code class="sig-name descname">ch</code>: channel(true, kind, locking)<a class="headerlink" href="#IO.ItemWriter.ch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>our channel</p>
</dd></dl>

<dl class="chpl method">
<dt id="IO.ItemWriter.write">
<em class="property">proc </em><code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">arg: ItemType</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.ItemWriter.write" title="Permalink to this definition">Â¶</a></dt>
<dd><p>write a single item, throwing on error</p>
</dd></dl>

</dd></dl>

<dl class="chpl method">
<dt id="IO.channel.itemWriter">
<em class="property">proc </em><code class="sig-prename descclassname">channel.</code><code class="sig-name descname">itemWriter</code><span class="sig-paren">(</span><em class="sig-param">type ItemType</em>, <em class="sig-param">param kind: iokind = iokind.dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.channel.itemWriter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create and return an <a class="reference internal" href="#IO.ItemWriter" title="IO.ItemWriter"><code class="xref chpl chpl-record docutils literal notranslate"><span class="pre">ItemWriter</span></code></a> that can write values of
a single type.</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.stdin">
<em class="property">const </em><code class="sig-name descname">stdin</code>: channel(false, iokind.dynamic, true)<a class="headerlink" href="#IO.stdin" title="Permalink to this definition">Â¶</a></dt>
<dd><p>standard input, otherwise known as file descriptor 0</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.stdout">
<em class="property">const </em><code class="sig-name descname">stdout</code>: channel(true, iokind.dynamic, true)<a class="headerlink" href="#IO.stdout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>standard output, otherwise known as file descriptor 1</p>
</dd></dl>

<dl class="chpl data">
<dt id="IO.stderr">
<em class="property">const </em><code class="sig-name descname">stderr</code>: channel(true, iokind.dynamic, true)<a class="headerlink" href="#IO.stderr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>standard error, otherwise known as file descriptor 2</p>
</dd></dl>

<dl class="chpl function">
<dt id="IO.read">
<em class="property">proc </em><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">ref args ...?n</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.read" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt id="IO.readln">
<em class="property">proc </em><code class="sig-name descname">readln</code><span class="sig-paren">(</span><em class="sig-param">ref args ...?n</em><span class="sig-paren">)</span>: bool throws<a class="headerlink" href="#IO.readln" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readln</span></code></a></p>
</dd></dl>

<dl class="chpl function">
<dt>
<em class="property">proc </em><code class="sig-name descname">readln</code><span class="sig-paren">(</span><em class="sig-param">type t ...?numTypes</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.readln</span></code>. See <a class="reference internal" href="#IO.channel.readln" title="IO.channel.readln"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.readln</span></code></a> for types</p>
</dd></dl>

<dl class="chpl function">
<dt>
<em class="property">proc </em><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">type t ...?numTypes</em><span class="sig-paren">)</span> throws</dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">stdin.read</span></code>. See <a class="reference internal" href="#IO.channel.read" title="IO.channel.read"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">channel.read</span></code></a> for types</p>
</dd></dl>

<dl class="chpl function">
<dt id="IO.unlink">
<em class="property">proc </em><code class="sig-name descname">unlink</code><span class="sig-paren">(</span><em class="sig-param">path: string</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#IO.unlink" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Delete a file. This function is likely to be replaced
by <a class="reference internal" href="FileSystem.html#FileSystem.remove" title="FileSystem.remove"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">FileSystem.remove</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>path</strong> â the path to the file to remove</p>
</dd>
<dt class="field-even">Throws</dt>
<dd class="field-even"><p><strong>SystemError</strong> â Thrown if the file is not successfully deleted.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="IO.unicodeSupported">
<em class="property">proc </em><code class="sig-name descname">unicodeSupported</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#IO.unicodeSupported" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>true</cite> if this version of the Chapel runtime supports UTF-8 output.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.getchunk">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">getchunk</code><span class="sig-paren">(</span><em class="sig-param">start: int(64) = 0</em>, <em class="sig-param">end: int(64) = max(int(64))</em><span class="sig-paren">)</span>: (int(64), int(64)) throws<a class="headerlink" href="#IO.file.getchunk" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns (chunk start, chunk end) for the first chunk in the file
containing data in the region start..end-1. Note that the returned
chunk might not cover all of the region in question.</p>
<p>Returns (0,0) if no such value exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> â the file offset (starting from 0) where the region begins</p></li>
<li><p><strong>end</strong> â the file offset just after the region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple of (chunkStart, chunkEnd) so that the bytes
in chunkStart..chunkEnd-1 are stored in a manner that makes
reading that chunk at a time most efficient</p>
</dd>
<dt class="field-odd">Throws</dt>
<dd class="field-odd"><p><strong>SystemError</strong> â Thrown if the chunk is not attained.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="IO.file.localesForRegion">
<em class="property">proc </em><code class="sig-prename descclassname">file.</code><code class="sig-name descname">localesForRegion</code><span class="sig-paren">(</span><em class="sig-param">start: int(64)</em>, <em class="sig-param">end: int(64)</em><span class="sig-paren">)</span><a class="headerlink" href="#IO.file.localesForRegion" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the âbestâ locale to run something working with the region
of the file in start..end-1.</p>
<p>This <em>must</em> return the same result when called from different locales.
Returns a domain of locales that are âbestâ for the given region. If no
locales are âbestâ we return a domain containing all locales.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> â the file offset (starting from 0) where the region begins</p></li>
<li><p><strong>end</strong> â the file offset just after the region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a set of locales that are best for working with this region</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>domain(locale)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="IO/FormattedIO.html" class="btn btn-neutral float-right" title="FormattedIO" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="FileSystem.html" class="btn btn-neutral float-left" title="FileSystem" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>