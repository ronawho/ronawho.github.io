

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Set &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="CommDiagnostics" href="CommDiagnostics.html" />
    <link rel="prev" title="Map" href="Map.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "modules/standard/Set";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../standard.html">Standard Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../standard.html#automatic-modules">Automatic Modules</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../standard.html#data-structures">Data Structures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Heap.html">Heap</a></li>
<li class="toctree-l3"><a class="reference internal" href="List.html">List</a></li>
<li class="toctree-l3"><a class="reference internal" href="Map.html">Map</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#files-io">Files/IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#language-support">Language Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#math-numerical">Math/Numerical</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#parallelism-distributed-computing">Parallelism/Distributed Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#system-interoperability">System/Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#deprecated-modules">Deprecated Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../standard.html#index">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../standard.html">Standard Modules</a> &raquo;</li>
        
      <li>Set</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/standard/Set.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-Set"></span><div class="section" id="set">
<h1>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h1>
<p><strong>Usage</strong></p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Set</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nx">Set</span><span class="p">;</span>
</pre></div>
</div>
<p>This module contains the implementation of the set type.</p>
<p>A set is a collection of unique elements. Sets are unordered and unindexed.</p>
<p>The highly parallel nature of Chapel means that great care should be taken
when performing operations that may invalidate references to set elements.
Adding or removing an element from a set may invalidate references to
elements contained in the set.</p>
<p>All references to set elements are invalidated when the set is cleared or
deinitialized.</p>
<p>Sets are not parallel safe by default, but can be made parallel safe by
setting the param formal ‘parSafe` to true in any set constructor. When
constructed from another set, the new set will inherit the parallel safety
mode of its originating set.</p>
<dl class="chpl record">
<dt id="Set.set">
<em class="property">record </em><code class="sig-name descname">set</code><a class="headerlink" href="#Set.set" title="Permalink to this definition">¶</a></dt>
<dd><p>A set is a collection of unique elements. Attempting to add a duplicate
element to a set has no effect.</p>
<p>The set type supports a test for membership via the <a class="reference internal" href="#Set.set.contains" title="Set.set.contains"><code class="xref chpl chpl-proc docutils literal notranslate"><span class="pre">contains</span></code></a>
method, along with free functions for calculating the union, difference,
intersection, and symmetric difference of two sets. The set type also
defines the (proper) subset and (proper) superset operations by
overloading common comparison operators.</p>
<p>Sets can be iterated over. The set type makes no guarantee of a consistent
iteration order.</p>
<p>A set can be default initialized (containing no elements), or it may be
initialized with elements that are copies of those contained by any
type that supports an iterator.</p>
<p>The set type is not parallel safe by default. For situations in which
such protections are desirable, parallel safety can be enabled by setting
<cite>parSafe = true</cite> in any set constructor. A set constructed from another
set inherits the parallel safety mode of that set by default.</p>
<dl class="chpl attribute">
<dt id="Set.set.eltType">
<em class="property">type </em><code class="sig-name descname">eltType</code><a class="headerlink" href="#Set.set.eltType" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the elements contained in this set.</p>
</dd></dl>

<dl class="chpl attribute">
<dt id="Set.set.parSafe">
<em class="property">param </em><code class="sig-name descname">parSafe</code> = false<a class="headerlink" href="#Set.set.parSafe" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>true</cite>, this set will perform parallel safe operations.</p>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.init">
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">param parSafe = false</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes an empty set containing elements of the given type.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eltType</strong> – The type of the elements of this set.</p></li>
<li><p><strong>parSafe</strong> – If <cite>true</cite>, this set will use parallel safe operations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<em class="property">proc </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">type eltType</em>, <em class="sig-param">iterable</em>, <em class="sig-param">param parSafe = false</em><span class="sig-paren">)</span></dt>
<dd><p>Initialize this set with a unique copy of each element contained in
<cite>iterable</cite>. If an element from <cite>iterable</cite> is already contained in this
set, it will not be added again. The formal <cite>iterable</cite> must be a type
with an iterator named “these” defined for it.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterable</strong> – A collection of elements to add to this set.</p></li>
<li><p><strong>parSafe</strong> – If <cite>true</cite>, this set will use parallel safe operations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.init=">
<em class="property">proc </em><code class="sig-name descname">init=</code><span class="sig-paren">(</span><em class="sig-param">const ref other: set(?t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.init=" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize this set with a copy of each of the elements contained in
the set <cite>other</cite>. This set will inherit the <cite>parSafe</cite> value of the
set <cite>other</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>other</strong> – A set to initialize this set with.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<code class="sig-name descname">proc ref add(in x: eltType)</code></dt>
<dd><p>Add a copy of the element <cite>x</cite> to this set. Does nothing if this set
already contains an element equal to the value of <cite>x</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>x</strong> – The element to add to this set.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.contains">
<em class="property">proc </em><code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">const ref x: eltType</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if the given element is a member of this set, and <cite>false</cite>
otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>x</strong> – The element to test for membership.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether or not the given element is a member of this set.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.isDisjoint">
<em class="property">proc </em><code class="sig-name descname">isDisjoint</code><span class="sig-paren">(</span><em class="sig-param">const ref other: set(eltType</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isDisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set shares no elements in common with the set
<cite>other</cite>, and <cite>false</cite> otherwise.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><cite>other</cite> must not be modified during this call.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>other</strong> – The set to compare against.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether or not this set and <cite>other</cite> are disjoint.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.isIntersecting">
<em class="property">proc </em><code class="sig-name descname">isIntersecting</code><span class="sig-paren">(</span><em class="sig-param">const ref other: set(eltType</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isIntersecting" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set and <cite>other</cite> have at least one element in
common, and <cite>false</cite> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>other</strong> – The set to compare against.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether or not this set and <cite>other</cite> intersect.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<code class="sig-name descname">proc ref remove(const ref x: eltType): bool</code></dt>
<dd><p>Attempt to remove the item from this set with a value equal to <cite>x</cite>. If
an element equal to <cite>x</cite> was removed from this set, return <cite>true</cite>, else
return <cite>false</cite> if no such value was found.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Removing an element from this set may invalidate existing references
to the elements contained in this set.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>x</strong> – The element to remove.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether or not an element equal to <cite>x</cite> was removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt>
<code class="sig-name descname">proc ref clear()</code></dt>
<dd><p>Clear the contents of this set.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Clearing the contents of this set will invalidate all existing
references to the elements contained in this set.</p>
</div>
</dd></dl>

<dl class="chpl itermethod">
<dt id="Set.set.these">
<em class="property">iter </em><code class="sig-name descname">these</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Set.set.these" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the elements of this set. Yields constant references
that cannot be modified.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Modifying this set while iterating over it may invalidate the
references returned by an iterator and is considered undefined
behavior.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p>A constant reference to an element in this set.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.writeThis">
<em class="property">proc </em><code class="sig-name descname">writeThis</code><span class="sig-paren">(</span><em class="sig-param">ch: channel</em><span class="sig-paren">)</span> throws<a class="headerlink" href="#Set.set.writeThis" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contents of this set to a channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><p><strong>ch</strong> – A channel to write to.</p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.isEmpty">
<em class="property">proc </em><code class="sig-name descname">isEmpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.set.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>true</cite> if this set contains zero elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>true</cite> if this set is empty.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.size">
<em class="property">proc </em><code class="sig-name descname">size</code><a class="headerlink" href="#Set.set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The current number of elements contained in this set.</p>
</dd></dl>

<dl class="chpl method">
<dt id="Set.set.toArray">
<em class="property">proc </em><code class="sig-name descname">toArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span>: [] eltType<a class="headerlink" href="#Set.set.toArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new DefaultRectangular array containing a copy of each of the
elements contained in this set. The elements of the returned array are
not guaranteed to follow any particular ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An array containing a copy of each of the elements in this set.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>[] eltType</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="chpl function">
<dt id="Set.=">
<em class="property">proc </em><code class="sig-name descname">=</code><span class="sig-paren">(</span><em class="sig-param">ref lhs: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref rhs: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.=" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the contents of the set <cite>lhs</cite>, then iterate through the contents of
<cite>rhs</cite> and add a copy of each element to <cite>lhs</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – The set to assign to.</p></li>
<li><p><strong>rhs</strong> – The set to assign from.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc |(const ref a: set(?t, ?), const ref b: set(t, ?)): set(t)</code></dt>
<dd><p>Return a new set that contains the union of two sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to take the union of.</p></li>
<li><p><strong>b</strong> – A set to take the union of.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new set containing the union between <cite>a</cite> and <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>set(?t, ?)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc |=(ref lhs: set(?t, ?), const ref rhs: set(t, ?))</code></dt>
<dd><p>Add to the set <cite>lhs</cite> all the elements of <cite>rhs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – A set to take the union of and then assign to.</p></li>
<li><p><strong>rhs</strong> – A set to take the union of.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.+">
<em class="property">proc </em><code class="sig-name descname">+</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: set(t, ?)<a class="headerlink" href="#Set.+" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new set that contains the union of two sets. Alias for the <cite>|</cite>
operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to take the union of.</p></li>
<li><p><strong>b</strong> – A set to take the union of.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new set containing the union between <cite>a</cite> and <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>set(?t, ?)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.+=">
<em class="property">proc </em><code class="sig-name descname">+=</code><span class="sig-paren">(</span><em class="sig-param">ref lhs: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref rhs: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.+=" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to the set <cite>lhs</cite> all the elements of <cite>rhs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – A set to take the union of and then assign to.</p></li>
<li><p><strong>rhs</strong> – A set to take the union of.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.-">
<em class="property">proc </em><code class="sig-name descname">-</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: set(t)<a class="headerlink" href="#Set.-" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new set that contains the difference of two sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to take the difference of.</p></li>
<li><p><strong>b</strong> – A set to take the difference of.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new set containing the difference between <cite>a</cite> and <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>set(t)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.-=">
<em class="property">proc </em><code class="sig-name descname">-=</code><span class="sig-paren">(</span><em class="sig-param">ref lhs: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref rhs: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span><a class="headerlink" href="#Set.-=" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove from the set <cite>lhs</cite> the elements of <cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – A set to take the difference of and then assign to.</p></li>
<li><p><strong>rhs</strong> – A set to take the difference of.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc &amp;(const ref a: set(?t, ?), const ref b: set(t, ?)): set(t)</code></dt>
<dd><p>Return a new set that contains the intersection of two sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to take the intersection of.</p></li>
<li><p><strong>b</strong> – A set to take the intersection of.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new set containing the intersection of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>set(t)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc &amp;=(ref lhs: set(?t, ?), const ref rhs: set(t, ?))</code></dt>
<dd><p>Assign to the set <cite>lhs</cite> the set that is the intersection of <cite>lhs</cite> and
<cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – A set to take the intersection of and then assign to.</p></li>
<li><p><strong>rhs</strong> – A set to take the intersection of.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc ^(const ref a: set(?t, ?), const ref b: set(t, ?)): set(t)</code></dt>
<dd><p>Return the symmetric difference of two sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to take the symmetric difference of.</p></li>
<li><p><strong>b</strong> – A set to take the symmetric difference of.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new set containing the symmetric difference of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>set(?t, ?)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt>
<code class="sig-name descname">proc ^=(ref lhs: set(?t, ?), const ref rhs: set(t, ?))</code></dt>
<dd><p>Assign to the set <cite>lhs</cite> the set that is the symmetric difference of <cite>lhs</cite>
and <cite>rhs</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will invalidate any references to elements previously contained in
the set <cite>lhs</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> – A set to take the symmetric difference of and then assign to.</p></li>
<li><p><strong>rhs</strong> – A set to take the symmetric difference of.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.==">
<em class="property">proc </em><code class="sig-name descname">==</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.==" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if the sets <cite>a</cite> and <cite>b</cite> are equal. That is, they are the
same size and contain the same elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if two sets are equal.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.!=">
<em class="property">proc </em><code class="sig-name descname">!=</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.!=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if the sets <cite>a</cite> and <cite>b</cite> are not equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if two sets are not equal.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.&lt;">
<em class="property">proc </em><code class="sig-name descname">&lt;</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.<" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a proper subset of <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if <cite>a</cite> is a proper subset of <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.&lt;=">
<em class="property">proc </em><code class="sig-name descname">&lt;=</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.<=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a subset of <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if <cite>a</cite> is a subset of <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.&gt;">
<em class="property">proc </em><code class="sig-name descname">&gt;</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.>" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a proper superset of <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if <cite>a</cite> is a proper superset of <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="chpl function">
<dt id="Set.&gt;=">
<em class="property">proc </em><code class="sig-name descname">&gt;=</code><span class="sig-paren">(</span><em class="sig-param">const ref a: set(?t</em>, <em class="sig-param">?)</em>, <em class="sig-param">const ref b: set(t</em>, <em class="sig-param">?)</em><span class="sig-paren">)</span>: bool<a class="headerlink" href="#Set.>=" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>true</cite> if <cite>a</cite> is a superset of <cite>b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A set to compare.</p></li>
<li><p><strong>b</strong> – A set to compare.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>true</cite> if <cite>a</cite> is a superset of <cite>b</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="CommDiagnostics.html" class="btn btn-neutral float-right" title="CommDiagnostics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Map.html" class="btn btn-neutral float-left" title="Map" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>