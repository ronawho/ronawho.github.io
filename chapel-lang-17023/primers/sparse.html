

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sparse Domains and Arrays &mdash; Chapel Documentation 1.24</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Associative Domains and Arrays" href="associative.html" />
    <link rel="prev" title="Slices" href="slices.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.24
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.24";
$pagename = "primers/sparse";
include "..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../language/reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Primers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#language-basics">Language Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#iterators">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#task-parallelism">Task Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#locality">Locality</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-parallelism">Data Parallelism</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="slices.html">Slices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Sparse Domains and Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="associative.html">Associative Domains and Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="reductions.html">Reductions</a></li>
<li class="toctree-l3"><a class="reference internal" href="distributions.html">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="replicated.html">Replicated Distribution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#library-utilities">Library Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#numerical-libraries">Numerical Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#language-overview">Language Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/spec/index.html">Language Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/archivedSpecs.html">Documentation Archives</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Primers</a> &raquo;</li>
        
      <li>Sparse Domains and Arrays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/primers/sparse.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sparse-domains-and-arrays">
<span id="primers-sparse"></span><h1>Sparse Domains and Arrays<a class="headerlink" href="#sparse-domains-and-arrays" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/chapel-lang/chapel/blob/master/test/release/examples/primers/sparse.chpl">View sparse.chpl on GitHub</a></p>
<p>This primer shows off some of Chapel’s support for sparse domains
and arrays.</p>
<p>First, we declare a configuration variable, <code class="docutils literal notranslate"><span class="pre">n</span></code>, which defines the
problem size for this example.  It’s given a default value of <code class="docutils literal notranslate"><span class="pre">9</span></code>,
which can be over-ridden on the executable’s command line using:
<code class="docutils literal notranslate"><span class="pre">--n=&lt;value&gt;</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">config</span> <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</pre></div>
</div>
<p>Sparse domains in Chapel are defined in terms of a bounding domain.
The role of this bounding domain is to define the range of legal
indices for the sparse domain.  Here we declare a dense 2D
rectangular bounding domain of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> indices which will serve as the
index space for the sparse domain/array in our example.  As we will
see, it will also be useful for operations that want to treat our
sparse domain as though it was a dense <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> set of values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">dnsDom</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">};</span>
</pre></div>
</div>
<p>Here we declare our sparse domain.  The sparse keyword indicates
that it will be used to only represent a subset of its bounding
domain’s indices, and that arrays declared using it will store a
<em>zero value</em> (described further below) for all indices in the set
<code class="docutils literal notranslate"><span class="pre">dnsDom</span> <span class="pre">-</span> <span class="pre">spsDom</span></code>.  Because we don’t initialize the sparse domain, it
is initially an empty set of indices.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsDom</span><span class="p">:</span> <span class="k">sparse</span> <span class="k">subdomain</span><span class="p">(</span><span class="nx">dnsDom</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we use the sparse domain to declare a sparse array.  This
uses Chapel’s normal array declaration syntax.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">spsArr</span><span class="p">:</span> <span class="p">[</span><span class="nx">spsDom</span><span class="p">]</span> <span class="kt">real</span><span class="p">;</span>
</pre></div>
</div>
<p>I/O on sparse domains and arrays only prints out <em>non-vero values</em>;
initially there are none, so these will both print in a degenerate manner.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, spsDom is: &quot;</span><span class="p">,</span> <span class="nx">spsDom</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Initially, spsArr is: &quot;</span><span class="p">,</span> <span class="nx">spsArr</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>We can also do I/O more explicitly by iterating over the dense
domain and indexing into the sparse array.  Note that it’s legal to
index into a sparse array in either its <em>zero</em> or <em>nonzero</em>
positions; however it’s only legal to assign to <em>nonzero</em>
positions, since those are the only ones that are explicitly
stored.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">writeSpsArr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">dnsDom</span> <span class="p">{</span>
    <span class="nx">write</span><span class="p">(</span><span class="nx">spsArr</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">),</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="nx">n</span><span class="p">)</span> <span class="k">then</span> <span class="nx">writeln</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="nx">writeln</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s try that procedure we just wrote:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr with a dense representation:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>Chapel’s sparse arrays store the element type’s default value for
their <em>zero value</em> by default – so <code class="docutils literal notranslate"><span class="pre">0</span></code> for numerical types,
empty strings for strings, <code class="docutils literal notranslate"><span class="pre">nil</span></code> references for classes, etc.
However, a different value can be stored at <em>zero</em> positions
instead which is why we don’t refer to it as the <em>zero value</em> and
rather as the <em>IRV</em> or <em>Implicitly Replicated Value</em>.  This value can
be changed for a given array by assigning to that array’s <em>IRV</em>
field, allowing a more interesting value/string/class instance to
be stored at all the <em>zero</em> values.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">spsArr</span><span class="p">.</span><span class="nx">IRV</span> <span class="o">=</span> <span class="mf">7.7</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after changing its IRV:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>OK, now let’s actually add some sparse indices to the <code class="docutils literal notranslate"><span class="pre">spsDom</span></code> domain
and see what happens:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">spsDom</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">);</span>
<span class="nx">spsDom</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">);</span>
<span class="nx">spsDom</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">spsDom</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after adding the corner indices:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>It appears as though nothing happened, but in fact it did.  The
sparse domain spsDom was reallocated to store the four new (corner)
indices; the sparse array was reallocated to allocate storage for
the four new elements corresponding to those indices; and those
elements were initialized to store the <em>IRV</em>, since that’s the
logical value that they were representing before the new sparse
indices “filled in”.  We can see this difference by going back to
the default sparse I/O:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After adding corners, spsDom is:\n&quot;</span><span class="p">,</span> <span class="nx">spsDom</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;After adding corners, spsArr is:\n&quot;</span><span class="p">,</span> <span class="nx">spsArr</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>Or by assigning the array elements corresponding to the corners
and using our dense printing procedure:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">computeVal</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">)</span> <span class="k">return</span> <span class="nx">row</span> <span class="o">+</span> <span class="nx">col</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>

<span class="nx">spsArr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">spsArr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">);</span>
<span class="nx">spsArr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">spsArr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after assigning the corner elements:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>Values can only be assigned to array positions that are members in
the sparse domain index set.  The boolean method Domain.contains(x)
can be used to check whether a certain index <code class="docutils literal notranslate"><span class="pre">(x)</span></code> is a member of the
domain’s index set. Note that, in multi-dimensional domains, the member
method can accept the index as a tuple like <code class="docutils literal notranslate"><span class="pre">spsDom.contains((i,j))</span></code>
or as a parameter list like <code class="docutils literal notranslate"><span class="pre">spsDom.contains(i,j)</span></code>. Below, we print
<code class="docutils literal notranslate"><span class="pre">*</span></code> for the positions that are members in the sparse domain, and <code class="docutils literal notranslate"><span class="pre">.</span></code>
otherwise.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Positions that are members in the sparse domain are marked by a &#39;*&#39;:&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">dnsDom</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">spsDom</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="k">then</span>
    <span class="nx">write</span><span class="p">(</span><span class="s">&quot;* &quot;</span><span class="p">);</span> <span class="c1">// (i,j) is a member in the sparse index set</span>
  <span class="k">else</span>
    <span class="nx">write</span><span class="p">(</span><span class="s">&quot;. &quot;</span><span class="p">);</span> <span class="c1">// (i,j) is not a member in the sparse index set</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="nx">n</span><span class="p">)</span> <span class="k">then</span> <span class="nx">writeln</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>Like other domains and arrays, sparse Chapel domains and arrays can
be iterated over…</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Iterating over spsDom and indexing into spsArr:&quot;</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">ij</span> <span class="kd">in</span> <span class="nx">spsDom</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;spsArr(&quot;</span><span class="p">,</span> <span class="nx">ij</span><span class="p">,</span> <span class="s">&quot;) = &quot;</span><span class="p">,</span> <span class="nx">spsArr</span><span class="p">(</span><span class="nx">ij</span><span class="p">));</span>
<span class="nx">writeln</span><span class="p">();</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Iterating over spsArr:&quot;</span><span class="p">);</span>
<span class="k">for</span> <span class="nx">a</span> <span class="kd">in</span> <span class="nx">spsArr</span> <span class="k">do</span>
  <span class="nx">writeln</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>…reductions can be taken…</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sparseSum</span> <span class="o">=</span> <span class="o">+</span> <span class="k">reduce</span> <span class="nx">spsArr</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">denseSum</span> <span class="o">=</span> <span class="o">+</span> <span class="k">reduce</span> <span class="p">[</span><span class="nx">ij</span> <span class="kd">in</span> <span class="nx">dnsDom</span><span class="p">]</span> <span class="nx">spsArr</span><span class="p">(</span><span class="nx">ij</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;the sum of the sparse elements is: &quot;</span><span class="p">,</span> <span class="nx">sparseSum</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;the sum of the dense elements is: &quot;</span><span class="p">,</span> <span class="nx">denseSum</span><span class="p">);</span>
<span class="nx">writeln</span><span class="p">();</span>
</pre></div>
</div>
<p>…and slices will be allowed to be taken (sparse slices of dense
arrays, dense slices of sparse arrays, sparse slices of sparse
arrays, etc.), but those aren’t implemented yet…</p>
<p>OK, let’s clear things out and start again, this time defining a
sparse domain whose diagonal elements are represented.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">spsDom</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>     <span class="c1">// empty the sparse index set</span>
<span class="nx">spsArr</span><span class="p">.</span><span class="nx">IRV</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>   <span class="c1">// reset the IRV</span>

<span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span>
  <span class="nx">spsDom</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">i</span><span class="p">);</span>

<span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">spsDom</span><span class="p">]</span> <span class="nx">spsArr</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after resetting and adding the diagonal:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>Here are some other ways to enumerate sparse indices.  You can
assign a sparse domain a tuple of indices:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="nx">spsDom</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
<span class="nx">spsDom</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">n</span><span class="p">));</span>

<span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">spsDom</span><span class="p">]</span> <span class="nx">spsArr</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after resetting and assigning a tuple of indices:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>You can also define an iterator and have it generate the sparse
indices:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">iter</span> <span class="nf">antiDiag</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="kd">in</span> <span class="mi">1</span><span class="o">..</span><span class="nx">n</span> <span class="k">do</span>
    <span class="k">yield</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">spsDom</span> <span class="o">=</span> <span class="nx">antiDiag</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>

<span class="p">[(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="kd">in</span> <span class="nx">spsDom</span><span class="p">]</span> <span class="nx">spsArr</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="o">=</span> <span class="nx">computeVal</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>

<span class="nx">writeln</span><span class="p">(</span><span class="s">&quot;Printing spsArr after resetting and assigning the antiDiag iterator:&quot;</span><span class="p">);</span>
<span class="nx">writeSpsArr</span><span class="p">();</span>
</pre></div>
</div>
<p>We’ll close with a brief note on performance: Chapel’s default
single-locale sparse format represents the domain using a dense
sorted vector of explicitly represented indices and the array using
a dense vector of elements.  This format is general, meaning that
we can support 1D, 2D, 3D, …, nD sparse domains and arrays in
addition to the 2D case shown here.  However, it is also very
general, which is why we use it.  As Chapel continues to develop, it
will support additional sparse formats that make various tradeoffs
in efficiency and representation as part of its standard
distribution library.  In addition, advanced users will be able to
define their own sparse domain/array representations using the
user-defined distribution capability.</p>
<p>Regardless of the sparse format used, operations over a sparse
domain’s indices or sparse array’s elements should typically be
proportional to the number of nonzeroes <code class="docutils literal notranslate"><span class="pre">(nnz)</span></code> rather than the size
of the dense bounding box.  Operations like inserting new indices
or testing for membership will tend to vary depending on the
representation.</p>
<p>For example, in the default representation, adding indices in
reverse sorted order will require O(nnz**2) time due to all of the
insertions required.  For this reason, users are encouraged to add
indices in sorted order when performance matters.</p>
<p>Other general rules of thumb when working with sparse domains and
arrays is to make the domains constant (const) whenever possible,
setting their index set in their initializer using a forall
expression or iterator invocation; and to assign sparse domain
indices before declaring arrays over those sparse domains when
possible (to avoid reallocating the arrays more than is necessary.
While the choice of a sparse representations may make the impact of
these decisions more or less crucial, they are good general rules
of thumb.</p>
<p>As a final performance-related note, there are several important
compiler optimizations that remain unimplemented for sparse domains
and arrays.  Today’s implementation is meant to expose users to
Chapel’s sparse concepts, but additional performance will be added
over time.</p>
<p>Anyone reading this far who is interested in exploring more with
sparse domains and arrays in Chapel is encouraged to contact us.
We currently have a Compressed Sparse Row (CSR) sparse domain/array
layout within our modules and an implementation of the NAS CG benchmark
that makes use of it, and would be happy to provide the curious with
full explanations of the features therein, and are open to new suggestions.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="associative.html" class="btn btn-neutral float-right" title="Associative Domains and Arrays" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="slices.html" class="btn btn-neutral float-left" title="Slices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Hewlett Packard Enterprise Development LP

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>