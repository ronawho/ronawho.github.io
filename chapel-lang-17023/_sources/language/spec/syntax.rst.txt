.. default-domain:: chpl

.. _Chapter-Syntax:

Syntax
======

This appendix collects the syntax productions listed throughout the
language specification. There are no new syntax productions listed
in this appendix. The productions are listed both alphabetically and
in application order for convenience.

:ref:`Productions_Listed_Alphabetical_Order`

:ref:`Productions_Listed_Application_Order`

.. _Productions_Listed_Alphabetical_Order:

Productions Listed in Alphabetical Order
----------------------------------------

.. code-block:: syntax

   aligned-range-expression:
     range-expression 'align' expression

   argument-list:
     ( formals[OPT] )

   array-literal:
     rectangular-array-literal
     associative-array-literal

   array-type:
     [ domain-expression ] type-expression

   assignment-operator: one of
      = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=

   assignment-statement:
     lvalue-expression assignment-operator expression

   associative-array-literal:
     [ associative-expr-list ]
     [ associative-expr-list , ]

   associative-domain-literal:
      { associative-expression-list }

   associative-domain-type:
     'domain' ( associative-index-type )

   associative-expr-list:
     index-expr => value-expr
     index-expr => value-expr, associative-expr-list

   associative-expression-list:
      non-range-expression
      non-range-expression, associative-expression-list

   associative-index-type:
     type-expression

   atomic-statement:
     'atomic' statement

   atomic-type:
     'atomic' type-expression

   base-domain-type:
     rectangular-domain-type
     associative-domain-type

   basic-class-type:
     identifier
     identifier ( named-expression-list )

   begin-statement:
     'begin' task-intent-clause[OPT] statement

   binary-digit: one of
     '0' '1'

   binary-digits:
     binary-digit
     binary-digit separator-binary-digits

   binary-expression:
     expression binary-operator expression

   binary-operator: one of
     + - * / % ** & | ^ << >> && || == != <= >= < > 'by' #

   block-statement:
     { statements[OPT] }

   bool-literal: one of
     'true' 'false'

   break-statement:
     'break' identifier[OPT] ;

   bytes-literal:
     interpreted-bytes-literal
     uninterpreted-bytes-literal

   call-expression:
     lvalue-expression ( named-expression-list )
     lvalue-expression [ named-expression-list ]
     parenthesesless-function-identifier

   cast-expression:
     expression : type-expression

   class-declaration-statement:
     'class' identifier class-inherit[OPT] { class-statement-list[OPT] }

   class-inherit:
     : basic-class-type

   class-statement:
     variable-declaration-statement
     method-declaration-statement
     type-declaration-statement
     empty-statement

   class-statement-list:
     class-statement
     class-statement class-statement-list

   class-type:
     basic-class-type
     'owned' basic-class-type
     'shared' basic-class-type
     'borrowed' basic-class-type
     'unmanaged' basic-class-type

   cobegin-statement:
     'cobegin' task-intent-clause[OPT] block-statement

   coforall-statement:
     'coforall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' statement
     'coforall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] block-statement
     'coforall' iteratable-expression task-intent-clause[OPT] 'do' statement
     'coforall' iteratable-expression task-intent-clause[OPT] block-statement

   conditional-statement:
     'if' expression 'then' statement else-part[OPT]
     'if' expression block-statement else-part[OPT]

   config-extern-or-export: one of
     'config' 'extern' 'export'

   continue-statement:
     'continue' identifier[OPT] ;

   counted-range-expression:
     range-expression # expression

   dataparallel-type:
     range-type
     domain-type
     mapped-domain-type
     array-type
     index-type

   default-expression:
     = expression

   defer-statement:
     'defer' statement

   delete-statement:
     'delete' expression-list ;

   digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'

   digits:
     digit
     digit separator-digits

   dmap-value:
     expression

   do-while-statement:
     'do' statement 'while' expression ;

   domain-alignment-expression:
     domain-expression 'align' expression

   domain-assignment-expression:
     domain-name = domain-expression

   domain-expression:
     domain-literal
     domain-name
     domain-assignment-expression
     domain-striding-expression
     domain-alignment-expression
     domain-slice-expression

   domain-literal:
     rectangular-domain-literal
     associative-domain-literal

   domain-name:
     identifier

   domain-slice-expression:
     domain-expression [ slicing-index-set ]
     domain-expression ( slicing-index-set )

   domain-striding-expression:
     domain-expression 'by' expression

   domain-type:
     base-domain-type
     simple-subdomain-type
     sparse-subdomain-type

   double-quote-delimited-characters:
     string-character double-quote-delimited-characters[OPT]
     ' double-quote-delimited-characters[OPT]

   else-part:
     'else' statement

   empty-statement:
     ;

   enum-constant:
     identifier init-part[OPT]

   enum-constant-expression:
     enum-type . identifier

   enum-constant-list:
     enum-constant
     enum-constant , enum-constant-list[OPT]

   enum-declaration-statement:
     'enum' identifier { enum-constant-list }

   enum-type:
     identifier

   exclude-list:
     identifier-list
     $ * $

   exponent-part:
     'e' sign[OPT] digits
     'E' sign[OPT] digits

   exported-procedure-declaration-statement:
     'export' external-name[OPT] 'proc' function-name argument-list return-intent[OPT] return-type[OPT]
       function-body

   expression:
     literal-expression
     variable-expression
     enum-constant-expression
     call-expression
     type-expression
     iteratable-call-expression
     member-access-expression
     new-expression
     query-expression
     cast-expression
     lvalue-expression
     parenthesized-expression
     unary-expression
     binary-expression
     let-expression
     if-expression
     for-expression
     forall-expression
     reduce-expression
     scan-expression
     module-access-expression
     tuple-expression
     tuple-expand-expression
     locale-query-expression
     type-query-expression
     mapped-domain-expression

   expression-list:
     expression
     expression , expression-list

   expression-statement:
     variable-expression ;
     member-access-expression ;
     call-expression ;
     new-expression ;
     let-expression ;

   external-name:
     expression

   external-procedure-declaration-statement:
     'extern' external-name[OPT] 'proc' function-name argument-list return-intent[OPT] return-type[OPT]

   external-record-declaration-statement:
     'extern' external-name[OPT] simple-record-declaration-statement

   external-type-alias-declaration-statement:
     'extern' 'type' type-alias-declaration-list ;

   field-access-expression:
     receiver-clause[OPT] identifier

   for-expression:
     'for' index-var-declaration 'in' iteratable-expression 'do' expression
     'for' iteratable-expression 'do' expression

   for-statement:
     'for' index-var-declaration 'in' iteratable-expression 'do' statement
     'for' index-var-declaration 'in' iteratable-expression block-statement
     'for' iteratable-expression 'do' statement
     'for' iteratable-expression block-statement

   forall-expression:
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' expression
     'forall' iteratable-expression task-intent-clause[OPT] 'do' expression
     [ index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] ] expression
     [ iteratable-expression task-intent-clause[OPT] ] expression

   forall-statement:
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' statement
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] block-statement
     'forall' iteratable-expression task-intent-clause[OPT] 'do' statement
     'forall' iteratable-expression task-intent-clause[OPT] block-statement
     [ index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] ] statement
     [ iteratable-expression task-intent-clause[OPT] ] statement

   formal:
     formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
     formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
     formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
     formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression

   formal-intent:
     'const'
     'const in'
     'const ref'
     'in'
     'out'
     'inout'
     'ref'
     'param'
     'type'

   formal-type:
     : type-expression
     : ? identifier[OPT]

   formals:
     formal
     formal , formals

   function-body:
     block-statement
     return-statement

   function-name:
     identifier
     operator-name

   hexadecimal-digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F' 'a' 'b' 'c' 'd' 'e' 'f'

   hexadecimal-digits:
     hexadecimal-digit
     hexadecimal-digit separator-hexadecimal-digits

   hexadecimal-escape-character:
     '\x' hexadecimal-digits

   identifier:
     letter-or-underscore legal-identifier-chars[OPT]

   identifier-list:
     identifier
     identifier , identifier-list
     tuple-grouped-identifier-list
     tuple-grouped-identifier-list , identifier-list

   if-expression:
     'if' expression 'then' expression 'else' expression
     'if' expression 'then' expression

   imaginary-literal:
     real-literal 'i'
     integer-literal 'i'

   import-expression:
     module-or-symbol-rename
     module-or-symbol-base unqualified-list

   import-expression-list:
     import-expression
     import-expression , import-expression-list

   import-statement:
     privacy-specifier[OPT] 'import' import-expression-list ;

   index-expr:
     expression

   index-type:
     'index' ( domain-expression )

   index-var-declaration:
     identifier
     tuple-grouped-identifier-list

   init-part:
     = expression

   initialization-part:
     = expression

   integer-literal:
     digits
     '0x' hexadecimal-digits
     '0X' hexadecimal-digits
     '0o' octal-digits
     '0O' octal-digits
     '0b' binary-digits
     '0B' binary-digits

   integer-parameter-expression:
     expression

   interpreted-bytes-literal:
     b" double-quote-delimited-characters[OPT] "
     b' single-quote-delimited-characters[OPT] '

   interpreted-string-literal:
     " double-quote-delimited-characters[OPT] "
     ' single-quote-delimited-characters[OPT] '

   io-expression:
     expression
     io-expression io-operator expression

   io-operator:
     <~>

   io-statement:
     io-expression io-operator expression

   iteratable-call-expression:
     call-expression

   iteratable-expression:
     expression
     'zip' ( expression-list )

   iterator-body:
     block-statement
     yield-statement

   iterator-declaration-statement:
     privacy-specifier[OPT] 'iter' iterator-name argument-list[OPT] yield-intent[OPT] yield-type[OPT] where-clause[OPT]
     iterator-body

   iterator-name:
     identifier

   label-statement:
     'label' identifier statement

   legal-identifier-char:
     letter-or-underscore
     digit
     '$'

   legal-identifier-chars:
     legal-identifier-char legal-identifier-chars[OPT]

   let-expression:
     'let' variable-declaration-list 'in' expression

   letter: one of
     'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
     'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'

   letter-or-underscore:
     letter
     '_'

   limitation-clause:
     'except' exclude-list
     'only' rename-list[OPT]

   literal-expression:
     bool-literal
     integer-literal
     real-literal
     imaginary-literal
     string-literal
     bytes-literal
     range-literal
     domain-literal
     array-literal

   locale-query-expression:
     expression . 'locale'

   lvalue-expression:
     variable-expression
     member-access-expression
     call-expression
     parenthesized-expression

   mapped-domain-expression:
     domain-expression 'dmapped' dmap-value

   mapped-domain-type:
     domain-type 'dmapped' dmap-value

   member-access-expression:
     field-access-expression
     method-call-expression

   method-call-expression:
     receiver-clause[OPT] expression ( named-expression-list )
     receiver-clause[OPT] expression [ named-expression-list ]
     receiver-clause[OPT] parenthesesless-function-identifier

   method-declaration-statement:
     procedure-kind[OPT] proc-or-iter this-intent[OPT] type-binding[OPT] function-name argument-list[OPT]
       return-intent[OPT] return-type[OPT] where-clause[OPT] function-body

   module-access-expression:
     module-identifier-list . identifier

   module-declaration-statement:
     privacy-specifier[OPT] prototype-specifier[OPT] 'module' module-identifier block-statement

   module-identifier:
     identifier

   module-identifier-list:
     module-identifier
     module-identifier . module-identifier-list

   module-or-enum-name:
     rename-base
     identifier . module-or-enum-name

   module-or-enum-name-list:
     module-or-enum-name limitation-clause[OPT]
     module-or-enum-name , module-or-enum-name-list

   module-or-symbol-base:
     identifier
     identifier . module-or-symbol-base

   module-or-symbol-rename:
     rename-base
     identifier . module-or-symbol-rename

   named-expression:
     expression
     identifier = expression

   named-expression-list:
     named-expression
     named-expression , named-expression-list

   new-expression:
     'new' type-expression ( argument-list )

   non-range-expression:
      expression

   octal-digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7'

   octal-digits:
     octal-digit
     octal-digit separator-octal-digits

   on-statement:
     'on' expression 'do' statement
     'on' expression block-statement

   operator-name: one of
     + - * / % ** ! == != <= >= < > << >> & | ^ ~
     = += -= *= /= %= **= &= |= ^= <<= >>= <=> <~>

   p-exponent-part:
     'p' sign[OPT] digits
     'P' sign[OPT] digits

   param-for-statement:
     'for' 'param' identifier 'in' param-iteratable-expression 'do' statement
     'for' 'param' identifier 'in' param-iteratable-expression block-statement

   param-iteratable-expression:
     range-literal
     range-literal 'by' integer-literal

   parenthesesless-function-identifier:
     identifier

   parenthesized-expression:
     ( expression )

   primitive-type:
     'void'
     'nothing'
     'bool' primitive-type-parameter-part[OPT]
     'int' primitive-type-parameter-part[OPT]
     'uint' primitive-type-parameter-part[OPT]
     'real' primitive-type-parameter-part[OPT]
     'imag' primitive-type-parameter-part[OPT]
     'complex' primitive-type-parameter-part[OPT]
     'string'
     'bytes'
     'enum'
     'record'
     'class'
     'owned'
     'shared'
     'unmanaged'
     'borrowed'

   primitive-type-parameter-part:
     ( integer-parameter-expression )

   privacy-specifier:
     'private'
     'public'

   proc-or-iter:
     'proc'
     'iter'

   procedure-declaration-statement:
     privacy-specifier[OPT] procedure-kind[OPT] 'proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
       function-body

   procedure-kind:
     'inline'
     'export'
     'extern'
     'override'

   prototype-specifier:
     'prototype'

   query-expression:
     ? identifier[OPT]

   range-expression:
     expression
     strided-range-expression
     counted-range-expression
     aligned-range-expression
     sliced-range-expression

   range-expression-list:
     range-expression
     range-expression, range-expression-list

   range-literal:
     expression .. expression
     expression ..< expression
     expression ..
     .. expression
     ..< expression
     ..

   range-type:
     'range' ( named-expression-list )

   real-literal:
     digits[OPT] . digits exponent-part[OPT]
     digits .[OPT] exponent-part
     '0x' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
     '0X' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
     '0x' hexadecimal-digits .[OPT] p-exponent-part
     '0X' hexadecimal-digits .[OPT] p-exponent-part

   receiver-clause:
     expression .

   record-declaration-statement:
     simple-record-declaration-statement
     external-record-declaration-statement

   record-statement:
     variable-declaration-statement
     method-declaration-statement
     type-declaration-statement
     empty-statement

   record-statement-list:
     record-statement
     record-statement record-statement-list

   record-type:
     identifier
     identifier ( named-expression-list )

   rectangular-array-literal:
     [ expression-list ]
     [ expression-list , ]

   rectangular-domain-literal:
     { range-expression-list }

   rectangular-domain-type:
     'domain' ( named-expression-list )

   reduce-expression:
     reduce-scan-operator 'reduce' iteratable-expression
     class-type 'reduce' iteratable-expression

   reduce-scan-operator: one of
     + * && || & | ^ 'min' 'max' 'minmax' 'minloc' 'maxloc'

   remote-variable-declaration-statement:
     'on' expression variable-declaration-statement

   rename-base:
     identifier 'as' identifier
     identifier 'as' _
     identifier

   rename-list:
     rename-base
     rename-base , rename-list

   return-intent:
     'const'
     'const ref'
     'ref'
     'param'
     'type'

   return-statement:
     'return' expression[OPT] ;

   return-type:
     : type-expression

   scan-expression:
     reduce-scan-operator 'scan' iteratable-expression
     class-type 'scan' iteratable-expression

   select-statement:
     'select' expression { when-statements }

   separator-binary-digits:
     binary-digit
     '_'
     binary-digit separator-binary-digits
     '_' separator-binary-digits

   separator-digits:
     digit
     '_'
     digit separator-digits
     '_' separator-digits

   separator-hexadecimal-digits:
     hexadecimal-digit
     '_'
     hexadecimal-digit separator-hexadecimal-digits
     '_' separator-hexadecimal-digits

   separator-octal-digits:
     octal-digit
     '_'
     octal-digit separator-octal-digits
     '_' separator-octal-digits

   serial-statement:
     'serial' expression[OPT] 'do' statement
     'serial' expression[OPT] block-statement

   sign: one of
     + -

   simple-escape-character: one of
     \' \" \? \\ \a \b \f \n \r \t \v

   simple-record-declaration-statement:
     'record' identifier { record-statement-list }

   simple-subdomain-type:
     'subdomain' ( domain-expression )

   single-quote-delimited-characters:
     string-character single-quote-delimited-characters[OPT]
     " single-quote-delimited-characters[OPT]

   single-type:
     'single' type-expression

   sliced-range-expression:
     range-expression ( range-expression )
     range-expression [ range-expression ]

   slicing-index-set:
     domain-expression
     range-expression-list

   sparse-subdomain-type:
     'sparse' 'subdomain'[OPT] ( domain-expression )

   statement:
     block-statement
     expression-statement
     assignment-statement
     swap-statement
     io-statement
     conditional-statement
     select-statement
     while-do-statement
     do-while-statement
     for-statement
     label-statement
     break-statement
     continue-statement
     param-for-statement
     use-statement
     import-statement
     defer-statement
     empty-statement
     return-statement
     yield-statement
     module-declaration-statement
     procedure-declaration-statement
     external-procedure-declaration-statement
     exported-procedure-declaration-statement
     iterator-declaration-statement
     method-declaration-statement
     type-declaration-statement
     variable-declaration-statement
     remote-variable-declaration-statement
     on-statement
     cobegin-statement
     coforall-statement
     begin-statement
     sync-statement
     serial-statement
     atomic-statement
     forall-statement
     delete-statement

   statements:
     statement
     statement statements

   step-expression:
     expression

   strided-range-expression:
     range-expression 'by' step-expression

   string-character:
     any character except the double quote, single quote, or new line
     simple-escape-character
     hexadecimal-escape-character

   string-literal:
     interpreted-string-literal
     uninterpreted-string-literal

   structured-type:
     class-type
     record-type
     union-type
     tuple-type

   swap-operator:
     <=>

   swap-statement:
     lvalue-expression swap-operator lvalue-expression

   sync-statement:
     'sync' statement
     'sync' block-statement

   sync-type:
     'sync' type-expression

   synchronization-type:
     sync-type
     single-type
     atomic-type

   task-intent-clause:
     'with' ( task-intent-list )

   task-intent-item:
     formal-intent identifier
     reduce-scan-operator 'reduce' identifier
     class-type 'reduce' identifier
     task-private-var-decl

   task-intent-list:
     task-intent-item
     task-intent-item, task-intent-list

   task-private-var-decl:
     task-private-var-kind identifier type-part[OPT] initialization-part[OPT]

   task-private-var-kind:
     'const'
     'var'
     'ref'

   this-intent:
     'param'
     'type'
     'ref'
     'const ref'
     'const'

   tuple-component:
     expression
     '_'

   tuple-component-list:
     tuple-component
     tuple-component , tuple-component-list

   tuple-expand-expression:
     ( ... expression )

   tuple-expression:
     ( tuple-component , )
     ( tuple-component , tuple-component-list )
     ( tuple-component , tuple-component-list , )

   tuple-grouped-identifier-list:
     ( identifier-list )

   tuple-type:
     ( type-expression , type-list )
     ( type-expression , )

   type-alias-declaration:
     identifier = type-expression
     identifier

   type-alias-declaration-list:
     type-alias-declaration
     type-alias-declaration , type-alias-declaration-list

   type-alias-declaration-statement:
     privacy-specifier[OPT] 'config'[OPT] 'type' type-alias-declaration-list ;
     external-type-alias-declaration-statement

   type-binding:
     identifier .
     '(' expression ')' .

   type-declaration-statement:
     enum-declaration-statement
     class-declaration-statement
     record-declaration-statement
     union-declaration-statement
     type-alias-declaration-statement

   type-expression:
     primitive-type
     enum-type
     structured-type
     dataparallel-type
     synchronization-type
     lvalue-expression
     if-expression
     unary-expression
     binary-expression

   type-list:
     type-expression
     type-expression , type-list

   type-part:
     : type-expression

   type-query-expression:
     expression . 'type'

   unary-expression:
     unary-operator expression

   unary-operator: one of
     + - ~ !

   uninterpreted-bytes-literal:
     b""" uninterpreted-double-quote-delimited-characters """
     b''' uninterpreted-single-quote-delimited-characters '''

   uninterpreted-double-quote-delimited-characters:
     uninterpreted-double-quote-string-character uninterpreted-double-quote-delimited-characters[OPT]

   uninterpreted-double-quote-string-character:
     any character except three double quotes in a row

   uninterpreted-single-quote-delimited-characters:
     uninterpreted-single-quote-string-character uninterpreted-single-quote-delimited-characters[OPT]

   uninterpreted-single-quote-string-character:
     any character except three single quotes in a row

   uninterpreted-string-literal:
     """ uninterpreted-double-quote-delimited-characters """
     ''' uninterpreted-single-quote-delimited-characters '''

   union-declaration-statement:
     'extern'[OPT] 'union' identifier { union-statement-list }

   union-statement:
     type-declaration-statement
     procedure-declaration-statement
     iterator-declaration-statement
     variable-declaration-statement
     empty-statement

   union-statement-list:
     union-statement
     union-statement union-statement-list

   union-type:
     identifier

   unqualified-list:
     . { rename-list }

   use-statement:
     privacy-specifier[OPT] 'use' module-or-enum-name-list ;

   value-expr:
     expression

   variable-argument-expression:
     ... expression
     ... ? identifier[OPT]
     ...

   variable-declaration:
     identifier-list type-part[OPT] initialization-part[OPT]

   variable-declaration-list:
     variable-declaration
     variable-declaration , variable-declaration-list

   variable-declaration-statement:
     privacy-specifier[OPT] config-extern-or-export[OPT] variable-kind variable-declaration-list ;

   variable-expression:
     identifier 

   variable-kind:
     'param'
     'const'
     'var'
     'ref'
     'const ref'

   when-statement:
     'when' expression-list 'do' statement
     'when' expression-list block-statement
     'otherwise' statement
     'otherwise' 'do' statement

   when-statements:
     when-statement
     when-statement when-statements

   where-clause:
     'where' expression

   while-do-statement:
     'while' expression 'do' statement
     'while' expression block-statement

   yield-intent:
     'const'
     'const ref'
     'ref'
     'param'
     'type'

   yield-statement:
     'yield' expression ;

   yield-type:
     : type-expression

.. _Productions_Listed_Application_Order:

Productions Listed in Application Order
---------------------------------------

.. code-block:: syntax

   module-declaration-statement:
     privacy-specifier[OPT] prototype-specifier[OPT] 'module' module-identifier block-statement

   privacy-specifier:
     'private'
     'public'

   prototype-specifier:
     'prototype'

   module-identifier:
     identifier

   block-statement:
     { statements[OPT] }

   identifier:
     letter-or-underscore legal-identifier-chars[OPT]

   statements:
     statement
     statement statements

   letter-or-underscore:
     letter
     '_'

   legal-identifier-chars:
     legal-identifier-char legal-identifier-chars[OPT]

   statement:
     block-statement
     expression-statement
     assignment-statement
     swap-statement
     io-statement
     conditional-statement
     select-statement
     while-do-statement
     do-while-statement
     for-statement
     label-statement
     break-statement
     continue-statement
     param-for-statement
     use-statement
     import-statement
     defer-statement
     empty-statement
     return-statement
     yield-statement
     module-declaration-statement
     procedure-declaration-statement
     external-procedure-declaration-statement
     exported-procedure-declaration-statement
     iterator-declaration-statement
     method-declaration-statement
     type-declaration-statement
     variable-declaration-statement
     remote-variable-declaration-statement
     on-statement
     cobegin-statement
     coforall-statement
     begin-statement
     sync-statement
     serial-statement
     atomic-statement
     forall-statement
     delete-statement

   letter: one of
     'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
     'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'

   legal-identifier-char:
     letter-or-underscore
     digit
     '$'

   expression-statement:
     variable-expression ;
     member-access-expression ;
     call-expression ;
     new-expression ;
     let-expression ;

   assignment-statement:
     lvalue-expression assignment-operator expression

   swap-statement:
     lvalue-expression swap-operator lvalue-expression

   io-statement:
     io-expression io-operator expression

   conditional-statement:
     'if' expression 'then' statement else-part[OPT]
     'if' expression block-statement else-part[OPT]

   select-statement:
     'select' expression { when-statements }

   while-do-statement:
     'while' expression 'do' statement
     'while' expression block-statement

   do-while-statement:
     'do' statement 'while' expression ;

   for-statement:
     'for' index-var-declaration 'in' iteratable-expression 'do' statement
     'for' index-var-declaration 'in' iteratable-expression block-statement
     'for' iteratable-expression 'do' statement
     'for' iteratable-expression block-statement

   label-statement:
     'label' identifier statement

   break-statement:
     'break' identifier[OPT] ;

   continue-statement:
     'continue' identifier[OPT] ;

   param-for-statement:
     'for' 'param' identifier 'in' param-iteratable-expression 'do' statement
     'for' 'param' identifier 'in' param-iteratable-expression block-statement

   use-statement:
     privacy-specifier[OPT] 'use' module-or-enum-name-list ;

   import-statement:
     privacy-specifier[OPT] 'import' import-expression-list ;

   defer-statement:
     'defer' statement

   empty-statement:
     ;

   return-statement:
     'return' expression[OPT] ;

   yield-statement:
     'yield' expression ;

   procedure-declaration-statement:
     privacy-specifier[OPT] procedure-kind[OPT] 'proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT]
       function-body

   external-procedure-declaration-statement:
     'extern' external-name[OPT] 'proc' function-name argument-list return-intent[OPT] return-type[OPT]

   exported-procedure-declaration-statement:
     'export' external-name[OPT] 'proc' function-name argument-list return-intent[OPT] return-type[OPT]
       function-body

   iterator-declaration-statement:
     privacy-specifier[OPT] 'iter' iterator-name argument-list[OPT] yield-intent[OPT] yield-type[OPT] where-clause[OPT]
     iterator-body

   method-declaration-statement:
     procedure-kind[OPT] proc-or-iter this-intent[OPT] type-binding[OPT] function-name argument-list[OPT]
       return-intent[OPT] return-type[OPT] where-clause[OPT] function-body

   type-declaration-statement:
     enum-declaration-statement
     class-declaration-statement
     record-declaration-statement
     union-declaration-statement
     type-alias-declaration-statement

   variable-declaration-statement:
     privacy-specifier[OPT] config-extern-or-export[OPT] variable-kind variable-declaration-list ;

   remote-variable-declaration-statement:
     'on' expression variable-declaration-statement

   on-statement:
     'on' expression 'do' statement
     'on' expression block-statement

   cobegin-statement:
     'cobegin' task-intent-clause[OPT] block-statement

   coforall-statement:
     'coforall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' statement
     'coforall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] block-statement
     'coforall' iteratable-expression task-intent-clause[OPT] 'do' statement
     'coforall' iteratable-expression task-intent-clause[OPT] block-statement

   begin-statement:
     'begin' task-intent-clause[OPT] statement

   sync-statement:
     'sync' statement
     'sync' block-statement

   serial-statement:
     'serial' expression[OPT] 'do' statement
     'serial' expression[OPT] block-statement

   atomic-statement:
     'atomic' statement

   forall-statement:
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' statement
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] block-statement
     'forall' iteratable-expression task-intent-clause[OPT] 'do' statement
     'forall' iteratable-expression task-intent-clause[OPT] block-statement
     [ index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] ] statement
     [ iteratable-expression task-intent-clause[OPT] ] statement

   delete-statement:
     'delete' expression-list ;

   digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'

   variable-expression:
     identifier 

   member-access-expression:
     field-access-expression
     method-call-expression

   call-expression:
     lvalue-expression ( named-expression-list )
     lvalue-expression [ named-expression-list ]
     parenthesesless-function-identifier

   new-expression:
     'new' type-expression ( argument-list )

   let-expression:
     'let' variable-declaration-list 'in' expression

   lvalue-expression:
     variable-expression
     member-access-expression
     call-expression
     parenthesized-expression

   assignment-operator: one of
      = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=

   expression:
     literal-expression
     variable-expression
     enum-constant-expression
     call-expression
     type-expression
     iteratable-call-expression
     member-access-expression
     new-expression
     query-expression
     cast-expression
     lvalue-expression
     parenthesized-expression
     unary-expression
     binary-expression
     let-expression
     if-expression
     for-expression
     forall-expression
     reduce-expression
     scan-expression
     module-access-expression
     tuple-expression
     tuple-expand-expression
     locale-query-expression
     type-query-expression
     mapped-domain-expression

   swap-operator:
     <=>

   io-expression:
     expression
     io-expression io-operator expression

   io-operator:
     <~>

   else-part:
     'else' statement

   when-statements:
     when-statement
     when-statement when-statements

   index-var-declaration:
     identifier
     tuple-grouped-identifier-list

   iteratable-expression:
     expression
     'zip' ( expression-list )

   param-iteratable-expression:
     range-literal
     range-literal 'by' integer-literal

   module-or-enum-name-list:
     module-or-enum-name limitation-clause[OPT]
     module-or-enum-name , module-or-enum-name-list

   import-expression-list:
     import-expression
     import-expression , import-expression-list

   procedure-kind:
     'inline'
     'export'
     'extern'
     'override'

   function-name:
     identifier
     operator-name

   argument-list:
     ( formals[OPT] )

   return-intent:
     'const'
     'const ref'
     'ref'
     'param'
     'type'

   return-type:
     : type-expression

   where-clause:
     'where' expression

   function-body:
     block-statement
     return-statement

   external-name:
     expression

   iterator-name:
     identifier

   yield-intent:
     'const'
     'const ref'
     'ref'
     'param'
     'type'

   yield-type:
     : type-expression

   iterator-body:
     block-statement
     yield-statement

   proc-or-iter:
     'proc'
     'iter'

   this-intent:
     'param'
     'type'
     'ref'
     'const ref'
     'const'

   type-binding:
     identifier .
     '(' expression ')' .

   enum-declaration-statement:
     'enum' identifier { enum-constant-list }

   class-declaration-statement:
     'class' identifier class-inherit[OPT] { class-statement-list[OPT] }

   record-declaration-statement:
     simple-record-declaration-statement
     external-record-declaration-statement

   union-declaration-statement:
     'extern'[OPT] 'union' identifier { union-statement-list }

   type-alias-declaration-statement:
     privacy-specifier[OPT] 'config'[OPT] 'type' type-alias-declaration-list ;
     external-type-alias-declaration-statement

   config-extern-or-export: one of
     'config' 'extern' 'export'

   variable-kind:
     'param'
     'const'
     'var'
     'ref'
     'const ref'

   variable-declaration-list:
     variable-declaration
     variable-declaration , variable-declaration-list

   task-intent-clause:
     'with' ( task-intent-list )

   expression-list:
     expression
     expression , expression-list

   field-access-expression:
     receiver-clause[OPT] identifier

   method-call-expression:
     receiver-clause[OPT] expression ( named-expression-list )
     receiver-clause[OPT] expression [ named-expression-list ]
     receiver-clause[OPT] parenthesesless-function-identifier

   named-expression-list:
     named-expression
     named-expression , named-expression-list

   parenthesesless-function-identifier:
     identifier

   type-expression:
     primitive-type
     enum-type
     structured-type
     dataparallel-type
     synchronization-type
     lvalue-expression
     if-expression
     unary-expression
     binary-expression

   parenthesized-expression:
     ( expression )

   literal-expression:
     bool-literal
     integer-literal
     real-literal
     imaginary-literal
     string-literal
     bytes-literal
     range-literal
     domain-literal
     array-literal

   enum-constant-expression:
     enum-type . identifier

   iteratable-call-expression:
     call-expression

   query-expression:
     ? identifier[OPT]

   cast-expression:
     expression : type-expression

   unary-expression:
     unary-operator expression

   binary-expression:
     expression binary-operator expression

   if-expression:
     'if' expression 'then' expression 'else' expression
     'if' expression 'then' expression

   for-expression:
     'for' index-var-declaration 'in' iteratable-expression 'do' expression
     'for' iteratable-expression 'do' expression

   forall-expression:
     'forall' index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] 'do' expression
     'forall' iteratable-expression task-intent-clause[OPT] 'do' expression
     [ index-var-declaration 'in' iteratable-expression task-intent-clause[OPT] ] expression
     [ iteratable-expression task-intent-clause[OPT] ] expression

   reduce-expression:
     reduce-scan-operator 'reduce' iteratable-expression
     class-type 'reduce' iteratable-expression

   scan-expression:
     reduce-scan-operator 'scan' iteratable-expression
     class-type 'scan' iteratable-expression

   module-access-expression:
     module-identifier-list . identifier

   tuple-expression:
     ( tuple-component , )
     ( tuple-component , tuple-component-list )
     ( tuple-component , tuple-component-list , )

   tuple-expand-expression:
     ( ... expression )

   locale-query-expression:
     expression . 'locale'

   type-query-expression:
     expression . 'type'

   mapped-domain-expression:
     domain-expression 'dmapped' dmap-value

   when-statement:
     'when' expression-list 'do' statement
     'when' expression-list block-statement
     'otherwise' statement
     'otherwise' 'do' statement

   tuple-grouped-identifier-list:
     ( identifier-list )

   range-literal:
     expression .. expression
     expression ..< expression
     expression ..
     .. expression
     ..< expression
     ..

   integer-literal:
     digits
     '0x' hexadecimal-digits
     '0X' hexadecimal-digits
     '0o' octal-digits
     '0O' octal-digits
     '0b' binary-digits
     '0B' binary-digits

   module-or-enum-name:
     rename-base
     identifier . module-or-enum-name

   limitation-clause:
     'except' exclude-list
     'only' rename-list[OPT]

   import-expression:
     module-or-symbol-rename
     module-or-symbol-base unqualified-list

   operator-name: one of
     + - * / % ** ! == != <= >= < > << >> & | ^ ~
     = += -= *= /= %= **= &= |= ^= <<= >>= <=> <~>

   formals:
     formal
     formal , formals

   enum-constant-list:
     enum-constant
     enum-constant , enum-constant-list[OPT]

   class-inherit:
     : basic-class-type

   class-statement-list:
     class-statement
     class-statement class-statement-list

   simple-record-declaration-statement:
     'record' identifier { record-statement-list }

   external-record-declaration-statement:
     'extern' external-name[OPT] simple-record-declaration-statement

   union-statement-list:
     union-statement
     union-statement union-statement-list

   type-alias-declaration-list:
     type-alias-declaration
     type-alias-declaration , type-alias-declaration-list

   external-type-alias-declaration-statement:
     'extern' 'type' type-alias-declaration-list ;

   variable-declaration:
     identifier-list type-part[OPT] initialization-part[OPT]

   task-intent-list:
     task-intent-item
     task-intent-item, task-intent-list

   receiver-clause:
     expression .

   named-expression:
     expression
     identifier = expression

   primitive-type:
     'void'
     'nothing'
     'bool' primitive-type-parameter-part[OPT]
     'int' primitive-type-parameter-part[OPT]
     'uint' primitive-type-parameter-part[OPT]
     'real' primitive-type-parameter-part[OPT]
     'imag' primitive-type-parameter-part[OPT]
     'complex' primitive-type-parameter-part[OPT]
     'string'
     'bytes'
     'enum'
     'record'
     'class'
     'owned'
     'shared'
     'unmanaged'
     'borrowed'

   enum-type:
     identifier

   structured-type:
     class-type
     record-type
     union-type
     tuple-type

   dataparallel-type:
     range-type
     domain-type
     mapped-domain-type
     array-type
     index-type

   synchronization-type:
     sync-type
     single-type
     atomic-type

   bool-literal: one of
     'true' 'false'

   real-literal:
     digits[OPT] . digits exponent-part[OPT]
     digits .[OPT] exponent-part
     '0x' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
     '0X' hexadecimal-digits[OPT] . hexadecimal-digits p-exponent-part[OPT]
     '0x' hexadecimal-digits .[OPT] p-exponent-part
     '0X' hexadecimal-digits .[OPT] p-exponent-part

   imaginary-literal:
     real-literal 'i'
     integer-literal 'i'

   string-literal:
     interpreted-string-literal
     uninterpreted-string-literal

   bytes-literal:
     interpreted-bytes-literal
     uninterpreted-bytes-literal

   domain-literal:
     rectangular-domain-literal
     associative-domain-literal

   array-literal:
     rectangular-array-literal
     associative-array-literal

   unary-operator: one of
     + - ~ !

   binary-operator: one of
     + - * / % ** & | ^ << >> && || == != <= >= < > 'by' #

   reduce-scan-operator: one of
     + * && || & | ^ 'min' 'max' 'minmax' 'minloc' 'maxloc'

   class-type:
     basic-class-type
     'owned' basic-class-type
     'shared' basic-class-type
     'borrowed' basic-class-type
     'unmanaged' basic-class-type

   module-identifier-list:
     module-identifier
     module-identifier . module-identifier-list

   tuple-component:
     expression
     '_'

   tuple-component-list:
     tuple-component
     tuple-component , tuple-component-list

   domain-expression:
     domain-literal
     domain-name
     domain-assignment-expression
     domain-striding-expression
     domain-alignment-expression
     domain-slice-expression

   dmap-value:
     expression

   identifier-list:
     identifier
     identifier , identifier-list
     tuple-grouped-identifier-list
     tuple-grouped-identifier-list , identifier-list

   digits:
     digit
     digit separator-digits

   hexadecimal-digits:
     hexadecimal-digit
     hexadecimal-digit separator-hexadecimal-digits

   octal-digits:
     octal-digit
     octal-digit separator-octal-digits

   binary-digits:
     binary-digit
     binary-digit separator-binary-digits

   rename-base:
     identifier 'as' identifier
     identifier 'as' _
     identifier

   exclude-list:
     identifier-list
     $ * $

   rename-list:
     rename-base
     rename-base , rename-list

   module-or-symbol-rename:
     rename-base
     identifier . module-or-symbol-rename

   module-or-symbol-base:
     identifier
     identifier . module-or-symbol-base

   unqualified-list:
     . { rename-list }

   formal:
     formal-intent[OPT] identifier formal-type[OPT] default-expression[OPT]
     formal-intent[OPT] identifier formal-type[OPT] variable-argument-expression
     formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] default-expression[OPT]
     formal-intent[OPT] tuple-grouped-identifier-list formal-type[OPT] variable-argument-expression

   enum-constant:
     identifier init-part[OPT]

   basic-class-type:
     identifier
     identifier ( named-expression-list )

   class-statement:
     variable-declaration-statement
     method-declaration-statement
     type-declaration-statement
     empty-statement

   record-statement-list:
     record-statement
     record-statement record-statement-list

   union-statement:
     type-declaration-statement
     procedure-declaration-statement
     iterator-declaration-statement
     variable-declaration-statement
     empty-statement

   type-alias-declaration:
     identifier = type-expression
     identifier

   type-part:
     : type-expression

   initialization-part:
     = expression

   task-intent-item:
     formal-intent identifier
     reduce-scan-operator 'reduce' identifier
     class-type 'reduce' identifier
     task-private-var-decl

   primitive-type-parameter-part:
     ( integer-parameter-expression )

   record-type:
     identifier
     identifier ( named-expression-list )

   union-type:
     identifier

   tuple-type:
     ( type-expression , type-list )
     ( type-expression , )

   range-type:
     'range' ( named-expression-list )

   domain-type:
     base-domain-type
     simple-subdomain-type
     sparse-subdomain-type

   mapped-domain-type:
     domain-type 'dmapped' dmap-value

   array-type:
     [ domain-expression ] type-expression

   index-type:
     'index' ( domain-expression )

   sync-type:
     'sync' type-expression

   single-type:
     'single' type-expression

   atomic-type:
     'atomic' type-expression

   exponent-part:
     'e' sign[OPT] digits
     'E' sign[OPT] digits

   p-exponent-part:
     'p' sign[OPT] digits
     'P' sign[OPT] digits

   interpreted-string-literal:
     " double-quote-delimited-characters[OPT] "
     ' single-quote-delimited-characters[OPT] '

   uninterpreted-string-literal:
     """ uninterpreted-double-quote-delimited-characters """
     ''' uninterpreted-single-quote-delimited-characters '''

   interpreted-bytes-literal:
     b" double-quote-delimited-characters[OPT] "
     b' single-quote-delimited-characters[OPT] '

   uninterpreted-bytes-literal:
     b""" uninterpreted-double-quote-delimited-characters """
     b''' uninterpreted-single-quote-delimited-characters '''

   rectangular-domain-literal:
     { range-expression-list }

   associative-domain-literal:
      { associative-expression-list }

   rectangular-array-literal:
     [ expression-list ]
     [ expression-list , ]

   associative-array-literal:
     [ associative-expr-list ]
     [ associative-expr-list , ]

   domain-name:
     identifier

   domain-assignment-expression:
     domain-name = domain-expression

   domain-striding-expression:
     domain-expression 'by' expression

   domain-alignment-expression:
     domain-expression 'align' expression

   domain-slice-expression:
     domain-expression [ slicing-index-set ]
     domain-expression ( slicing-index-set )

   separator-digits:
     digit
     '_'
     digit separator-digits
     '_' separator-digits

   hexadecimal-digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F' 'a' 'b' 'c' 'd' 'e' 'f'

   separator-hexadecimal-digits:
     hexadecimal-digit
     '_'
     hexadecimal-digit separator-hexadecimal-digits
     '_' separator-hexadecimal-digits

   octal-digit: one of
     '0' '1' '2' '3' '4' '5' '6' '7'

   separator-octal-digits:
     octal-digit
     '_'
     octal-digit separator-octal-digits
     '_' separator-octal-digits

   binary-digit: one of
     '0' '1'

   separator-binary-digits:
     binary-digit
     '_'
     binary-digit separator-binary-digits
     '_' separator-binary-digits

   formal-intent:
     'const'
     'const in'
     'const ref'
     'in'
     'out'
     'inout'
     'ref'
     'param'
     'type'

   formal-type:
     : type-expression
     : ? identifier[OPT]

   default-expression:
     = expression

   variable-argument-expression:
     ... expression
     ... ? identifier[OPT]
     ...

   init-part:
     = expression

   record-statement:
     variable-declaration-statement
     method-declaration-statement
     type-declaration-statement
     empty-statement

   task-private-var-decl:
     task-private-var-kind identifier type-part[OPT] initialization-part[OPT]

   integer-parameter-expression:
     expression

   type-list:
     type-expression
     type-expression , type-list

   base-domain-type:
     rectangular-domain-type
     associative-domain-type

   simple-subdomain-type:
     'subdomain' ( domain-expression )

   sparse-subdomain-type:
     'sparse' 'subdomain'[OPT] ( domain-expression )

   sign: one of
     + -

   double-quote-delimited-characters:
     string-character double-quote-delimited-characters[OPT]
     ' double-quote-delimited-characters[OPT]

   single-quote-delimited-characters:
     string-character single-quote-delimited-characters[OPT]
     " single-quote-delimited-characters[OPT]

   uninterpreted-double-quote-delimited-characters:
     uninterpreted-double-quote-string-character uninterpreted-double-quote-delimited-characters[OPT]

   uninterpreted-single-quote-delimited-characters:
     uninterpreted-single-quote-string-character uninterpreted-single-quote-delimited-characters[OPT]

   range-expression-list:
     range-expression
     range-expression, range-expression-list

   associative-expression-list:
      non-range-expression
      non-range-expression, associative-expression-list

   associative-expr-list:
     index-expr => value-expr
     index-expr => value-expr, associative-expr-list

   slicing-index-set:
     domain-expression
     range-expression-list

   task-private-var-kind:
     'const'
     'var'
     'ref'

   rectangular-domain-type:
     'domain' ( named-expression-list )

   associative-domain-type:
     'domain' ( associative-index-type )

   string-character:
     any character except the double quote, single quote, or new line
     simple-escape-character
     hexadecimal-escape-character

   uninterpreted-double-quote-string-character:
     any character except three double quotes in a row

   uninterpreted-single-quote-string-character:
     any character except three single quotes in a row

   range-expression:
     expression
     strided-range-expression
     counted-range-expression
     aligned-range-expression
     sliced-range-expression

   non-range-expression:
      expression

   index-expr:
     expression

   value-expr:
     expression

   associative-index-type:
     type-expression

   simple-escape-character: one of
     \' \" \? \\ \a \b \f \n \r \t \v

   hexadecimal-escape-character:
     '\x' hexadecimal-digits

   strided-range-expression:
     range-expression 'by' step-expression

   counted-range-expression:
     range-expression # expression

   aligned-range-expression:
     range-expression 'align' expression

   sliced-range-expression:
     range-expression ( range-expression )
     range-expression [ range-expression ]

   step-expression:
     expression

